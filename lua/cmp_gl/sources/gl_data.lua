local descriptions = {
  [[GlUniform Specify the value of a uniform variable for the current program object
---
### Parameters
`location` Specifies the location of the uniform variable to be modified.
`count` For the vector ( `glUniform*v` ) commands, specifies the number of elements that are to
be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it
is an array.

For the matrix ( `glUniformMatrix*` ) commands, specifies the number of matrices that are to be
modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or
more if it is an array of matrices.

`transpose` For the matrix commands, specifies whether to transpose the matrix as the values
are loaded into the uniform variable.
`v0`, `v1`, `v2`, `v3` For the scalar commands, specifies the new values to be used for
the specified uniform variable.
`value` For the vector and matrix commands, specifies a pointer to an array of `count` values
that will be used to update the specified uniform variable.

---
### Description
`glUniform` modifies the value of a uniform variable or a uniform variable array. The location of
the uniform variable to be modified is specified by `location`, which should be a value returned
by glGetUniformLocation. `glUniform` operates on the program object that was made part of
current state by calling glUseProgram.

The commands `glUniform{1|2|3|4}{f|i|ui}` are used to change the value of the uniform variable
specified by `location` using the values passed as arguments. The number specified in the command
should match the number of components in the data type of the specified uniform variable (e.g., `1`
for float, int, unsigned int, bool ; `2` for vec2, ivec2, uvec2, bvec2, etc.). The
suffix `f` indicates that floating-point values are being passed; the suffix `i` indicates that
integer values are being passed; the suffix `ui` indicates that unsigned integer values are being
passed, and this type should also match the data type of the specified uniform variable. The `i`
variants of this function should be used to provide values for uniform variables defined as int,
ivec2, ivec3, ivec4, or arrays of these. The `ui` variants of this function should be used to
provide values for uniform variables defined as unsigned int, uvec2, uvec3, uvec4, or arrays
of these. The `f` variants should be used to provide values for uniform variables of type float,
vec2, vec3, vec4, or arrays of these. Either the `i`, `ui` or `f` variants may be used
to provide values for uniform variables of type bool, bvec2, bvec3, bvec4, or arrays of
these. The uniform variable will be set to false if the input value is 0 or 0.0f, and it will be
set to true otherwise.

All active uniform variables defined in a program object are initialized to 0 when the program
object is linked successfully. They retain the values assigned to them by a call to `glUniform `
until the next successful link operation occurs on the program object, when they are once again
initialized to 0.

The commands `glUniform{1|2|3|4}{f|i|ui}v` can be used to modify a single uniform variable or a
uniform variable array. These commands pass a count and a pointer to the values to be loaded into a
uniform variable or a uniform variable array. A count of 1 should be used if modifying the value of
a single uniform variable, and a count of 1 or greater can be used to modify an entire array or part
of an array. When loading n elements starting at an arbitrary position m in a uniform variable
array, elements m + n - 1 in the array will be replaced with the new values. If `m` + `n` -
1 is larger than the size of the uniform variable array, values for all array elements beyond the
end of the array will be ignored. The number specified in the name of the command indicates the
number of components for each element in `value`, and it should match the number of components in
the data type of the specified uniform variable (e.g., `1` for float, int, bool; `2` for vec2,
ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for
the specified uniform variable as described previously for `glUniform{1|2|3|4}{f|i|ui}`.

For uniform variable arrays, each element of the array is considered to be of the type indicated in
the name of the command (e.g., `glUniform3f` or `glUniform3fv` can be used to load a uniform
variable array of type vec3). The number of elements of the uniform variable array to be modified is
specified by `count`

The commands `glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv` are used to modify a matrix or an
array of matrices. The numbers in the command name are interpreted as the dimensionality of the
matrix. The number `2` indicates a 2 × 2 matrix (i.e., 4 values), the number `3` indicates a 3
× 3 matrix (i.e., 9 values), and the number `4` indicates a 4 × 4 matrix (i.e., 16 values).

Non-square matrix dimensionality is explicit, with the first number representing the number of
columns and the second number representing the number of rows. For example, `2x4` indicates a 2 ×
4 matrix with 2 columns and 4 rows (i.e., 8 values). If `transpose` is `GL_FALSE`, each matrix
is assumed to be supplied in column major order. If `transpose` is `GL_TRUE`, each matrix is
assumed to be supplied in row major order. The `count` argument indicates the number of matrices
to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count
greater than 1 can be used to modify an array of matrices.
---
### Notes
`glUniform1i` and `glUniform1iv` are the only two functions that may be used to load uniform
variables defined as sampler types. Loading samplers with any other function will result in a
`GL_INVALID_OPERATION` error.

If `count` is greater than 1 and the indicated uniform variable is not an array, a
`GL_INVALID_OPERATION` error is generated and the specified uniform variable will remain unchanged.

Other than the preceding exceptions, if the type and size of the uniform variable as defined in the
shader do not match the type and size specified in the name of the command used to load its value, a
`GL_INVALID_OPERATION` error will be generated and the specified uniform variable will remain
unchanged.

If `location` is a value other than -1 and it does not represent a valid uniform variable
location in the current program object, an error will be generated, and no changes will be made to
the uniform variable storage of the current program object. If `location` is equal to -1, the data
passed in will be silently ignored and the specified uniform variable will not be changed.
---
### Errors
`GL_INVALID_OPERATION` is generated if there is no current program object.

`GL_INVALID_OPERATION` is generated if the size of the uniform variable declared in the shader
does not match the size indicated by the `glUniform` command.

`GL_INVALID_OPERATION` is generated if one of the signed or unsigned integer variants of this
function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of
these, or if one of the floating-point variants of this function is used to load a uniform variable
of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of
these.

`GL_INVALID_OPERATION` is generated if one of the signed integer variants of this function is
used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of
these.

`GL_INVALID_OPERATION` is generated if one of the unsigned integer variants of this function is
used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.

`GL_INVALID_OPERATION` is generated if `location` is an invalid uniform location for the
current program object and `location` is not equal to -1.

`GL_INVALID_VALUE` is generated if `count` is less than 0.

`GL_INVALID_OPERATION` is generated if `count` is greater than 1 and the indicated uniform
variable is not an array variable.

`GL_INVALID_OPERATION` is generated if a sampler is loaded using a command other than
`glUniform1i` and `glUniform1iv`.
---
### Associated Gets
glGet with the argument `GL_CURRENT_PROGRAM`

glGetActiveUniform with the handle of a program object and the index of an active uniform
variable

glGetUniform with the handle of a program object and the location of a uniform variable

glGetUniformLocation with the handle of a program object and the name of a uniform variable
---
### Version Support
`glUniform1f` `glUniform1fv` `glUniform1i` `glUniform1iv` `glUniform1ui`
`glUniform1uiv` `glUniform2f` `glUniform2fv` `glUniform2i` `glUniform2iv`
`glUniform2ui` `glUniform2uiv` `glUniform3f` `glUniform3fv` `glUniform3i`
`glUniform3iv` `glUniform3ui` `glUniform3uiv` `glUniform4f` `glUniform4fv`
`glUniform4i` `glUniform4iv` `glUniform4ui` `glUniform4uiv` `glUniformMatrix2fv`
`glUniformMatrix2x3fv` `glUniformMatrix2x4fv` `glUniformMatrix3fv` `glUniformMatrix3x2fv`
`glUniformMatrix3x4fv` `glUniformMatrix4fv` `glUniformMatrix4x2fv` `glUniformMatrix4x3fv`
---
### See Also
glLinkProgram, glUseProgram
---
### Copyright
Copyright 2003-2005 3Dlabs Inc. Ltd. Copyright 2010-2014 Khronos Group. This material may be
distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8
June 1999. https://opencontent.org/openpub/.
]],
  [[Retrieve the range and precision for numeric formats supported by the shader compiler
---
### Parameters
`shaderType` Specifies the type of shader whose precision to query. `shaderType` must be
`GL_VERTEX_SHADER` or `GL_FRAGMENT_SHADER`.

`precisionType` Specifies the numeric format whose precision and range to query.
`range` Specifies the address of array of two integers into which encodings of the
implementation's numeric range are returned.
`precision` Specifies the address of an integer into which the numeric precision of the
implementation is written.
---
### Description
`glGetShaderPrecisionFormat` retrieves the numeric range and precision for the implementation's
representation of quantities in different numeric formats in specified shader type. `shaderType`
specifies the type of shader for which the numeric precision and range is to be retrieved and must
be one of `GL_VERTEX_SHADER` or `GL_FRAGMENT_SHADER`. `precisionType` specifies the numeric
format to query and must be one of `GL_LOW_FLOAT`, `GL_MEDIUM_FLOAT` `GL_HIGH_FLOAT`,
`GL_LOW_INT`, `GL_MEDIUM_INT`, or `GL_HIGH_INT`.

`range` points to an array of two integers into which the format's numeric range will be
returned. If min and max are the smallest values representable in the format, then the values
returned are defined to be: `range` [0] = floor(log2(|min|)) and `range` [1] = floor(log2(|max|)).

`precision` specifies the address of an integer into which will be written the log2 value of the
number of bits of precision of the format. If the smallest representable value greater than 1 is 1 +
eps, then the integer addressed by `precision` will contain floor(-log2(eps)).
---
### Errors
`GL_INVALID_ENUM` is generated if `shaderType` or `precisionType` is not an accepted value.
---
### Version Support
`glGetShaderPrecisionFormat`
---
### See Also
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Returns the source code string from a shader object
---
### Parameters
`shader` Specifies the shader object to be queried.
`bufSize` Specifies the size of the character buffer for storing the returned source code
string.
`length` Returns the length of the string returned in `source` (excluding the null
terminator).

`source` Specifies an array of characters that is used to return the source code string.
---
### Description
`glGetShaderSource` returns the concatenation of the source code strings from the shader object
specified by `shader`. The source code strings for a shader object are the result of a previous
call to glShaderSource. The string returned by the function will be null terminated.

`glGetShaderSource` returns in `source` as much of the source code string as it can, up to a
maximum of `bufSize` characters. The number of characters actually returned, excluding the null
termination character, is specified by `length`. If the length of the returned string is not
required, a value of `NULL` can be passed in the `length` argument. The size of the buffer
required to store the returned source code string can be obtained by calling glGetShader with the
value `GL_SHADER_SOURCE_LENGTH`.
---
### Errors
`GL_INVALID_VALUE` is generated if `shader` is not a value generated by OpenGL.

`GL_INVALID_OPERATION` is generated if `shader` is not a shader object.

`GL_INVALID_VALUE` is generated if `bufSize` is less than 0.
---
### Associated Gets
glGetShader with argument `GL_SHADER_SOURCE_LENGTH`

glIsShader
---
### Version Support
`glGetShaderSource`
---
### See Also
glCreateShader, glShaderSource
---
### Copyright
Copyright 2003-2005 3Dlabs Inc. Ltd. Copyright 2010-2014 Khronos Group. This material may be
distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8
June 1999. https://opencontent.org/openpub/.
]],
  [[Return a string describing the current GL connection
---
### Parameters
`name` Specifies a symbolic constant, one of `GL_VENDOR`, `GL_RENDERER`, `GL_VERSION`,
or `GL_SHADING_LANGUAGE_VERSION`. Additionally, `glGetStringi` accepts the `GL_EXTENSIONS`
token.

`index` For `glGetStringi`, specifies the index of the string to return.

---
### Description
`glGetString` returns a pointer to a static string describing some aspect of the current GL
connection. `name` can be one of the following:

`GL_VENDOR` Returns the company responsible for this GL implementation. This name does not
change from release to release.
`GL_RENDERER` Returns the name of the renderer. This name is typically specific to a particular
configuration of a hardware platform. It does not change from release to release.
`GL_VERSION` Returns a version or release number.
`GL_SHADING_LANGUAGE_VERSION` Returns a version or release number for the shading language.
`glGetStringi` returns a pointer to a static string indexed by `index`. `name` can be one of
the following:

`GL_EXTENSIONS` For `glGetStringi` only, returns the extension string supported by the
implementation at `index`.

Strings `GL_VENDOR` and `GL_RENDERER` together uniquely specify a platform. They do not change
from release to release and should be used by platform-recognition algorithms.

The `GL_VERSION` and `GL_SHADING_LANGUAGE_VERSION` strings begin with a version number. The
version number uses one of these forms:

major_number.minor_number major_number.minor_number.release_number

Vendor-specific information may follow the version number. Its format depends on the
implementation, but a space always separates the version number and the vendor-specific information.

All strings are null-terminated.
---
### Notes
If an error is generated, `glGetString` returns 0.

The client and server may support different versions. `glGetString` always returns a compatible
version number. The release number always describes the server.
---
### Errors
`GL_INVALID_ENUM` is generated if `name` is not an accepted value.

`GL_INVALID_VALUE` is generated by `glGetStringi` if `index` is outside the valid range for
indexed state `name`.
---
### Version Support
`glGetString` `glGetStringi`
---
### See Also
---
### Copyright
Copyright 1991-2006 Silicon Graphics, Inc. Copyright 2010-2014 Khronos Group. This document
is licensed under the SGI Free Software B License. For details, see
https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.
]],
  [[Retrieve the index of a subroutine uniform of a given shader stage within a program
---
### Parameters
`program` Specifies the name of the program containing shader stage.
`shadertype` Specifies the shader stage from which to query for subroutine uniform index.
`shadertype` must be one of `GL_VERTEX_SHADER`, `GL_TESS_CONTROL_SHADER`,
`GL_TESS_EVALUATION_SHADER`, `GL_GEOMETRY_SHADER` or `GL_FRAGMENT_SHADER`.

`name` Specifies the name of the subroutine uniform whose index to query.
---
### Description
`glGetSubroutineIndex` returns the index of a subroutine uniform within a shader stage attached
to a program object. `program` contains the name of the program to which the shader is attached.
`shadertype` specifies the stage from which to query shader subroutine index. `name` contains the
null-terminated name of the subroutine uniform whose name to query.

If `name` is not the name of a subroutine uniform in the shader stage, `GL_INVALID_INDEX` is
returned, but no error is generated. If `name` is the name of a subroutine uniform in the shader
stage, a value between zero and the value of `GL_ACTIVE_SUBROUTINES` minus one will be returned.

Subroutine indices are assigned using consecutive integers in the range from zero to the value of
`GL_ACTIVE_SUBROUTINES` minus one for the shader stage.
---
### Errors
`GL_INVALID_ENUM` is generated if `shadertype` or `pname` is not one of the accepted values.

`GL_INVALID_VALUE` is generated if `program` is not the name of an existing program object.
---
### Version Support
`glGetSubroutineIndex`
---
### See Also
glGetProgram, glGetActiveSubroutineUniform, glGetActiveSubroutineUniformName
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Retrieve the location of a subroutine uniform of a given shader stage within a program
---
### Parameters
`program` Specifies the name of the program containing shader stage.
`shadertype` Specifies the shader stage from which to query for subroutine uniform index.
`shadertype` must be one of `GL_VERTEX_SHADER`, `GL_TESS_CONTROL_SHADER`,
`GL_TESS_EVALUATION_SHADER`, `GL_GEOMETRY_SHADER` or `GL_FRAGMENT_SHADER`.

`name` Specifies the name of the subroutine uniform whose index to query.
---
### Description
`glGetSubroutineUniformLocation` returns the location of the subroutine uniform variable `name`
in the shader stage of type `shadertype` attached to `program`, with behavior otherwise
identical to glGetUniformLocation.

If `name` is not the name of a subroutine uniform in the shader stage, -1 is returned, but no
error is generated. If `name` is the name of a subroutine uniform in the shader stage, a value
between zero and the value of `GL_ACTIVE_SUBROUTINE_LOCATIONS` minus one will be returned.

Subroutine locations are assigned using consecutive integers in the range from zero to the value of
`GL_ACTIVE_SUBROUTINE_LOCATIONS` minus one for the shader stage. For active subroutine uniforms
declared as arrays, the declared array elements are assigned consecutive locations.
---
### Errors
`GL_INVALID_ENUM` is generated if `shadertype` or `pname` is not one of the accepted values.

`GL_INVALID_VALUE` is generated if `program` is not the name of an existing program object.
---
### Version Support
`glGetSubroutineUniformLocation`
---
### See Also
glGetProgram, glGetActiveSubroutineUniform, glGetActiveSubroutineUniformName,
glGetUniformLocation
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Query the properties of a sync object
---
### Parameters
`sync` Specifies the sync object whose properties to query.
`pname` Specifies the parameter whose value to retrieve from the sync object specified in
`sync`.

`bufSize` Specifies the size of the buffer whose address is given in `values`.

`length` Specifies the address of an variable to receive the number of integers placed in
`values`.

`values` Specifies the address of an array to receive the values of the queried parameter.
---
### Description
`glGetSynciv` retrieves properties of a sync object. `sync` specifies the name of the sync
object whose properties to retrieve.

On success, `glGetSynciv` replaces up to `bufSize` integers in `values` with the
corresponding property values of the object being queried. The actual number of integers replaced is
returned in the variable whose address is specified in `length`. If `length` is NULL, no
length is returned.

If `pname` is `GL_OBJECT_TYPE`, a single value representing the specific type of the sync
object is placed in `values`. The only type supported is `GL_SYNC_FENCE`.

If `pname` is `GL_SYNC_STATUS`, a single value representing the status of the sync object (
`GL_SIGNALED` or `GL_UNSIGNALED` ) is placed in `values`.

If `pname` is `GL_SYNC_CONDITION`, a single value representing the condition of the sync
object is placed in `values`. The only condition supported is `GL_SYNC_GPU_COMMANDS_COMPLETE`.

If `pname` is `GL_SYNC_FLAGS`, a single value representing the flags with which the sync
object was created is placed in `values`. No flags are currently supported `flags` is expected
to be used in future extensions to the sync objects.

If an error occurs, nothing will be written to `values` or `length`.
---
### Errors
`GL_INVALID_VALUE` is generated if `sync` is not the name of a sync object.

`GL_INVALID_ENUM` is generated if `pname` is not one of the accepted tokens.
---
### Version Support
`glGetSynciv`
---
### See Also
glFenceSync, glWaitSync, glClientWaitSync
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[GlGetTexImage Return a texture image
---
### Parameters
`target` Specifies the target to which the texture is bound for `glGetTexImage` and
`glGetnTexImage` functions. `GL_TEXTURE_1D`, `GL_TEXTURE_2D`, `GL_TEXTURE_3D`,
`GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_RECTANGLE`,
`GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`,
`GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`,
`GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`, and
`GL_TEXTURE_CUBE_MAP_ARRAY` are acceptable.

`texture` Specifies the texture object name.
`level` Specifies the level-of-detail number of the desired image. Level 0 is the base image
level. Level n is the n th mipmap reduction image.

`format` Specifies a pixel format for the returned data. The supported formats are
`GL_STENCIL_INDEX`, `GL_DEPTH_COMPONENT`, `GL_DEPTH_STENCIL`, `GL_RED`, `GL_GREEN`,
`GL_BLUE`, `GL_RG`, `GL_RGB`, `GL_RGBA`, `GL_BGR`, `GL_BGRA`, `GL_RED_INTEGER`,
`GL_GREEN_INTEGER`, `GL_BLUE_INTEGER`, `GL_RG_INTEGER`, `GL_RGB_INTEGER`, `GL_RGBA_INTEGER`,
`GL_BGR_INTEGER`, `GL_BGRA_INTEGER`.

`type` Specifies a pixel type for the returned data. The supported types are `GL_UNSIGNED_BYTE`,
`GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`,
`GL_HALF_FLOAT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`,
`GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`,
`GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`,
`GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`,
`GL_UNSIGNED_INT_2_10_10_10_REV`, `GL_UNSIGNED_INT_24_8`, `GL_UNSIGNED_INT_10F_11F_11F_REV`,
`GL_UNSIGNED_INT_5_9_9_9_REV`, and `GL_FLOAT_32_UNSIGNED_INT_24_8_REV`.

`bufSize` Specifies the size of the buffer `pixels` for `glGetnTexImage` and
`glGetTextureImage` functions.

`pixels` Returns the texture image. Should be a pointer to an array of the type specified by
`type`.

---
### Description
`glGetTexImage`, `glGetnTexImage` and `glGetTextureImage` functions return a texture image
into `pixels`. For `glGetTexImage` and `glGetnTexImage`, `target` specifies whether the
desired texture image is one specified by glTexImage1D ( `GL_TEXTURE_1D` ), glTexImage2D (
`GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_RECTANGLE`, `GL_TEXTURE_2D` or any of
`GL_TEXTURE_CUBE_MAP_*` ), or glTexImage3D ( `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_3D`,
`GL_TEXTURE_CUBE_MAP_ARRAY` ). For `glGetTextureImage`, `texture` specifies the texture object
name. In addition to types of textures accepted by `glGetTexImage` and `glGetnTexImage`, the
function also accepts cube map texture objects (with effective target `GL_TEXTURE_CUBE_MAP` ).
`level` specifies the level-of-detail number of the desired image. `format` and `type` specify
the format and type of the desired image array. See the reference page for glTexImage1D for a
description of the acceptable values for the `format` and `type` parameters, respectively. For
glGetnTexImage and glGetTextureImage functions, bufSize tells the size of the buffer to receive the
retrieved pixel data. `glGetnTexImage` and `glGetTextureImage` do not write more than `bufSize`
bytes into `pixels`.

If a non-zero named buffer object is bound to the `GL_PIXEL_PACK_BUFFER` target (see
glBindBuffer ) while a texture image is requested, `pixels` is treated as a byte offset into the
buffer object's data store.

To understand the operation of `glGetTexImage`, consider the selected internal four-component
texture image to be an RGBA color buffer the size of the image. The semantics of `glGetTexImage`
are then identical to those of glReadPixels, with the exception that no pixel transfer operations
are performed, when called with the same `format` and `type`, with x and y set to 0, width
set to the width of the texture image and height set to 1 for 1D images, or to the height of the
texture image for 2D images.

If the selected texture image does not contain four components, the following mappings are applied.

Single-component textures are treated as RGBA buffers with red set to the single-component value,
green set to 0, blue set to 0, and alpha set to 1. Two-component textures are treated as RGBA
buffers with red set to the value of component zero, alpha set to the value of component one, and
green and blue set to 0. Finally, three-component textures are treated as RGBA buffers with red set
to component zero, green set to component one, blue set to component two, and alpha set to 1. To
determine the required size of `pixels`, use glGetTexLevelParameter to determine the dimensions
of the internal texture image, then scale the required number of pixels by the storage required for
each pixel, based on `format` and `type`. Be sure to take the pixel storage parameters into
account, especially `GL_PACK_ALIGNMENT`.

If `glGetTextureImage` is used against a cube map texture object, the texture is treated as a
three-dimensional image of a depth of 6, where the cube map faces are ordered as image layers, in an
order presented in the table below:

Layer number Cube Map Face 0 GL_TEXTURE_CUBE_MAP_POSITIVE_X 1 GL_TEXTURE_CUBE_MAP_NEGATIVE_X
2 GL_TEXTURE_CUBE_MAP_POSITIVE_Y 3 GL_TEXTURE_CUBE_MAP_NEGATIVE_Y 4
GL_TEXTURE_CUBE_MAP_POSITIVE_Z 5 GL_TEXTURE_CUBE_MAP_NEGATIVE_Z
---
### Notes
If an error is generated, no change is made to the contents of `pixels`.

`glGetTexImage` and `glGetnTexImage` return the texture image for the active texture unit.

`GL_STENCIL_INDEX` is accepted for `format` only if the GL version is 4.4 or greater.
]],
  [[Set texture parameters
---
### Parameters
`target` Specifies the target to which the texture is bound for `glTexParameter` functions.

Must be one of `GL_TEXTURE_1D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D`, `GL_TEXTURE_2D_ARRAY`,
`GL_TEXTURE_2D_MULTISAMPLE`, `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`, `GL_TEXTURE_3D`,
`GL_TEXTURE_CUBE_MAP`, `GL_TEXTURE_CUBE_MAP_ARRAY`, or `GL_TEXTURE_RECTANGLE`.

`texture` Specifies the texture object name for `glTextureParameter` functions.

`pname` Specifies the symbolic name of a single-valued texture parameter. `pname` can be one
of the following: `GL_DEPTH_STENCIL_TEXTURE_MODE`, `GL_TEXTURE_BASE_LEVEL`,
`GL_TEXTURE_COMPARE_FUNC`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_LOD_BIAS`,
`GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`,
`GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`,
`GL_TEXTURE_SWIZZLE_B`, `GL_TEXTURE_SWIZZLE_A`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, or
`GL_TEXTURE_WRAP_R`.

For the vector commands ( `glTexParameter*v` ), `pname` can also be one of
`GL_TEXTURE_BORDER_COLOR` or `GL_TEXTURE_SWIZZLE_RGBA`.

`param` For the scalar commands, specifies the value of `pname`.

`params` For the vector commands, specifies a pointer to an array where the value or values of
`pname` are stored.
]],
  [[Simultaneously specify storage for all levels of a one-dimensional texture
---
### Parameters
`target` Specifies the target to which the texture object is bound for `glTexStorage1D`.

Must be one of `GL_TEXTURE_1D` or `GL_PROXY_TEXTURE_1D`.

`texture` Specifies the texture object name for `glTextureStorage1D`. The effective target of
`texture` must be one of the valid non-proxy `target` values above.

`levels` Specify the number of texture levels.
`internalformat` Specifies the sized internal format to be used to store texture image data.
`width` Specifies the width of the texture, in texels.
---
### Description
`glTexStorage1D` and `glTextureStorage1D` specify the storage requirements for all levels of a
one-dimensional texture simultaneously. Once a texture is specified with this command, the format
and dimensions of all levels become immutable unless it is a proxy texture. The contents of the
image may still be modified, however, its storage requirements may not change. Such a texture is
referred to as an immutable-format texture.

Calling `glTexStorage1D` is equivalent, assuming no errors are generated, to executing the
following pseudo-code:

for (i = 0; i < levels; i++) { glTexImage1D(target, i, internalformat, width, 0, format, type,
NULL); width = max(1, (width / 2)); } Calling `glTextureStorage1D` is equivalent to the above
pseudo-code, where `target` is the effective target of `texture` and it is as if `texture`
were bound to `target` for the purposes of `glTexImage1D`.

Since no texture data is actually provided, the values used in the pseudo-code for `format` and
`type` are irrelevant and may be considered to be any values that are legal for the chosen
`internalformat` enumerant. `internalformat` must be one of the sized internal formats given in
Table 1 below, one of the sized depth-component formats `GL_DEPTH_COMPONENT32F`,
`GL_DEPTH_COMPONENT24`, or `GL_DEPTH_COMPONENT16`, one of the combined depth-stencil formats,
`GL_DEPTH32F_STENCIL8`, or `GL_DEPTH24_STENCIL8`, or the stencil-only format,
`GL_STENCIL_INDEX8`. Upon success, the value of `GL_TEXTURE_IMMUTABLE_FORMAT` becomes `GL_TRUE`.
The value of `GL_TEXTURE_IMMUTABLE_FORMAT` may be discovered by calling glGetTexParameter
with `pname` set to `GL_TEXTURE_IMMUTABLE_FORMAT`. No further changes to the dimensions or
format of the texture object may be made. Using any command that might alter the dimensions or
format of the texture object (such as glTexImage1D or another call to `glTexStorage1D` ) will
result in the generation of a `GL_INVALID_OPERATION` error, even if it would not, in fact, alter
the dimensions or format of the object.

---
### Notes
`GL_STENCIL_INDEX8` is accepted for `internalformat` only if the GL version is 4.4 or higher.
]],
  [[Return texture parameter values for a specific level of detail
---
### Parameters
`target` Specifies the target to which the texture is bound for `glGetTexLevelParameterfv`
and `glGetTexLevelParameteriv` functions. Must be one of the following values: `GL_TEXTURE_1D`,
`GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D_ARRAY`,
`GL_TEXTURE_RECTANGLE`, `GL_TEXTURE_2D_MULTISAMPLE`, `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`,
`GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`,
`GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`,
`GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`, `GL_PROXY_TEXTURE_1D`,
`GL_PROXY_TEXTURE_2D`, `GL_PROXY_TEXTURE_3D`, `GL_PROXY_TEXTURE_1D_ARRAY`,
`GL_PROXY_TEXTURE_2D_ARRAY`, `GL_PROXY_TEXTURE_RECTANGLE`, `GL_PROXY_TEXTURE_2D_MULTISAMPLE`,
`GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY`, `GL_PROXY_TEXTURE_CUBE_MAP`, or `GL_TEXTURE_BUFFER`.

`texture` Specifies the texture object name for `glGetTextureLevelParameterfv` and
`glGetTextureLevelParameteriv` functions.

`level` Specifies the level-of-detail number of the desired image. Level 0 is the base image
level. Level n is the n th mipmap reduction image.

`pname` Specifies the symbolic name of a texture parameter. `GL_TEXTURE_WIDTH`,
`GL_TEXTURE_HEIGHT`, `GL_TEXTURE_DEPTH`, `GL_TEXTURE_INTERNAL_FORMAT`, `GL_TEXTURE_RED_SIZE`,
`GL_TEXTURE_GREEN_SIZE`, `GL_TEXTURE_BLUE_SIZE`, `GL_TEXTURE_ALPHA_SIZE`,
`GL_TEXTURE_DEPTH_SIZE`, `GL_TEXTURE_COMPRESSED`, `GL_TEXTURE_COMPRESSED_IMAGE_SIZE`, and
`GL_TEXTURE_BUFFER_OFFSET` are accepted.

`params` Returns the requested data.
---
### Description
`glGetTexLevelParameterfv`, `glGetTexLevelParameteriv`, `glGetTextureLevelParameterfv` and
`glGetTextureLevelParameteriv` return in `params` texture parameter values for a specific
level-of-detail value, specified as `level`. For the first two functions, `target` defines the
target texture, either `GL_TEXTURE_1D`, `GL_TEXTURE_2D`, `GL_TEXTURE_3D`,
`GL_PROXY_TEXTURE_1D`, `GL_PROXY_TEXTURE_2D`, `GL_PROXY_TEXTURE_3D`,
`GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`,
`GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`,
`GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`, or
`GL_PROXY_TEXTURE_CUBE_MAP`. The remaining two take a `texture` argument which specifies the name
of the texture object.

`GL_MAX_TEXTURE_SIZE`, and `GL_MAX_3D_TEXTURE_SIZE` are not really descriptive enough. It has
to report the largest square texture image that can be accommodated with mipmaps but a long skinny
texture, or a texture without mipmaps may easily fit in texture memory. The proxy targets allow the
user to more accurately query whether the GL can accommodate a texture of a given configuration. If
the texture cannot be accommodated, the texture state variables, which may be queried with
`glGetTexLevelParameter` and `glGetTextureLevelParameter`, are set to 0. If the texture can be
accommodated, the texture state values will be set as they would be set for a non-proxy target.

`pname` specifies the texture parameter whose value or values will be returned.

The accepted parameter names are as follows: `GL_TEXTURE_WIDTH` `params` returns a single
value, the width of the texture image. The initial value is 0.

`GL_TEXTURE_HEIGHT` `params` returns a single value, the height of the texture image. The
initial value is 0.

`GL_TEXTURE_DEPTH` `params` returns a single value, the depth of the texture image. The
initial value is 0.

`GL_TEXTURE_INTERNAL_FORMAT` `params` returns a single value, the internal format of the
texture image.

`GL_TEXTURE_RED_TYPE`, `GL_TEXTURE_GREEN_TYPE`, `GL_TEXTURE_BLUE_TYPE`,
`GL_TEXTURE_ALPHA_TYPE`, `GL_TEXTURE_DEPTH_TYPE` The data type used to store the component. The
types `GL_NONE`, `GL_SIGNED_NORMALIZED`, `GL_UNSIGNED_NORMALIZED`, `GL_FLOAT`, `GL_INT`,
and `GL_UNSIGNED_INT` may be returned to indicate signed normalized fixed-point, unsigned
normalized fixed-point, floating-point, integer unnormalized, and unsigned integer unnormalized
components, respectively.

`GL_TEXTURE_RED_SIZE`, `GL_TEXTURE_GREEN_SIZE`, `GL_TEXTURE_BLUE_SIZE`,
`GL_TEXTURE_ALPHA_SIZE`, `GL_TEXTURE_DEPTH_SIZE` The internal storage resolution of an
individual component. The resolution chosen by the GL will be a close match for the resolution
requested by the user with the component argument of glTexImage1D, glTexImage2D,
glTexImage3D, glCopyTexImage1D, and glCopyTexImage2D. The initial value is 0.

`GL_TEXTURE_COMPRESSED` `params` returns a single boolean value indicating if the texture
image is stored in a compressed internal format. The initial value is `GL_FALSE`.

`GL_TEXTURE_COMPRESSED_IMAGE_SIZE` `params` returns a single integer value, the number of
unsigned bytes of the compressed texture image that would be returned from glGetCompressedTexImage.

`GL_TEXTURE_BUFFER_OFFSET` `params` returns a single integer value, the offset into the data
store of the buffer bound to a buffer texture. glTexBufferRange.

`GL_TEXTURE_BUFFER_SIZE` `params` returns a single integer value, the size of the range of a
data store of the buffer bound to a buffer texture. glTexBufferRange.

---
### Notes
If an error is generated, no change is made to the contents of `params`.

`glGetTexLevelParameter` returns the texture level parameters for the active texture unit.

`GL_TEXTURE_BUFFER_OFFSET` and `GL_TEXTURE_BUFFER_SIZE` are available only if the GL version is
4.3 or greater.
---
### Errors
`GL_INVALID_OPERATION` is generated by `glGetTextureLevelParameterfv` and
`glGetTextureLevelParameteriv` functions if `texture` is not the name of an existing texture
object.

`GL_INVALID_ENUM` is generated by `glGetTexLevelParameterfv` and `glGetTexLevelParameteriv`
functions if `target` or `pname` is not an accepted value.

`GL_INVALID_VALUE` is generated if `level` is less than 0.

`GL_INVALID_VALUE` may be generated if `level` is greater than log 2 max, where max is
the returned value of `GL_MAX_TEXTURE_SIZE`.

`GL_INVALID_VALUE` is generated if `target` is `GL_TEXTURE_BUFFER` and `level` is not zero.

`GL_INVALID_OPERATION` is generated if `GL_TEXTURE_COMPRESSED_IMAGE_SIZE` is queried on texture
images with an uncompressed internal format or on proxy targets.
---
### Version Support
`glGetTexLevelParameterfv` `glGetTexLevelParameteriv` `glGetTextureLevelParameterfv`
`glGetTextureLevelParameteriv`
---
### See Also
glActiveTexture, glGetTexParameter, glCopyTexImage1D, glCopyTexImage2D,
glCopyTexSubImage1D, glCopyTexSubImage2D, glCopyTexSubImage3D, glTexImage1D,
glTexImage2D, glTexImage3D, glTexSubImage1D, glTexSubImage2D, glTexSubImage3D,
glTexParameter
---
### Copyright
Copyright 1991-2006 Silicon Graphics, Inc. Copyright 2010-2014 Khronos Group. This document
is licensed under the SGI Free Software B License. For details, see
https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.
]],
  [[Simultaneously specify storage for all levels of a two-dimensional or one-dimensional array texture
---
### Parameters
`target` Specifies the target to which the texture object is bound for `glTexStorage2D`.

Must be one of `GL_TEXTURE_2D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_RECTANGLE`,
`GL_TEXTURE_CUBE_MAP`, `GL_PROXY_TEXTURE_2D`, `GL_PROXY_TEXTURE_1D_ARRAY`,
`GL_PROXY_TEXTURE_RECTANGLE`, or `GL_PROXY_TEXTURE_CUBE_MAP`.

`texture` Specifies the texture object name for `glTextureStorage2D`. The effective target of
`texture` must be one of the valid non-proxy `target` values above.

`levels` Specify the number of texture levels.
`internalformat` Specifies the sized internal format to be used to store texture image data.
`width` Specifies the width of the texture, in texels.
`height` Specifies the height of the texture, in texels.
---
### Description
`glTexStorage2D` and `glTextureStorage2D` specify the storage requirements for all levels of a
two-dimensional texture or one-dimensional texture array simultaneously. Once a texture is specified
with this command, the format and dimensions of all levels become immutable unless it is a proxy
texture. The contents of the image may still be modified, however, its storage requirements may not
change. Such a texture is referred to as an immutable-format texture.

The behavior of `glTexStorage2D` depends on the `target` parameter. When `target` is
`GL_TEXTURE_2D`, `GL_PROXY_TEXTURE_2D`, `GL_TEXTURE_RECTANGLE`, `GL_PROXY_TEXTURE_RECTANGLE`
or `GL_PROXY_TEXTURE_CUBE_MAP`, calling `glTexStorage2D` is equivalent, assuming no errors are
generated, to executing the following pseudo-code:

for (i = 0; i < levels; i++) { glTexImage2D(target, i, internalformat, width, height, 0, format,
type, NULL); width = max(1, (width / 2)); height = max(1, (height / 2)); } When `target` is
`GL_TEXTURE_CUBE_MAP`, `glTexStorage2D` is equivalent to:

for (i = 0; i < levels; i++) { for (face in (+X, -X, +Y, -Y, +Z, -Z)) { glTexImage2D(face, i,
internalformat, width, height, 0, format, type, NULL); } width = max(1, (width / 2)); height =
max(1, (height / 2)); } When `target` is `GL_TEXTURE_1D_ARRAY` or `GL_PROXY_TEXTURE_1D_ARRAY`,
`glTexStorage2D` is equivalent to:

for (i = 0; i < levels; i++) { glTexImage2D(target, i, internalformat, width, height, 0, format,
type, NULL); width = max(1, (width / 2)); } Calling `glTextureStorage2D` is equivalent to the
above pseudo-code, where `target` is the effective target of `texture` and it is as if
`texture` were bound to `target` for the purposes of `glTexImage2D`.

Since no texture data is actually provided, the values used in the pseudo-code for `format` and
`type` are irrelevant and may be considered to be any values that are legal for the chosen
`internalformat` enumerant. `internalformat` must be one of the sized internal formats given in
Table 1 below, one of the sized depth-component formats `GL_DEPTH_COMPONENT32F`,
`GL_DEPTH_COMPONENT24`, or `GL_DEPTH_COMPONENT16`, one of the combined depth-stencil formats,
`GL_DEPTH32F_STENCIL8`, or `GL_DEPTH24_STENCIL8`, or the stencil-only format,
`GL_STENCIL_INDEX8`. Upon success, the value of `GL_TEXTURE_IMMUTABLE_FORMAT` becomes `GL_TRUE`.
The value of `GL_TEXTURE_IMMUTABLE_FORMAT` may be discovered by calling glGetTexParameter
with `pname` set to `GL_TEXTURE_IMMUTABLE_FORMAT`. No further changes to the dimensions or
format of the texture object may be made. Using any command that might alter the dimensions or
format of the texture object (such as glTexImage2D or another call to `glTexStorage2D` ) will
result in the generation of a `GL_INVALID_OPERATION` error, even if it would not, in fact, alter
the dimensions or format of the object.

---
### Notes
`GL_STENCIL_INDEX8` is accepted for `internalformat` only if the GL version is 4.4 or higher.
]],
  [[Specify storage for a two-dimensional multisample texture
---
### Parameters
`target` Specifies the target to which the texture object is bound for
`glTexStorage2DMultisample`. Must be one of `GL_TEXTURE_2D_MULTISAMPLE` or
`GL_PROXY_TEXTURE_2D_MULTISAMPLE`.

`texture` Specifies the texture object name for `glTextureStorage2DMultisample`. The
effective target of `texture` must be one of the valid non-proxy `target` values above.

`samples` Specify the number of samples in the texture.
`internalformat` Specifies the sized internal format to be used to store texture image data.
`width` Specifies the width of the texture, in texels.
`height` Specifies the height of the texture, in texels.
`fixedsamplelocations` Specifies whether the image will use identical sample locations and the
same number of samples for all texels in the image, and the sample locations will not depend on the
internal format or size of the image.
---
### Description
`glTexStorage2DMultisample` and `glTextureStorage2DMultisample` specify the storage
requirements for a two-dimensional multisample texture. Once a texture is specified with this
command, its format and dimensions become immutable unless it is a proxy texture. The contents of
the image may still be modified, however, its storage requirements may not change. Such a texture is
referred to as an immutable-format texture.

`samples` specifies the number of samples to be used for the texture and must be greater than
zero and less than or equal to the value of `GL_MAX_SAMPLES`. `internalformat` must be a
color-renderable, depth-renderable, or stencil-renderable format. `width` and `height` specify
the width and height, respectively, of the texture. If `fixedsamplelocations` is `GL_TRUE`, the
image will use identical sample locations and the same number of samples for all texels in the
image, and the sample locations will not depend on the internal format or size of the image.

---
### Errors
`GL_INVALID_OPERATION` is generated by `glTexStorage2DMultisample` if zero is bound to
`target`.

`GL_INVALID_OPERATION` is generated by `glTextureStorage2DMultisample` if `texture` is not
the name of an existing texture object.

`GL_INVALID_ENUM` is generated if `internalformat` is not a valid color-renderable,
depth-renderable or stencil-renderable format.

`GL_INVALID_ENUM` is generated if `target` or the effective target of `texture` is not one of
the accepted targets described above.

`GL_INVALID_VALUE` is generated if `width` or `height` are less than 1 or greater than the
value of `GL_MAX_TEXTURE_SIZE`.

`GL_INVALID_VALUE` is generated if `levels` is less than 1.

`GL_INVALID_VALUE` is generated if `samples` is zero.

`GL_INVALID_OPERATION` is generated if `samples` is greater than the maximum number of samples
supported for this `target` and `internalformat`.

`GL_INVALID_OPERATION` is generated if the value of `GL_TEXTURE_IMMUTABLE_FORMAT` for the
texture bound to `target` is not `GL_FALSE`.
---
### Version Support
`glTexStorage2DMultisample` `glTextureStorage2DMultisample`
---
### See Also
glTexImage2D, glTexImage2DMultisample, glTexStorage1D, glTexStorage3D.
---
### Copyright
Copyright 2013-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Return texture parameter values
---
### Parameters
`target` Specifies the target to which the texture is bound for `glGetTexParameterfv`,
`glGetTexParameteriv`, `glGetTexParameterIiv`, and `glGetTexParameterIuiv` functions.
`GL_TEXTURE_1D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D`, `GL_TEXTURE_2D_ARRAY`,
`GL_TEXTURE_2D_MULTISAMPLE`, `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`, `GL_TEXTURE_3D`,
`GL_TEXTURE_CUBE_MAP`, `GL_TEXTURE_RECTANGLE`, and `GL_TEXTURE_CUBE_MAP_ARRAY` are accepted.

`texture` Specifies the texture object name for `glGetTextureParameterfv`,
`glGetTextureParameteriv`, `glGetTextureParameterIiv`, and `glGetTextureParameterIuiv`
functions.

`pname` Specifies the symbolic name of a texture parameter. `GL_DEPTH_STENCIL_TEXTURE_MODE`,
`GL_IMAGE_FORMAT_COMPATIBILITY_TYPE`, `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_BORDER_COLOR`,
`GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_COMPARE_FUNC`, `GL_TEXTURE_IMMUTABLE_FORMAT`,
`GL_TEXTURE_IMMUTABLE_LEVELS`, `GL_TEXTURE_LOD_BIAS`, `GL_TEXTURE_MAG_FILTER`,
`GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MIN_LOD`,
`GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`, `GL_TEXTURE_SWIZZLE_B`, `GL_TEXTURE_SWIZZLE_A`,
`GL_TEXTURE_SWIZZLE_RGBA`, `GL_TEXTURE_TARGET`, `GL_TEXTURE_VIEW_MIN_LAYER`,
`GL_TEXTURE_VIEW_MIN_LEVEL`, `GL_TEXTURE_VIEW_NUM_LAYERS`, `GL_TEXTURE_VIEW_NUM_LEVELS`,
`GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, and `GL_TEXTURE_WRAP_R` are accepted.

`params` Returns the texture parameters.
---
### Description
`glGetTexParameter` and `glGetTextureParameter` return in `params` the value or values of the
texture parameter specified as `pname`. `target` defines the target texture. `GL_TEXTURE_1D`,
`GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D_ARRAY`,
`GL_TEXTURE_RECTANGLE`, `GL_TEXTURE_CUBE_MAP`, `GL_TEXTURE_CUBE_MAP_ARRAY`,
`GL_TEXTURE_2D_MULTISAMPLE`, or `GL_TEXTURE_2D_MULTISAMPLE_ARRAY` specify one-, two-, or
three-dimensional, one-dimensional array, two-dimensional array, rectangle, cube-mapped or
cube-mapped array, two-dimensional multisample, or two-dimensional multisample array texturing,
respectively. `pname` accepts the same symbols as glTexParameter, with the same
interpretations:

`GL_DEPTH_STENCIL_TEXTURE_MODE` Returns the single-value depth stencil texture mode, a symbolic
constant. The initial value is `GL_DEPTH_COMPONENT`.

`GL_TEXTURE_MAG_FILTER` Returns the single-valued texture magnification filter, a symbolic
constant. The initial value is `GL_LINEAR`.

`GL_TEXTURE_MIN_FILTER` Returns the single-valued texture minification filter, a symbolic
constant. The initial value is `GL_NEAREST_MIPMAP_LINEAR`.

`GL_TEXTURE_MIN_LOD` Returns the single-valued texture minimum level-of-detail value. The
initial value is -1000.

`GL_TEXTURE_MAX_LOD` Returns the single-valued texture maximum level-of-detail value. The
initial value is 1000.
`GL_TEXTURE_BASE_LEVEL` Returns the single-valued base texture mipmap level. The initial value
is 0.
`GL_TEXTURE_MAX_LEVEL` Returns the single-valued maximum texture mipmap array level. The initial
value is 1000.
`GL_TEXTURE_SWIZZLE_R` Returns the red component swizzle. The initial value is `GL_RED`.

`GL_TEXTURE_SWIZZLE_G` Returns the green component swizzle. The initial value is `GL_GREEN`.

`GL_TEXTURE_SWIZZLE_B` Returns the blue component swizzle. The initial value is `GL_BLUE`.

`GL_TEXTURE_SWIZZLE_A` Returns the alpha component swizzle. The initial value is `GL_ALPHA`.

`GL_TEXTURE_SWIZZLE_RGBA` Returns the component swizzle for all channels in a single query.
`GL_TEXTURE_WRAP_S` Returns the single-valued wrapping function for texture coordinate s, a
symbolic constant. The initial value is `GL_REPEAT`.

`GL_TEXTURE_WRAP_T` Returns the single-valued wrapping function for texture coordinate t, a
symbolic constant. The initial value is `GL_REPEAT`.

`GL_TEXTURE_WRAP_R` Returns the single-valued wrapping function for texture coordinate r, a
symbolic constant. The initial value is `GL_REPEAT`.

`GL_TEXTURE_BORDER_COLOR` Returns four integer or floating-point numbers that comprise the RGBA
color of the texture border. Floating-point values are returned in the range 0 1. Integer
values are returned as a linear mapping of the internal floating-point representation such that 1.0
maps to the most positive representable integer and -1.0 maps to the most negative representable
integer. The initial value is (0, 0, 0, 0).

`GL_TEXTURE_COMPARE_MODE` Returns a single-valued texture comparison mode, a symbolic constant.

The initial value is `GL_NONE`. See glTexParameter.

`GL_TEXTURE_COMPARE_FUNC` Returns a single-valued texture comparison function, a symbolic
constant. The initial value is `GL_LEQUAL`. See glTexParameter.

`GL_TEXTURE_VIEW_MIN_LEVEL` Returns a single-valued base level of a texture view relative to its
parent. The initial value is 0. See glTextureView.

`GL_TEXTURE_VIEW_NUM_LEVELS` Returns a single-valued number of levels of detail of a texture
view. See glTextureView.

`GL_TEXTURE_VIEW_MIN_LAYER` Returns a single-valued first level of a texture array view relative
to its parent. See glTextureView.

`GL_TEXTURE_VIEW_NUM_LAYERS` Returns a single-valued number of layers in a texture array view.

See glTextureView.

`GL_TEXTURE_IMMUTABLE_LEVELS` Returns a single-valued number of immutable texture levels in a
texture view. See glTextureView.

In addition to the parameters that may be set with glTexParameter, `glGetTexParameter` and
`glGetTextureParameter` accept the following read-only parameters:

`GL_IMAGE_FORMAT_COMPATIBILITY_TYPE` Returns the matching criteria use for the texture when
used as an image texture. Can return `GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE`,
`GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS` or `GL_NONE`.

`GL_TEXTURE_IMMUTABLE_FORMAT` Returns non-zero if the texture has an immutable format. Textures
become immutable if their storage is specified with glTexStorage1D, glTexStorage2D or
glTexStorage3D. The initial value is `GL_FALSE`.

`GL_TEXTURE_TARGET` Returns the effective target of the texture object. For
`glGetTex*Parameter` functions, this is the target parameter. For `glGetTextureParameter*`, it is
the target to which the texture was initially bound when it was created, or the value of the target
parameter to the call to `glCreateTextures` which created the texture.

---
### Notes
If an error is generated, no change is made to the contents of `params`.

`GL_IMAGE_FORMAT_COMPATIBILITY_TYPE` is available only if the GL version is 4.2 or greater.

`GL_DEPTH_STENCIL_TEXTURE_MODE`, `GL_TEXTURE_VIEW_MIN_LEVEL`, `GL_TEXTURE_VIEW_NUM_LEVELS`,
`GL_TEXTURE_VIEW_MIN_LAYER`, `GL_TEXTURE_VIEW_NUM_LAYERS` and `GL_TEXTURE_IMMUTABLE_LEVELS` are
available only if the GL version is 4.3 or greater.

`GL_TEXTURE_TARGET` are available only if the GL version is 4.5 or greater.
---
### Errors
`GL_INVALID_ENUM` is generated if `pname` is not an accepted value.

`GL_INVALID_ENUM` error is generated by `glGetTexParameter` if the effective `target` is not
one of the accepted texture targets.

`GL_INVALID_OPERATION` is generated by `glGetTextureParameter*` if `texture` is not the name
of an existing texture object.
---
### Version Support
`glGetTexParameterIiv` `glGetTexParameterIuiv` `glGetTexParameterfv`
`glGetTexParameteriv` `glGetTextureParameterIiv` `glGetTextureParameterIuiv`
`glGetTextureParameterfv` `glGetTextureParameteriv`
---
### See Also
glTexParameter, `glTextureParameter`, glTexStorage1D, glTexStorage2D, glTexStorage3D,
`glTextureStorage1D`, `glTextureStorage2D`, `glTextureStorage3D`, glTextureView
---
### Copyright
Copyright 1991-2006 Silicon Graphics, Inc. Copyright 2010-2014 Khronos Group. This document
is licensed under the SGI Free Software B License. For details, see
https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.
]],
  [[Simultaneously specify storage for all levels of a three-dimensional, two-dimensional array or
cube-map array texture
---
### Parameters
`target` Specifies the target to which the texture object is bound for `glTexStorage3D`.

Must be one of `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_CUBE_MAP_ARRAY`,
`GL_PROXY_TEXTURE_3D`, `GL_PROXY_TEXTURE_2D_ARRAY` or `GL_PROXY_TEXTURE_CUBE_MAP_ARRAY`.

`texture` Specifies the texture object name for `glTextureStorage3D`. The effective target of
`texture` must be one of the valid non-proxy `target` values above.

`levels` Specify the number of texture levels.
`internalformat` Specifies the sized internal format to be used to store texture image data.
`width` Specifies the width of the texture, in texels.
`height` Specifies the height of the texture, in texels.
`depth` Specifies the depth of the texture, in texels.
---
### Description
`glTexStorage3D` and `glTextureStorage3D` specify the storage requirements for all levels of a
three-dimensional, two-dimensional array or cube-map array texture simultaneously. Once a texture is
specified with this command, the format and dimensions of all levels become immutable unless it is a
proxy texture. The contents of the image may still be modified, however, its storage requirements
may not change. Such a texture is referred to as an immutable-format texture.

The behavior of `glTexStorage3D` depends on the `target` parameter. When `target` is
`GL_TEXTURE_3D`, or `GL_PROXY_TEXTURE_3D`, calling `glTexStorage3D` is equivalent, assuming no
errors are generated, to executing the following pseudo-code:

for (i = 0; i < levels; i++) { glTexImage3D(target, i, internalformat, width, height, depth, 0,
format, type, NULL); width = max(1, (width / 2)); height = max(1, (height / 2)); depth = max(1,
(depth / 2)); } When `target` is `GL_TEXTURE_2D_ARRAY`, `GL_PROXY_TEXTURE_2D_ARRAY`,
`GL_TEXTURE_CUBE_MAP_ARRAY`, or `GL_PROXY_TEXTURE_CUBE_MAP_ARRAY`, `glTexStorage3D` is
equivalent to:

for (i = 0; i < levels; i++) { glTexImage3D(target, i, internalformat, width, height, depth, 0,
format, type, NULL); width = max(1, (width / 2)); height = max(1, (height / 2)); } Calling
`glTextureStorage3D` is equivalent to the above pseudo-code, where `target` is the effective
target of `texture` and it is as if `texture` were bound to `target` for the purposes of
`glTexImage3D`.

Since no texture data is actually provided, the values used in the pseudo-code for `format` and
`type` are irrelevant and may be considered to be any values that are legal for the chosen
`internalformat` enumerant. `internalformat` must be one of the sized internal formats given in
Table 1 below, one of the sized depth-component formats `GL_DEPTH_COMPONENT32F`,
`GL_DEPTH_COMPONENT24`, or `GL_DEPTH_COMPONENT16`, one of the combined depth-stencil formats,
`GL_DEPTH32F_STENCIL8`, or `GL_DEPTH24_STENCIL8`, or the stencil-only format,
`GL_STENCIL_INDEX8`. Upon success, the value of `GL_TEXTURE_IMMUTABLE_FORMAT` becomes `GL_TRUE`.
The value of `GL_TEXTURE_IMMUTABLE_FORMAT` may be discovered by calling glGetTexParameter
with `pname` set to `GL_TEXTURE_IMMUTABLE_FORMAT`. No further changes to the dimensions or
format of the texture object may be made. Using any command that might alter the dimensions or
format of the texture object (such as glTexImage3D or another call to `glTexStorage3D` ) will
result in the generation of a `GL_INVALID_OPERATION` error, even if it would not, in fact, alter
the dimensions or format of the object.

---
### Notes
`GL_STENCIL_INDEX8` is accepted for `internalformat` only if the GL version is 4.4 or higher.
]],
  [[Specify storage for a two-dimensional multisample array texture
---
### Parameters
`target` Specifies the target to which the texture object is bound for
`glTexStorage3DMultisample`. Must be one of `GL_TEXTURE_2D_MULTISAMPLE_ARRAY` or
`GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY`.

`texture` Specifies the texture object name for `glTextureStorage3DMultisample`. The
effective target of `texture` must be one of the valid non-proxy `target` values above.

`samples` Specify the number of samples in the texture.
`internalformat` Specifies the sized internal format to be used to store texture image data.
`width` Specifies the width of the texture, in texels.
`height` Specifies the height of the texture, in texels.
`depth` Specifies the depth of the texture, in layers.
`fixedsamplelocations` Specifies whether the image will use identical sample locations and the
same number of samples for all texels in the image, and the sample locations will not depend on the
internal format or size of the image.
---
### Description
`glTexStorage3DMultisample` and `glTextureStorage3DMultisample` specify the storage
requirements for a two-dimensional multisample array texture. Once a texture is specified with this
command, its format and dimensions become immutable unless it is a proxy texture. The contents of
the image may still be modified, however, its storage requirements may not change. Such a texture is
referred to as an immutable-format texture.

`samples` specifies the number of samples to be used for the texture and must be greater than
zero and less than or equal to the value of `GL_MAX_SAMPLES`. `internalformat` must be a
color-renderable, depth-renderable, or stencil-renderable format. `width` and `height` specify
the width and height, respectively, of the texture and `depth` specifies the depth (or the number
of layers) of the texture. If `fixedsamplelocations` is `GL_TRUE`, the image will use identical
sample locations and the same number of samples for all texels in the image, and the sample
locations will not depend on the internal format or size of the image.

---
### Errors
`GL_INVALID_OPERATION` is generated by `glTexStorage3DMultisample` if zero is bound to
`target`.

`GL_INVALID_OPERATION` is generated by `glTextureStorage3DMultisample` if `texture` is not
the name of an existing texture object.

`GL_INVALID_ENUM` is generated if `internalformat` is not a valid color-renderable,
depth-renderable or stencil-renderable format.

`GL_INVALID_ENUM` is generated if `target` or the effective target of `texture` is not one of
the accepted targets described above.

`GL_INVALID_VALUE` is generated if `width` or `height` are less than 1 or greater than the
value of `GL_MAX_TEXTURE_SIZE`.

`GL_INVALID_VALUE` is generated if `depth` is less than 1 or greater than the value of
`GL_MAX_ARRAY_TEXTURE_LAYERS`.

`GL_INVALID_VALUE` is generated if `levels` is less than 1.

`GL_INVALID_VALUE` is generated if `samples` is zero.

`GL_INVALID_OPERATION` is generated if `samples` is greater than the maximum number of samples
supported for this `target` and `internalformat`.

`GL_INVALID_OPERATION` is generated if the value of `GL_TEXTURE_IMMUTABLE_FORMAT` for the
texture bound to `target` is not `GL_FALSE`.
---
### Associated Gets
`glGetInteger` with arguments `GL_MAX_TEXTURE_SIZE`, `GL_MAX_ARRAY_TEXTURE_LEVELS`,
`GL_TEXTURE_VIEW_MIN_LAYER`, `GL_TEXTURE_VIEW_NUM_LAYERS`, or `GL_TEXTURE_IMMUTABLE_LEVELS`.
---
### Version Support
`glTexStorage3DMultisample` `glTextureStorage3DMultisample`
---
### See Also
glTexImage3D, glTexImage3DMultisample, glTexStorage1D, glTexStorage2DMultisample,
glTexStorage3D.
---
### Copyright
Copyright 2013-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Specify a one-dimensional texture subimage
---
### Parameters
`target` Specifies the target to which the texture is bound for `glTexSubImage1D`. Must be
`GL_TEXTURE_1D`.

`texture` Specifies the texture object name for `glTextureSubImage1D`. The effective target
of `texture` must be one of the valid `target` values above.

`level` Specifies the level-of-detail number. Level 0 is the base image level. Level n is the
n th mipmap reduction image.

`xoffset` Specifies a texel offset in the x direction within the texture array.
`width` Specifies the width of the texture subimage.
`format` Specifies the format of the pixel data. The following symbolic values are accepted:
`GL_RED`, `GL_RG`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, `GL_DEPTH_COMPONENT`, and
`GL_STENCIL_INDEX`.

`type` Specifies the data type of the pixel data. The following symbolic values are accepted:
`GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`,
`GL_INT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`,
`GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`,
`GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`,
`GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, and
`GL_UNSIGNED_INT_2_10_10_10_REV`.

`pixels` Specifies a pointer to the image data in memory.
---
### Description
Texturing maps a portion of a specified texture image onto each graphical primitive for which
texturing is enabled. To enable or disable one-dimensional texturing, call glEnable and
`glDisable` with argument `GL_TEXTURE_1D`.

`glTexSubImage1D` and `glTextureSubImage1D` redefine a contiguous subregion of an existing
one-dimensional texture image. The texels referenced by `pixels` replace the portion of the
existing texture array with x indices `xoffset` and xoffset + width - 1, inclusive. This
region may not include any texels outside the range of the texture array as it was originally
specified. It is not an error to specify a subtexture with width of 0, but such a specification has
no effect.

If a non-zero named buffer object is bound to the `GL_PIXEL_UNPACK_BUFFER` target (see
glBindBuffer ) while a texture image is specified, `pixels` is treated as a byte offset into the
buffer object's data store.
---
### Notes
glPixelStore modes affect texture images.

`glTexSubImage1D` and `glTextureSubImage1D` specify a one-dimensional subtexture for the
current texture unit, specified with glActiveTexture.

`GL_STENCIL_INDEX` is accepted for `format` only if the GL version is 4.4 or higher.
---
### Errors
`GL_INVALID_ENUM` is generated if `target` or the effective target of `texture` is not one of
the allowable values.

`GL_INVALID_OPERATION` is generated by `glTextureSubImage1D` if `texture` is not the name of
an existing texture object.

`GL_INVALID_ENUM` is generated if `format` is not an accepted format constant.

`GL_INVALID_ENUM` is generated if `type` is not a type constant.

`GL_INVALID_VALUE` is generated if `level` is less than 0.

`GL_INVALID_VALUE` may be generated if `level` is greater than log 2 max, where max is
the returned value of `GL_MAX_TEXTURE_SIZE`.

`GL_INVALID_VALUE` is generated if xoffset < - b, or if xoffset + width > w - b,
where w is the `GL_TEXTURE_WIDTH`, and b is the width of the `GL_TEXTURE_BORDER` of the
texture image being modified. Note that w includes twice the border width.

`GL_INVALID_VALUE` is generated if `width` is less than 0.

`GL_INVALID_OPERATION` is generated if the texture array has not been defined by a previous
glTexImage1D operation.

`GL_INVALID_OPERATION` is generated if `type` is one of `GL_UNSIGNED_BYTE_3_3_2`,
`GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, or `GL_UNSIGNED_SHORT_5_6_5_REV` and
`format` is not `GL_RGB`.

`GL_INVALID_OPERATION` is generated if `type` is one of `GL_UNSIGNED_SHORT_4_4_4_4`,
`GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`,
`GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, or
`GL_UNSIGNED_INT_2_10_10_10_REV` and `format` is neither `GL_RGBA` nor `GL_BGRA`.

`GL_INVALID_OPERATION` is generated if `format` is `GL_STENCIL_INDEX` and the base internal
format is not `GL_STENCIL_INDEX`.

`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the
`GL_PIXEL_UNPACK_BUFFER` target and the buffer object's data store is currently mapped.

`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the
`GL_PIXEL_UNPACK_BUFFER` target and the data would be unpacked from the buffer object such that the
memory reads required would exceed the data store size.

`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the
`GL_PIXEL_UNPACK_BUFFER` target and `pixels` is not evenly divisible into the number of bytes
needed to store in memory a datum indicated by `type`.
---
### Associated Gets
glGetTexImage

glGet with argument `GL_PIXEL_UNPACK_BUFFER_BINDING`
---
### Version Support
`glTexSubImage1D` `glTextureSubImage1D`
---
### See Also
glActiveTexture, glCopyTexImage1D, glCopyTexImage2D, glCopyTexSubImage1D,
glCopyTexSubImage2D, glCopyTexSubImage3D, glPixelStore, glTexImage1D, glTexImage2D,
glTexImage3D, glTexParameter, glTexSubImage2D, glTexSubImage3D
---
### Copyright
Copyright 1991-2006 Silicon Graphics, Inc. Copyright 2010-2014 Khronos Group. This document
is licensed under the SGI Free Software B License. For details, see
https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.
]],
  [[Specify a two-dimensional texture subimage
---
### Parameters
`target` Specifies the target to which the texture is bound for `glTexSubImage2D`. Must be
`GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`,
`GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`,
`GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`, or `GL_TEXTURE_1D_ARRAY`.

`texture` Specifies the texture object name for `glTextureSubImage2D`. The effective target
of `texture` must be one of the valid `target` values above.

`level` Specifies the level-of-detail number. Level 0 is the base image level. Level n is the
n th mipmap reduction image.

`xoffset` Specifies a texel offset in the x direction within the texture array.
`yoffset` Specifies a texel offset in the y direction within the texture array.
`width` Specifies the width of the texture subimage.
`height` Specifies the height of the texture subimage.
`format` Specifies the format of the pixel data. The following symbolic values are accepted:
`GL_RED`, `GL_RG`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, `GL_BGRA`, `GL_DEPTH_COMPONENT`, and
`GL_STENCIL_INDEX`.

`type` Specifies the data type of the pixel data. The following symbolic values are accepted:
`GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`,
`GL_INT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`,
`GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`,
`GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`,
`GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, and
`GL_UNSIGNED_INT_2_10_10_10_REV`.

`pixels` Specifies a pointer to the image data in memory.
---
### Description
Texturing maps a portion of a specified texture image onto each graphical primitive for which
texturing is enabled. `glTexSubImage2D` and `glTextureSubImage2D` redefine a contiguous
subregion of an existing two-dimensional or one-dimensional array texture image. The texels
referenced by `pixels` replace the portion of the existing texture array with x indices `xoffset`
and xoffset + width - 1, inclusive, and y indices `yoffset` and yoffset + height - 1,
inclusive. This region may not include any texels outside the range of the texture array as it was
originally specified. It is not an error to specify a subtexture with zero width or height, but such
a specification has no effect.

If a non-zero named buffer object is bound to the `GL_PIXEL_UNPACK_BUFFER` target (see
glBindBuffer ) while a texture image is specified, `pixels` is treated as a byte offset into the
buffer object's data store.
---
### Notes
glPixelStore modes affect texture images.

`glTexSubImage2D` and `glTextureSubImage3D` specify a two-dimensional subtexture for the
current texture unit, specified with glActiveTexture.

`GL_STENCIL_INDEX` is accepted for `format` only if the GL version is 4.4 or higher.
---
### Errors
`GL_INVALID_ENUM` is generated if `target` or the effective target of `texture` is not
`GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`,
`GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`,
`GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`, or `GL_TEXTURE_1D_ARRAY`.

`GL_INVALID_OPERATION` is generated by `glTextureSubImage2D` if `texture` is not the name of
an existing texture object.

`GL_INVALID_ENUM` is generated if `format` is not an accepted format constant.

`GL_INVALID_ENUM` is generated if `type` is not a type constant.

`GL_INVALID_VALUE` is generated if `level` is less than 0.

`GL_INVALID_VALUE` may be generated if `level` is greater than log 2 max, where max is
the returned value of `GL_MAX_TEXTURE_SIZE`.

`GL_INVALID_VALUE` is generated if xoffset < - b, xoffset + width > w - b,
yoffset < - b, or yoffset + height > h - b, where w is the `GL_TEXTURE_WIDTH`, h
is the `GL_TEXTURE_HEIGHT`, and b is the border width of the texture image being modified.

Note that w and h include twice the border width.

`GL_INVALID_VALUE` is generated if `width` or `height` is less than 0.

`GL_INVALID_OPERATION` is generated if the texture array has not been defined by a previous
glTexImage2D operation.

`GL_INVALID_OPERATION` is generated if `type` is one of `GL_UNSIGNED_BYTE_3_3_2`,
`GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, or `GL_UNSIGNED_SHORT_5_6_5_REV` and
`format` is not `GL_RGB`.

`GL_INVALID_OPERATION` is generated if `type` is one of `GL_UNSIGNED_SHORT_4_4_4_4`,
`GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`,
`GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, or
`GL_UNSIGNED_INT_2_10_10_10_REV` and `format` is neither `GL_RGBA` nor `GL_BGRA`.

`GL_INVALID_OPERATION` is generated if `format` is `GL_STENCIL_INDEX` and the base internal
format is not `GL_STENCIL_INDEX`.

`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the
`GL_PIXEL_UNPACK_BUFFER` target and the buffer object's data store is currently mapped.

`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the
`GL_PIXEL_UNPACK_BUFFER` target and the data would be unpacked from the buffer object such that the
memory reads required would exceed the data store size.

`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the
`GL_PIXEL_UNPACK_BUFFER` target and `pixels` is not evenly divisible into the number of bytes
needed to store in memory a datum indicated by `type`.
---
### Associated Gets
glGetTexImage

glGet with argument `GL_PIXEL_UNPACK_BUFFER_BINDING`
---
### Version Support
`glTexSubImage2D` `glTextureSubImage2D`
---
### See Also
glActiveTexture, glCopyTexImage1D, glCopyTexImage2D, glCopyTexSubImage1D,
glCopyTexSubImage2D, glCopyTexSubImage3D, glPixelStore, glTexImage1D, glTexImage2D,
glTexImage3D, glTexSubImage1D, glTexSubImage3D, glTexParameter
---
### Copyright
Copyright 1991-2006 Silicon Graphics, Inc. Copyright 2010-2014 Khronos Group. This document
is licensed under the SGI Free Software B License. For details, see
https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.
]],
  [[Retrieve a sub-region of a texture image from a texture object
---
### Parameters
`texture` Specifies the name of the source texture object. Must be `GL_TEXTURE_1D`,
`GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_3D`,
`GL_TEXTURE_CUBE_MAP`, `GL_TEXTURE_CUBE_MAP_ARRAY` or `GL_TEXTURE_RECTANGLE`. In specific,
buffer and multisample textures are not permitted.

`level` Specifies the level-of-detail number. Level 0 is the base image level. Level $n$ is the
$n$th mipmap reduction image.
`xoffset` Specifies a texel offset in the x direction within the texture array.
`yoffset` Specifies a texel offset in the y direction within the texture array.
`zoffset` Specifies a texel offset in the z direction within the texture array.
`width` Specifies the width of the texture subimage.
`height` Specifies the height of the texture subimage.
`depth` Specifies the depth of the texture subimage.
`format` Specifies the format of the pixel data. The following symbolic values are accepted:
`GL_RED`, `GL_RG`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, `GL_BGRA`, `GL_DEPTH_COMPONENT` and
`GL_STENCIL_INDEX`.

`type` Specifies the data type of the pixel data. The following symbolic values are accepted:
`GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`,
`GL_INT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`,
`GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`,
`GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`,
`GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, and
`GL_UNSIGNED_INT_2_10_10_10_REV`.

`bufSize` Specifies the size of the buffer to receive the retrieved pixel data.
`pixels` Returns the texture subimage. Should be a pointer to an array of the type specified by
`type`.

---
### Description
`glGetTextureSubImage` returns a texture subimage into pixels.

`texture` is the name of the source texture object and must not be a buffer or multisample
texture. The effective `target` parameter is the value of `GL_TEXTURE_TARGET` for texture.
`Level`, `format`, `type` and `pixels` have the same meaning as for `glGetTexImage`.
`bufSize` is the size of the buffer to receive the retrieved pixel data.

For cube map textures, the behavior is as though `GetTextureImage` were called, but only texels
from the requested cube map faces (selected by `zoffset` and `depth`, as described below) were
returned.

`xoffset`, `yoffset` and `zoffset` values indicate the position of the subregion to return.
`width`, `height` and `depth` indicate the size of the region to return. These parameters have
the same meaning as for `glTexSubImage3D`, though for one- and two-dimensional textures there are
extra restrictions, described in the errors section below.

For one-dimensional array textures, `yoffset` is interpreted as the first layer to access and
`height` is the number of layers to access.

For two-dimensional array textures, `zoffset` is interpreted as the first layer to access and
`depth` is the number of layers to access.

Cube map textures are treated as an array of six slices in the z-dimension, where the value of
`zoffset` is interpreted as specifying the cube map face for the corresponding layer (as presented
in the table below) and `depth` is the number of faces to access:

Layer number Cube Map Face 0 GL_TEXTURE_CUBE_MAP_POSITIVE_X 1 GL_TEXTURE_CUBE_MAP_NEGATIVE_X
2 GL_TEXTURE_CUBE_MAP_POSITIVE_Y 3 GL_TEXTURE_CUBE_MAP_NEGATIVE_Y 4
GL_TEXTURE_CUBE_MAP_POSITIVE_Z 5 GL_TEXTURE_CUBE_MAP_NEGATIVE_Z

For cube map array textures, `zoffset` is the first layer-face to access, and `depth` is the
number of layer-faces to access. A layer-face described by $k$ is translated into an array layer and
face according to $$ layer = \\\\left\\\\lfloor { layer \\\\over 6 } \\\\right\\\\rfloor$$ and $$ face = k \\\\bmod 6.
$$

Component groups from the specified sub-region are packed and placed into memory as described for
`glGetTextureImage`, starting with the texel at ( `xoffset`, `yoffset`, `zoffset` ).
---
### Errors
`GL_INVALID_VALUE` error is generated if `texture` is not the name of an existing texture
object.

`GL_INVALID_OPERATION` error is generated if `texture` is the name of a buffer or multisample
texture.

`GL_INVALID_VALUE` is generated if `xoffset`, `yoffset` or `zoffset` are negative.

`GL_INVALID_VALUE` is generated if `xoffset` + `width` is greater than the texture's width,
`yoffset` + `height` is greater than the texture's height, or `zoffset` + `depth` is greater
than the texture's depth.

`GL_INVALID_VALUE` error is generated if the effective target is `GL_TEXTURE_1D` and either
`yoffset` is not zero, or `height` is not one.

`GL_INVALID_VALUE` error is generated if the effective target is `GL_TEXTURE_1D`,
`GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D` or `GL_TEXTURE_RECTANGLE` and either `zoffset` is not
zero, or `depth` is not one.

`GL_INVALID_OPERATION` error is generated if the buffer size required to store the requested data
is greater than `bufSize`.
---
### Version Support
`glGetTextureSubImage`
---
### See Also
glGetTexImage, `glGetTextureImage`, glReadPixels, glTexImage1D, glTexImage2D,
glTexImage3D, glTexSubImage1D, glTexSubImage2D, glTexSubImage3D
---
### Copyright
Copyright 2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Specify a three-dimensional texture subimage
---
### Parameters
`target` Specifies the target to which the texture is bound for `glTexSubImage3D`. Must be
`GL_TEXTURE_3D` or `GL_TEXTURE_2D_ARRAY`.

`texture` Specifies the texture object name for `glTextureSubImage3D`. The effective target
of `texture` must be one of the valid `target` values above.

`level` Specifies the level-of-detail number. Level 0 is the base image level. Level n is the
n th mipmap reduction image.

`xoffset` Specifies a texel offset in the x direction within the texture array.
`yoffset` Specifies a texel offset in the y direction within the texture array.
`zoffset` Specifies a texel offset in the z direction within the texture array.
`width` Specifies the width of the texture subimage.
`height` Specifies the height of the texture subimage.
`depth` Specifies the depth of the texture subimage.
`format` Specifies the format of the pixel data. The following symbolic values are accepted:
`GL_RED`, `GL_RG`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, `GL_DEPTH_COMPONENT`, and
`GL_STENCIL_INDEX`.

`type` Specifies the data type of the pixel data. The following symbolic values are accepted:
`GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`,
`GL_INT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`,
`GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`,
`GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`,
`GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, and
`GL_UNSIGNED_INT_2_10_10_10_REV`.

`pixels` Specifies a pointer to the image data in memory.
---
### Description
Texturing maps a portion of a specified texture image onto each graphical primitive for which
texturing is enabled. `glTexSubImage3D` and `glTextureSubImage3D` redefine a contiguous
subregion of an existing three-dimensional or two-dimensioanl array texture image. The texels
referenced by `pixels` replace the portion of the existing texture array with x indices `xoffset`
and xoffset + width - 1, inclusive, y indices `yoffset` and yoffset + height - 1,
inclusive, and z indices `zoffset` and zoffset + depth - 1, inclusive. For three-dimensional
textures, the z index refers to the third dimension. For two-dimensional array textures, the z index
refers to the slice index. This region may not include any texels outside the range of the texture
array as it was originally specified. It is not an error to specify a subtexture with zero width,
height, or depth but such a specification has no effect.

If a non-zero named buffer object is bound to the `GL_PIXEL_UNPACK_BUFFER` target (see
glBindBuffer ) while a texture image is specified, `pixels` is treated as a byte offset into the
buffer object's data store.
---
### Notes
The glPixelStore modes affect texture images.

`glTexSubImage3D` and `glTextureSubImage3D` specify a three-dimensional or two-dimensional
array subtexture for the current texture unit, specified with glActiveTexture.

`GL_STENCIL_INDEX` is accepted for `format` only if the GL version is 4.4 or higher.
---
### Errors
`GL_INVALID_ENUM` is generated if `target` or the effective target of `texture` is not
`GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY` or `GL_TEXTURE_CUBE_MAP_ARRAY`.

`GL_INVALID_OPERATION` is generated by `glTextureSubImage3D` if `texture` is not the name of
an existing texture object.

`GL_INVALID_ENUM` is generated if `format` is not an accepted format constant.

`GL_INVALID_ENUM` is generated if `type` is not a type constant.

`GL_INVALID_VALUE` is generated if `level` is less than 0.

`GL_INVALID_VALUE` may be generated if `level` is greater than log 2 max, where max is
the returned value of `GL_MAX_TEXTURE_SIZE`.

`GL_INVALID_VALUE` is generated if xoffset < - b, xoffset + width > w - b,
yoffset < - b, or yoffset + height > h - b, or zoffset < - b, or zoffset +
depth > d - b, where w is the `GL_TEXTURE_WIDTH`, h is the `GL_TEXTURE_HEIGHT`, d
is the `GL_TEXTURE_DEPTH` and b is the border width of the texture image being modified. Note
that w, h, and d include twice the border width.

`GL_INVALID_VALUE` is generated if `width`, `height`, or `depth` is less than 0.

`GL_INVALID_OPERATION` is generated if the texture array has not been defined by a previous
glTexImage3D or glTexStorage3D operation.

`GL_INVALID_OPERATION` is generated if `type` is one of `GL_UNSIGNED_BYTE_3_3_2`,
`GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, or `GL_UNSIGNED_SHORT_5_6_5_REV` and
`format` is not `GL_RGB`.

`GL_INVALID_OPERATION` is generated if `type` is one of `GL_UNSIGNED_SHORT_4_4_4_4`,
`GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`,
`GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, or
`GL_UNSIGNED_INT_2_10_10_10_REV` and `format` is neither `GL_RGBA` nor `GL_BGRA`.

`GL_INVALID_OPERATION` is generated if `format` is `GL_STENCIL_INDEX` and the base internal
format is not `GL_STENCIL_INDEX`.

`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the
`GL_PIXEL_UNPACK_BUFFER` target and the buffer object's data store is currently mapped.

`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the
`GL_PIXEL_UNPACK_BUFFER` target and the data would be unpacked from the buffer object such that the
memory reads required would exceed the data store size.

`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the
`GL_PIXEL_UNPACK_BUFFER` target and `pixels` is not evenly divisible into the number of bytes
needed to store in memory a datum indicated by `type`.
---
### Associated Gets
glGetTexImage

glGet with argument `GL_PIXEL_UNPACK_BUFFER_BINDING`
---
### Version Support
`glTexSubImage3D` `glTextureSubImage3D`
---
### See Also
glActiveTexture, glCopyTexImage1D, glCopyTexImage2D, glCopyTexSubImage1D,
glCopyTexSubImage2D, glCopyTexSubImage3D, glPixelStore, glTexImage1D, glTexImage2D,
glTexImage3D, glTexSubImage1D, glTexSubImage2D, glTexParameter
---
### Copyright
Copyright 1991-2006 Silicon Graphics, Inc. Copyright 2010-2014 Khronos Group. This document
is licensed under the SGI Free Software B License. For details, see
https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.
]],
  [[Query the state of a transform feedback object.
---
### Parameters
`xfb` The name of an existing transform feedback object, or zero for the default transform
feedback object.
`pname` Property to use for the query. Must be one of the values:
`GL_TRANSFORM_FEEDBACK_BUFFER_BINDING`, `GL_TRANSFORM_FEEDBACK_BUFFER_START`,
`GL_TRANSFORM_FEEDBACK_BUFFER_SIZE`, `GL_TRANSFORM_FEEDBACK_PAUSED`,
`GL_TRANSFORM_FEEDBACK_ACTIVE`.

`index` Index of the transform feedback stream (for indexed state).
`param` The address of a buffer into which will be written the requested state information.
---
### Description
In order to use the Transform Feedback functionality, you need to configure the Transform Feedback
Buffer indexed bindings. This can be achieved by either using `glBindBufferBase` or
`glBindBuffersBase` to associate whole buffer object storage to one of the Transform Feedback
Binding Points, or by calling `glBindBufferRange` or `glBindBuffersRange` to use a region of a
buffer object storage for the binding. You may want to (but are not required to) bind a Transform
Feedback Object first, in order to cache the binding configuration. This usually allows you to
restore the Transform Feedback configuration faster, than if you were to execute a list of API calls
necessary to set up the Transform Feedback state of your liking.

This reference page discusses two types of getters that operate on Transform Feedback Objects and
their bindings. The first class operates on general Transform Feedback binding point and includes
`glGetTransformFeedbackiv` function. `glGetTransformFeedbackiv` can be used to retrieve
information about Transform Feedback object bound to the general Transform Feedback binding point,
as configured with a `glBindTransformFeedback` call. In this case, you can check:

What the ID of the currently bound Transform Feedback Object is; (
`GL_TRANSFORM_FEEDBACK_BUFFER_BINDING` )

Whether the Transform Feedback process is currently paused; ( `GL_TRANSFORM_FEEDBACK_PAUSED` )

Whether the Transform Feedback process has been begun and is currently undergoing; (
`GL_TRANSFORM_FEEDBACK_ACTIVE` )


The latter class, which includes `glGetTransformFeedbacki_v` and `glGetTransformFeedbacki64_v`
functions, can be used to check what the current configuration of each of the buffer object regions
bound to Transform Feedback Buffer binding points is. This allows you to query for the following
information:

`glGetTransformFeedbacki_v` only: What the ID of the Buffer Object bound to a Transform
Feedback Binding Point of user-specified index is; ( `GL_TRANSFORM_FEEDBACK_BUFFER_BINDING` ).

`glGetTransformFeedbacki64_v` only: What the start offset configured for the binding is; (
`GL_TRANSFORM_FEEDBACK_BUFFER_START` );

`glGetTransformFeedbacki64_v` only: What the length of the region used for the binding is; (
`GL_TRANSFORM_FEEDBACK_BUFFER_SIZE` );

---
### Errors
`GL_INVALID_OPERATION` error is generated if `xfb` is not zero or the name of an existing
transform feedback object.

`GL_INVALID_ENUM` error is generated by `glGetTransformFeedbackiv` if `pname` is not
`GL_TRANSFORM_FEEDBACK_PAUSED` or `GL_TRANSFORM_FEEDBACK_ACTIVE`.

`GL_INVALID_ENUM` error is generated by `glGetTransformFeedbacki_v` if `pname` is not
`GL_TRANSFORM_FEEDBACK_BUFFER_BINDING`.

`GL_INVALID_ENUM` error is generated by `glGetTransformFeedbacki64_v` if `pname` is not
`GL_TRANSFORM_FEEDBACK_BUFFER_START` or `GL_TRANSFORM_FEEDBACK_BUFFER_SIZE`.

`GL_INVALID_VALUE` error is generated by `glGetTransformFeedbacki_v` and
`glGetTransformFeedbacki64_v` if `index` is greater than or equal to the number of binding points
for transform feedback (the value of `GL_MAX_TRANSFORM_FEEDBACK_BUFFERS` ).
---
### Version Support
`glGetTransformFeedbackiv` `glGetTransformFeedbacki_v` `glGetTransformFeedbacki64v`
---
### See Also
glBindBufferBase, glBindBufferRange, glBindBuffersBase, glBindBuffersRange,
glBindTransformFeedback
---
### Copyright
Copyright 2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Controls the ordering of reads and writes to rendered fragments across drawing commands
---
### Description
The values of rendered fragments are undefined when a shader stage fetches texels and the same
texels are written via fragment shader outputs, even if the reads and writes are not in the same
drawing command. To safely read the result of a written texel via a texel fetch in a subsequent
drawing command, call `glTextureBarrier` between the two drawing commands to guarantee that writes
have completed and caches have been invalidated before subsequent drawing commands are executed.
---
### Notes
The situation described above is referred to as a rendering feedback loop and is discussed in
more detail in section 9.3 of the OpenGL 4.5 Specification.
---
### Errors
None.
---
### Version Support
`glTextureBarrier`
---
### See Also
glMemoryBarrier
---
### Copyright
Copyright 2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Initialize a texture as a data alias of another texture's data store
---
### Parameters
`texture` Specifies the texture object to be initialized as a view.
`target` Specifies the target to be used for the newly initialized texture.
`origtexture` Specifies the name of a texture object of which to make a view.
`internalformat` Specifies the internal format for the newly created view.
`minlevel` Specifies lowest level of detail of the view.
`numlevels` Specifies the number of levels of detail to include in the view.
`minlayer` Specifies the index of the first layer to include in the view.
`numlayers` Specifies the number of layers to include in the view.
---
### Description
`glTextureView` initializes a texture object as an alias, or view of another texture object,
sharing some or all of the parent texture's data store with the initialized texture. `texture`
specifies a name previously reserved by a successful call to glGenTextures but that has not yet
been bound or given a target. `target` specifies the target for the newly initialized texture and
must be compatible with the target of the parent texture, given in `origtexture` as specified in
the following table:

Original Target Compatible New Targets `GL_TEXTURE_1D` `GL_TEXTURE_1D`,
`GL_TEXTURE_1D_ARRAY` `GL_TEXTURE_2D` `GL_TEXTURE_2D`, `GL_TEXTURE_2D_ARRAY` `GL_TEXTURE_3D`
`GL_TEXTURE_3D` `GL_TEXTURE_CUBE_MAP` `GL_TEXTURE_CUBE_MAP`, `GL_TEXTURE_2D`,
`GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_CUBE_MAP_ARRAY` `GL_TEXTURE_RECTANGLE`
`GL_TEXTURE_RECTANGLE` `GL_TEXTURE_BUFFER` none `GL_TEXTURE_1D_ARRAY` `GL_TEXTURE_1D`,
`GL_TEXTURE_1D_ARRAY` `GL_TEXTURE_2D_ARRAY` `GL_TEXTURE_2D`, `GL_TEXTURE_2D_ARRAY`
`GL_TEXTURE_CUBE_MAP_ARRAY` `GL_TEXTURE_CUBE_MAP`, `GL_TEXTURE_2D`, `GL_TEXTURE_2D_ARRAY`,
`GL_TEXTURE_CUBE_MAP_ARRAY` `GL_TEXTURE_2D_MULTISAMPLE` `GL_TEXTURE_2D_MULTISAMPLE`,
`GL_TEXTURE_MULTISAMPLE_ARRAY` `GL_TEXTURE_2D_MULTISAMPLE_ARRAY` `GL_TEXTURE_2D_MULTISAMPLE`,
`GL_TEXTURE_MULTISAMPLE_ARRAY` The value of `GL_TEXTURE_IMMUTABLE_FORMAT` for `origtexture`
must be `GL_TRUE`. After initialization, `texture` inherits the data store of the parent
texture, `origtexture` and is usable as a normal texture object with target `target`. Data in
the shared store is reinterpreted with the new internal format specified by `internalformat`.
`internalformat` must be compatible with the internal format of the parent texture as specified in
the following table:

Class Internal Formats 128-bit `GL_RGBA32F`, `GL_RGBA32UI`, `GL_RGBA32I` 96-bit
`GL_RGB32F`, `GL_RGB32UI`, `GL_RGB32I` 64-bit `GL_RGBA16F`, `GL_RG32F`, `GL_RGBA16UI`,
`GL_RG32UI`, `GL_RGBA16I`, `GL_RG32I`, `GL_RGBA16`, `GL_RGBA16_SNORM` 48-bit `GL_RGB16`,
`GL_RGB16_SNORM`, `GL_RGB16F`, `GL_RGB16UI`, `GL_RGB16I` 32-bit `GL_RG16F`,
`GL_R11F_G11F_B10F`, `GL_R32F`, `GL_RGB10_A2UI`, `GL_RGBA8UI`, `GL_RG16UI`, `GL_R32UI`,
`GL_RGBA8I`, `GL_RG16I`, `GL_R32I`, `GL_RGB10_A2`, `GL_RGBA8`, `GL_RG16`,
`GL_RGBA8_SNORM`, `GL_RG16_SNORM`, `GL_SRGB8_ALPHA8`, `GL_RGB9_E5` 24-bit `GL_RGB8`,
`GL_RGB8_SNORM`, `GL_SRGB8`, `GL_RGB8UI`, `GL_RGB8I` 16-bit `GL_R16F`, `GL_RG8UI`,
`GL_R16UI`, `GL_RG8I`, `GL_R16I`, `GL_RG8`, `GL_R16`, `GL_RG8_SNORM`, `GL_R16_SNORM`
8-bit `GL_R8UI`, `GL_R8I`, `GL_R8`, `GL_R8_SNORM` `GL_RGTC1_RED` `GL_COMPRESSED_RED_RGTC1`,
`GL_COMPRESSED_SIGNED_RED_RGTC1` `GL_RGTC2_RG` `GL_COMPRESSED_RG_RGTC2`,
`GL_COMPRESSED_SIGNED_RG_RGTC2` `GL_BPTC_UNORM` `GL_COMPRESSED_RGBA_BPTC_UNORM`,
`GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM` `GL_BPTC_FLOAT` `GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT`,
`GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT` If the original texture is an array or has multiple mipmap
levels, the parameters `minlayer`, `numlayers`, `minlevel`, and `numlevels` control which of
those slices and levels are considered part of the texture. The `minlevel` and `minlayer`
parameters are relative to the view of the original texture. If `numlayers` or `numlevels`
extend beyond the original texture, they are clamped to the max extent of the original texture.

If the new texture's target is `GL_TEXTURE_CUBE_MAP`, the clamped `numlayers` must be equal to
6. If the new texture's target is `GL_TEXTURE_CUBE_MAP_ARRAY`, then `numlayers` counts
layer-faces rather than layers, and the clamped `numlayers` must be a multiple of 6. If the new
texture's target is `GL_TEXTURE_CUBE_MAP` or `GL_TEXTURE_CUBE_MAP_ARRAY`, the width and height
of the original texture's levels must be equal.

When the original texture's target is `GL_TEXTURE_CUBE_MAP`, the layer parameters are
interpreted in the same order as if it were a `GL_TEXTURE_CUBE_MAP_ARRAY` with 6 layer-faces.

If `target` is `GL_TEXTURE_1D`, `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_RECTANGLE`,
or `GL_TEXTURE_2D_MULTISAMPLE`, `numlayers` must equal 1.

The dimensions of the original texture must be less than or equal to the maximum supported
dimensions of the new target. For example, if the original texture has a `GL_TEXTURE_2D_ARRAY`
target and its width is greater than `GL_MAX_CUBE_MAP_TEXTURE_SIZE`, an error will be generated if
`glTextureView` is called to create a `GL_TEXTURE_CUBE_MAP` view.

Texture commands that take a `level` or `layer` parameter, such as glTexSubImage2D,
interpret that parameter to be relative to the view of the texture. i.e. the mipmap level of the
data store that would be updated via glTexSubImage2D would be the sum of `level` and the value
of `GL_TEXTURE_VIEW_MIN_LEVEL`.
---
### Errors
`GL_INVALID_VALUE` is generated if `minlayer` or `minlevel` are larger than the greatest
layer or level of `origtexture`.

`GL_INVALID_OPERATION` is generated if `target` is not compatible with the target of
`origtexture`.

`GL_INVALID_OPERATION` is generated if the dimensions of `origtexture` are greater than the
maximum supported dimensions for `target`.

`GL_INVALID_OPERATION` is generated if `internalformat` is not compatible with the internal
format of `origtexture`.

`GL_INVALID_OPERATION` is generated if `texture` has already been bound or otherwise given a
target.

`GL_INVALID_OPERATION` is generated if the value of `GL_TEXTURE_IMMUTABLE_FORMAT` for
`origtexture` is not `GL_TRUE`.

`GL_INVALID_OPERATION` is generated if `origtexture` is not the name of an existing texture
object.

`GL_INVALID_VALUE` is generaged if `target` is `GL_TEXTURE_CUBE_MAP` and `numlayers` is not
6, or if `target` is `GL_TEXTURE_CUBE_MAP_ARRAY` and `numlayers` is not an integer multiple of
6.

`GL_INVALID_VALUE` is generated if `target` is `GL_TEXTURE_1D`, `GL_TEXTURE_2D`,
`GL_TEXTURE_3D`, `GL_TEXTURE_RECTANGLE`, or `GL_TEXTURE_2D_MULTISAMPLE` and `numlayers` does
not equal 1.

`GL_INVALID_VALUE` is generated if `texture` zero or is not the name of a texture previously
returned from a successful call to glGenTextures.
---
### Associated Gets
glTexParameter with arguments `GL_TEXTURE_VIEW_MIN_LEVEL`, `GL_TEXTURE_VIEW_NUM_LEVELS`,
`GL_TEXTURE_VIEW_MIN_LAYER`, `GL_TEXTURE_VIEW_NUM_LAYERS`, or `GL_TEXTURE_IMMUTABLE_LEVELS`.
---
### Version Support
`glTextureView`
---
### See Also
glTexStorage1D, glTexStorage2D, glTexStorage3D, glGetTexParameter.
---
### Copyright
Copyright 2013-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Retrieve information about varying variables selected for transform feedback
---
### Parameters
`program` The name of the target program object.
`index` The index of the varying variable whose information to retrieve.
`bufSize` The maximum number of characters, including the null terminator, that may be written
into `name`.

`length` The address of a variable which will receive the number of characters written into
`name`, excluding the null-terminator. If `length` is `NULL` no length is returned.

`size` The address of a variable that will receive the size of the varying.
`type` The address of a variable that will receive the type of the varying.
`name` The address of a buffer into which will be written the name of the varying.
---
### Description
Information about the set of varying variables in a linked program that will be captured during
transform feedback may be retrieved by calling `glGetTransformFeedbackVarying`.
`glGetTransformFeedbackVarying` provides information about the varying variable selected by
`index`. An `index` of 0 selects the first varying variable specified in the `varyings` array
passed to glTransformFeedbackVaryings, and an `index` of the value of
`GL_TRANSFORM_FEEDBACK_VARYINGS` minus one selects the last such variable.

The name of the selected varying is returned as a null-terminated string in `name`. The actual
number of characters written into `name`, excluding the null terminator, is returned in `length`.
If `length` is NULL, no length is returned. The maximum number of characters that may be written
into `name`, including the null terminator, is specified by `bufSize`.

The length of the longest varying name in program is given by
`GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH`, which can be queried with glGetProgram.

For the selected varying variable, its type is returned into `type`. The size of the varying is
returned into `size`. The value in `size` is in units of the type returned in `type`. The type
returned can be any of the scalar, vector, or matrix attribute types returned by glGetActiveAttrib.
If an error occurred, the return parameters `length`, `size`, `type` and `name` will be
unmodified. This command will return as much information about the varying variables as possible. If
no information is available, `length` will be set to zero and `name` will be an empty string.

This situation could arise if `glGetTransformFeedbackVarying` is called after a failed link.
---
### Errors
`GL_INVALID_VALUE` is generated if `program` is not the name of a program object.

`GL_INVALID_VALUE` is generated if `index` is greater or equal to the value of
`GL_TRANSFORM_FEEDBACK_VARYINGS`.

`GL_INVALID_OPERATION` is generated `program` has not been linked.
---
### Associated Gets
glGetProgram with argument `GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH`.
---
### Version Support
`glGetTransformFeedbackVarying`
---
### See Also
glBeginTransformFeedback, `glEndTransformFeedback`, glTransformFeedbackVaryings,
glGetProgram
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Bind a buffer object to a transform feedback buffer object
---
### Parameters
`xfb` Name of the transform feedback buffer object.
`index` Index of the binding point within `xfb`.

`buffer` Name of the buffer object to bind to the specified binding point.
---
### Description
`glTransformFeedbackBufferBase` binds the buffer object `buffer` to the binding point at index
`index` of the transform feedback object `xfb`.
---
### Notes
Calling `glTransformFeedbackBufferBase` is equivalent to calling
glTransformFeedbackBufferRange with `offset` zero and `size` equal to the size of `buffer`.
---
### Errors
`GL_INVALID_OPERATION` is generated if `xfb` is not the name of an existing transform feedback
object.

`GL_INVALID_VALUE` is generated if in `buffer` is not zero or the name of an existing buffer
object.

`GL_INVALID_VALUE` is generated if `index` is greater than or equal to the number of transform
feedback buffer binding points (the value of `GL_TRANSFORM_FEEDBACK_BUFFER_BINDING` ).
---
### Version Support
`glTransformFeedbackBufferBase`
---
### See Also
glBindBufferRange, glBindBufferBase, glTransformFeedbackBufferRange.
---
### Copyright
Copyright 2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[GlGetUniform Returns the value of a uniform variable
---
### Parameters
`program` Specifies the program object to be queried.
`location` Specifies the location of the uniform variable to be queried.
`bufSize` Specifies the size of the buffer `params`.

`params` Returns the value of the specified uniform variable.
---
### Description
`glGetUniform` and `glGetnUniform` return in `params` the value(s) of the specified uniform
variable. The type of the uniform variable specified by `location` determines the number of values
returned. If the uniform variable is defined in the shader as a boolean, int, or float, a single
value will be returned. If it is defined as a vec2, ivec2, or bvec2, two values will be returned. If
it is defined as a vec3, ivec3, or bvec3, three values will be returned, and so on. To query values
stored in uniform variables declared as arrays, call `glGetUniform` for each element of the array.

To query values stored in uniform variables declared as structures, call `glGetUniform` for each
field in the structure. The values for uniform variables declared as a matrix will be returned in
column major order.

The locations assigned to uniform variables are not known until the program object is linked. After
linking has occurred, the command glGetUniformLocation can be used to obtain the location of a
uniform variable. This location value can then be passed to `glGetUniform` or `glGetnUniform` in
order to query the current value of the uniform variable. After a program object has been linked
successfully, the index values for uniform variables remain fixed until the next link command
occurs. The uniform variable values can only be queried after a link if the link was successful.

The only difference between `glGetUniform` and `glGetnUniform` is that `glGetnUniform` will
generate an error if size of the `params` buffer,as described by `bufSize`, is not large enough
to hold the result data.
---
### Notes
If an error is generated, no change is made to the contents of `params`.
---
### Errors
`GL_INVALID_VALUE` is generated if `program` is not a value generated by OpenGL.

`GL_INVALID_OPERATION` is generated if `program` is not a program object.

`GL_INVALID_OPERATION` is generated if `program` has not been successfully linked.

`GL_INVALID_OPERATION` is generated if `location` does not correspond to a valid uniform
variable location for the specified program object.

`GL_INVALID_OPERATION` is generated by `glGetnUniform` if the buffer size required to store the
requested data is greater than `bufSize`.
---
### Associated Gets
glGetActiveUniform with arguments `program` and the index of an active uniform variable

glGetProgram with arguments `program` and `GL_ACTIVE_UNIFORMS` or
`GL_ACTIVE_UNIFORM_MAX_LENGTH`

glGetUniformLocation with arguments `program` and the name of a uniform variable

glIsProgram
---
### Version Support
`glGetUniformdv` `glGetUniformfv` `glGetUniformiv` `glGetUniformuiv`
`glGetnUniformdv` `glGetnUniformfv` `glGetnUniformiv` `glGetnUniformuiv`
---
### See Also
glCreateProgram, glLinkProgram, glUniform
---
### Copyright
Copyright 2003-2005 3Dlabs Inc. Ltd. Copyright 2010-2014 Khronos Group. This material may be
distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8
June 1999. https://opencontent.org/openpub/.
]],
  [[Bind a range within a buffer object to a transform feedback buffer object
---
### Parameters
`xfb` Name of the transform feedback buffer object.
`index` Index of the binding point within `xfb`.

`buffer` Name of the buffer object to bind to the specified binding point.
`offset` The starting offset in basic machine units into the buffer object.
`size` The amount of data in basic machine units that can be read from or written to the buffer
object while used as an indexed target.
---
### Description
`glTransformFeedbackBufferRange` binds a range of the buffer object `buffer` represented by
`offset` and `size` to the binding point at index `index` of the transform feedback object
`xfb`.

`offset` specifies the offset in basic machine units into the buffer object `buffer` and
`size` specifies the amount of data that can be read from the buffer object while used as an
indexed target.
---
### Notes
---
### Errors
`GL_INVALID_OPERATION` is generated if `xfb` is not the name of an existing transform feedback
object.

`GL_INVALID_VALUE` is generated if in `buffer` is not zero or the name of an existing buffer
object.

`GL_INVALID_VALUE` is generated if `index` is greater than or equal to the number of transform
feedback buffer binding points (the value of `GL_TRANSFORM_FEEDBACK_BUFFER_BINDING` ).

`GL_INVALID_VALUE` is generated if `offset` is negative.

`GL_INVALID_VALUE` is generated if `buffer` is non-zero and either `size` is less than or
equal to zero, or `offset` + `size` is greater than the value of `GL_BUFFER_SIZE` for
`buffer`.
---
### Version Support
`glTransformFeedbackBufferRange`
---
### See Also
glBindBufferRange, glBindBufferBase, glTransformFeedbackBufferBase.
---
### Copyright
Copyright 2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Specify values to record in transform feedback buffers
---
### Parameters
`program` The name of the target program object.
`count` The number of varying variables used for transform feedback.
`varyings` An array of `count` zero-terminated strings specifying the names of the varying
variables to use for transform feedback.

`bufferMode` Identifies the mode used to capture the varying variables when transform feedback
is active. `bufferMode` must be `GL_INTERLEAVED_ATTRIBS` or `GL_SEPARATE_ATTRIBS`.

---
### Description
The names of the vertex or geometry shader outputs to be recorded in transform feedback mode are
specified using `glTransformFeedbackVaryings`. When a geometry shader is active, transform
feedback records the values of selected geometry shader output variables from the emitted vertices.

Otherwise, the values of the selected vertex shader outputs are recorded.

The state set by `glTranformFeedbackVaryings` is stored and takes effect next time
glLinkProgram is called on `program`. When glLinkProgram is called, `program` is linked so
that the values of the specified varying variables for the vertices of each primitive generated by
the GL are written to a single buffer object if `bufferMode` is `GL_INTERLEAVED_ATTRIBS` or
multiple buffer objects if `bufferMode` is `GL_SEPARATE_ATTRIBS`.

`glTransformFeedbackVaryings` can also special identifiers if `bufferMode` is
`GL_INTERLEAVED_ATTRIBS` :

gl_NextBuffer Subsequent variables in `varyings` will be assigned to the next buffer binding
point.

gl_SkipComponents# Where # may be 1, 2, 3, or 4. The variable is treated as having this number of
components, but the contents of the memory are preserved under feedback operations. In addition to
the errors generated by `glTransformFeedbackVaryings`, the program `program` will fail to link
if: The count specified by `glTransformFeedbackVaryings` is non-zero, but the program object
has no vertex or geometry shader.

Any variable name specified in the `varyings` array is not declared as an output in the vertex
shader (or the geometry shader, if active), or is not one of the special identifiers listed above.

Special identifiers appear in a `varyings` array where `bufferMode` is not
`GL_INTERLEAVED_ATTRIBS`.

Any two entries in the `varyings` array, which are not one of the special varyings above,
specify the same varying variable.

Discounting any special identifiers, the total number of components to capture in any varying
variable in `varyings` is greater than the constant
`GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS` and the buffer mode is `GL_SEPARATE_ATTRIBS`.

The total number of components to capture is greater than the constant
`GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS` and the buffer mode is `GL_INTERLEAVED_ATTRIBS`.

---
### Notes
`glGetTransformFeedbackVarying` is available only if the GL version is 3.0 or greater.
---
### Errors
`GL_INVALID_VALUE` is generated if `program` is not the name of a program object.

`GL_INVALID_VALUE` is generated if `bufferMode` is `GL_SEPARATE_ATTRIBS` and `count` is
greater than the implementation-dependent limit `GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS`.
---
### Associated Gets
glGetTransformFeedbackVarying
---
### Version Support
`glTransformFeedbackVaryings`
---
### See Also
glBeginTransformFeedback, `glEndTransformFeedback`, glGetTransformFeedbackVarying
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[GlGetVertexAttrib Return a generic vertex attribute parameter
---
### Parameters
`index` Specifies the generic vertex attribute parameter to be queried.
`pname` Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted
values are `GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING`, `GL_VERTEX_ATTRIB_ARRAY_ENABLED`,
`GL_VERTEX_ATTRIB_ARRAY_SIZE`, `GL_VERTEX_ATTRIB_ARRAY_STRIDE`, `GL_VERTEX_ATTRIB_ARRAY_TYPE`,
`GL_VERTEX_ATTRIB_ARRAY_NORMALIZED`, `GL_VERTEX_ATTRIB_ARRAY_INTEGER`,
`GL_VERTEX_ATTRIB_ARRAY_LONG`, `GL_VERTEX_ATTRIB_ARRAY_DIVISOR`, `GL_VERTEX_ATTRIB_BINDING`,
`GL_VERTEX_ATTRIB_RELATIVE_OFFSET` or `GL_CURRENT_VERTEX_ATTRIB`.

`params` Returns the requested data.
---
### Description
`glGetVertexAttrib` returns in `params` the value of a generic vertex attribute parameter. The
generic vertex attribute to be queried is specified by `index`, and the parameter to be queried is
specified by `pname`.

The accepted parameter names are as follows: `GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING` `params`
returns a single value, the name of the buffer object currently bound to the binding point
corresponding to generic vertex attribute array `index`. If no buffer object is bound, 0 is
returned. The initial value is 0.

`GL_VERTEX_ATTRIB_ARRAY_ENABLED` `params` returns a single value that is non-zero (true) if
the vertex attribute array for `index` is enabled and 0 (false) if it is disabled. The initial
value is `GL_FALSE`.

`GL_VERTEX_ATTRIB_ARRAY_SIZE` `params` returns a single value, the size of the vertex
attribute array for `index`. The size is the number of values for each element of the vertex
attribute array, and it will be 1, 2, 3, or 4. The initial value is 4.

`GL_VERTEX_ATTRIB_ARRAY_STRIDE` `params` returns a single value, the array stride for (number
of bytes between successive elements in) the vertex attribute array for `index`. A value of 0
indicates that the array elements are stored sequentially in memory. The initial value is 0.

`GL_VERTEX_ATTRIB_ARRAY_TYPE` `params` returns a single value, a symbolic constant indicating
the array type for the vertex attribute array for `index`. Possible values are `GL_BYTE`,
`GL_UNSIGNED_BYTE`, `GL_SHORT`, `GL_UNSIGNED_SHORT`, `GL_INT`, `GL_UNSIGNED_INT`,
`GL_FLOAT`, and `GL_DOUBLE`. The initial value is `GL_FLOAT`.

`GL_VERTEX_ATTRIB_ARRAY_NORMALIZED` `params` returns a single value that is non-zero (true)
if fixed-point data types for the vertex attribute array indicated by `index` are normalized when
they are converted to floating point, and 0 (false) otherwise. The initial value is `GL_FALSE`.

`GL_VERTEX_ATTRIB_ARRAY_INTEGER` `params` returns a single value that is non-zero (true) if
fixed-point data types for the vertex attribute array indicated by `index` have integer data
types, and 0 (false) otherwise. The initial value is 0 ( `GL_FALSE` ).

`GL_VERTEX_ATTRIB_ARRAY_LONG` `param` returns a single value that is non-zero (true) if a
vertex attribute is stored as an unconverted double, and 0 (false) otherwise. The initial value is 0
( `GL_FALSE` ).

`GL_VERTEX_ATTRIB_ARRAY_DIVISOR` `params` returns a single value that is the frequency
divisor used for instanced rendering. See glVertexAttribDivisor. The initial value is 0.

`GL_VERTEX_ATTRIB_BINDING` `params` returns a single value, the vertex buffer binding of the
vertex attribute array `index`.

`GL_VERTEX_ATTRIB_RELATIVE_OFFSET` `params` returns a single value that is the byte offset of
the first element relative to the start of the vertex buffer binding specified attribute fetches
from. The initial value is 0.

`GL_CURRENT_VERTEX_ATTRIB` `params` returns four values that represent the current value for
the generic vertex attribute specified by index. Generic vertex attribute 0 is unique in that it has
no current state, so an error will be generated if `index` is 0. The initial value for all other
generic vertex attributes is (0,0,0,1).

`glGetVertexAttribdv` and `glGetVertexAttribfv` return the current attribute values as four
single-precision floating-point values; `glGetVertexAttribiv` reads them as floating-point values
and converts them to four integer values; `glGetVertexAttribIiv` and `glGetVertexAttribIuiv`
read and return them as signed or unsigned integer values, respectively; `glGetVertexAttribLdv`
reads and returns them as four double-precision floating-point values.

All of the parameters except `GL_CURRENT_VERTEX_ATTRIB` represent state stored in the currently
bound vertex array object.
---
### Notes
If an error is generated, no change is made to the contents of `params`.
---
### Errors
`GL_INVALID_OPERATION` is generated if `pname` is not `GL_CURRENT_VERTEX_ATTRIB` and there is
no currently bound vertex array object.

`GL_INVALID_VALUE` is generated if `index` is greater than or equal to `GL_MAX_VERTEX_ATTRIBS`.

`GL_INVALID_ENUM` is generated if `pname` is not an accepted value.

`GL_INVALID_OPERATION` is generated if `index` is 0 and `pname` is
`GL_CURRENT_VERTEX_ATTRIB`.
---
### Associated Gets
glGet with argument `GL_MAX_VERTEX_ATTRIBS`

glGetVertexAttribPointerv with arguments `index` and `GL_VERTEX_ATTRIB_ARRAY_POINTER`
---
### Version Support
`glGetVertexAttribIiv` `glGetVertexAttribIuiv` `glGetVertexAttribLdv`
`glGetVertexAttribdv` `glGetVertexAttribfv` `glGetVertexAttribiv`
---
### See Also
glBindAttribLocation, glBindBuffer, `glDisableVertexAttribArray`,
glEnableVertexAttribArray, glVertexAttrib, glVertexAttribDivisor, glVertexAttribPointer
---
### Copyright
Copyright 2003-2005 3Dlabs Inc. Ltd. Copyright 2010-2014 Khronos Group. This material may be
distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8
June 1999. https://opencontent.org/openpub/.
]],
  [[Set a named parameter of a framebuffer object
---
### Parameters
`target` Specifies the target to which the framebuffer is bound for `glFramebufferParameteri`.

`framebuffer` Specifies the name of the framebuffer object for `glNamedFramebufferParameteri`.

`pname` Specifies the framebuffer parameter to be modified.
`param` The new value for the parameter named `pname`.

---
### Description
`glFramebufferParameteri` and `glNamedFramebufferParameteri` modify the value of the parameter
named `pname` in the specified framebuffer object. There are no modifiable parameters of the
default draw and read framebuffer, so they are not valid targets of these commands.

For `glFramebufferParameteri`, the framebuffer object is that bound to `target`, which must be
`GL_DRAW_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER` or `GL_FRAMEBUFFER`. `GL_FRAMEBUFFER` is
equivalent to `GL_DRAW_FRAMEBUFFER`.

For `glNamedFramebufferParameteri`, `framebuffer` is the name of the framebuffer object.

`pname` specifies the parameter to be modified. The following values are accepted:

`GL_FRAMEBUFFER_DEFAULT_WIDTH` `param` specifies the assumed with for a framebuffer object
with no attachments. If a framebuffer has attachments then the width of those attachments is used,
otherwise the value of `GL_FRAMEBUFFER_DEFAULT_WIDTH` is used for the framebuffer. `param` must
be greater than or equal to zero and less than or equal to the value of `GL_MAX_FRAMEBUFFER_WIDTH`.

`GL_FRAMEBUFFER_DEFAULT_HEIGHT` `param` specifies the assumed height for a framebuffer object
with no attachments. If a framebuffer has attachments then the height of those attachments is used,
otherwise the value of `GL_FRAMEBUFFER_DEFAULT_HEIGHT` is used for the framebuffer. `param` must
be greater than or equal to zero and less than or equal to the value of `GL_MAX_FRAMEBUFFER_HEIGHT`.

`GL_FRAMEBUFFER_DEFAULT_LAYERS` `param` specifies the assumed number of layers for a
framebuffer object with no attachments. If a framebuffer has attachments then the layer count of
those attachments is used, otherwise the value of `GL_FRAMEBUFFER_DEFAULT_LAYERS` is used for the
framebuffer. `param` must be greater than or equal to zero and less than or equal to the value of
`GL_MAX_FRAMEBUFFER_LAYERS`.

`GL_FRAMEBUFFER_DEFAULT_SAMPLES` `param` specifies the assumed number of samples in a
framebuffer object with no attachments. If a framebuffer has attachments then the sample count of
those attachments is used, otherwise the value of `GL_FRAMEBUFFER_DEFAULT_SAMPLES` is used for the
framebuffer. `param` must be greater than or equal to zero and less than or equal to the value of
`GL_MAX_FRAMEBUFFER_SAMPLE`.

`GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS` `param` specifies whether the framebuffer
should assume identical sample locations and the same number of samples for all texels in the
virtual image. If `param` is zero, then the implementation may vary the position or the count of
samples within the virtual image from pixel to pixel, otherwise it will use the same sample position
and count for all pixels in the virtual image.

---
### Errors
`GL_INVALID_ENUM` is generated by `glFramebufferParameteri` if `target` is not one of the
accepted framebuffer targets.

`GL_INVALID_OPERATION` is generated by `glFramebufferParameteri` if the default framebuffer is
bound to `target`.

`GL_INVALID_OPERATION` is generated by `glNamedFramebufferParameteri` if `framebuffer` is not
the name of an existing framebuffer object.

`GL_INVALID_VALUE` is generated if `pname` is `GL_FRAMEBUFFER_DEFAULT_WIDTH` and `param` is
less than zero or greater than the value of `GL_MAX_FRAMEBUFFER_WIDTH`.

`GL_INVALID_VALUE` is generated if `pname` is `GL_FRAMEBUFFER_DEFAULT_HEIGHT` and `param`
is less than zero or greater than the value of `GL_MAX_FRAMEBUFFER_HEIGHT`.

`GL_INVALID_VALUE` is generated if `pname` is `GL_FRAMEBUFFER_DEFAULT_LAYERS` and `param`
is less than zero or greater than the value of `GL_MAX_FRAMEBUFFER_LAYERS`.

`GL_INVALID_VALUE` is generated if `pname` is `GL_FRAMEBUFFER_DEFAULT_SAMPLES` and `param`
is less than zero or greater than the value of `GL_MAX_FRAMEBUFFER_SAMPLES`.
---
### Associated Gets
`glGetFramebufferParameteriv`.
---
### Version Support
`glFramebufferParameteri` `glNamedFramebufferParameteri`
---
### See Also
glBindFramebuffer, glCreateFramebuffers, glFramebufferRenderbuffer, glFramebufferTexture,
glGenFramebuffers, glGetFramebufferParameter
---
### Copyright
Copyright 2013-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Attach a renderbuffer as a logical buffer of a framebuffer object
---
### Parameters
`target` Specifies the target to which the framebuffer is bound for
`glFramebufferRenderbuffer`.

`framebuffer` Specifies the name of the framebuffer object for
`glNamedFramebufferRenderbuffer`.

`attachment` Specifies the attachment point of the framebuffer.
`renderbuffertarget` Specifies the renderbuffer target. Must be `GL_RENDERBUFFER`.

`renderbuffer` Specifies the name of an existing renderbuffer object of type
`renderbuffertarget` to attach.

---
### Description
`glFramebufferRenderbuffer` and `glNamedFramebufferRenderbuffer` attaches a renderbuffer as one
of the logical buffers of the specified framebuffer object. Renderbuffers cannot be attached to the
default draw and read framebuffer, so they are not valid targets of these commands.

For `glFramebufferRenderbuffer`, the framebuffer object is that bound to `target`, which must
be `GL_DRAW_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER` or `GL_FRAMEBUFFER`. `GL_FRAMEBUFFER` is
equivalent to `GL_DRAW_FRAMEBUFFER`.

For `glNamedFramebufferRenderbuffer`, `framebuffer` is the name of the framebuffer object.

`renderbuffertarget` must be `GL_RENDERBUFFER`.

`renderbuffer` must be zero or the name of an existing renderbuffer object of type
`renderbuffertarget`. If `renderbuffer` is not zero, then the specified renderbuffer will be used
as the logical buffer identified by `attachment` of the specified framebuffer object. If
`renderbuffer` is zero, then the value of `renderbuffertarget` is ignored.

`attachment` specifies the logical attachment of the framebuffer and must be
`GL_COLOR_ATTACHMENT` i, `GL_DEPTH_ATTACHMENT`, `GL_STENCIL_ATTACHMENT` or
`GL_DEPTH_STENCIL_ATTACHMENT`. i in may range from zero to the value of
`GL_MAX_COLOR_ATTACHMENTS` minus one. Setting `attachment` to the value
`GL_DEPTH_STENCIL_ATTACHMENT` is a special case causing both the depth and stencil attachments of
the specified framebuffer object to be set to `renderbuffer`, which should have the base internal
format `GL_DEPTH_STENCIL`.

The value of `GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE` for the specified attachment point is set
to `GL_RENDERBUFFER` and the value of `GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME` is set to
`renderbuffer`. All other state values of specified attachment point are set to their default
values. No change is made to the state of the renderbuuffer object and any previous attachment to
the `attachment` logical buffer of the specified framebuffer object is broken.

If `renderbuffer` is zero, these commands will detach the image, if any, identified by the
specified attachment point of the specified framebuffer object. All state values of the attachment
point are set to their default values.
---
### Errors
`GL_INVALID_ENUM` is generated by `glFramebufferRenderbuffer` if `target` is not one of the
accepted framebuffer targets.

`GL_INVALID_OPERATION` is generated by `glFramebufferRenderbuffer` if zero is bound to
`target`.

`GL_INVALID_OPERATION` is generated by `glNamedFramebufferRenderbuffer` if `framebuffer` is
not the name of an existing framebuffer object.

`GL_INVALID_ENUM` is generated if `attachment` is not one of the accepted attachment points.

`GL_INVALID_ENUM` is generated if `renderbuffertarget` is not `GL_RENDERBUFFER`.

`GL_INVALID_OPERATION` is generated if `renderbuffertarget` is not zero or the name of an
existing renderbuffer object of type `GL_RENDERBUFFER`.
---
### Version Support
`glFramebufferRenderbuffer` `glNamedFramebufferRenderbuffer`
---
### See Also
glGenFramebuffers, glBindFramebuffer, glGenRenderbuffers, glFramebufferTexture,
`glFramebufferTexture1D`, `glFramebufferTexture2D`, `glFramebufferTexture3D`
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Attach a level of a texture object as a logical buffer of a framebuffer object
---
### Parameters
`target` Specifies the target to which the framebuffer is bound for all commands except
`glNamedFramebufferTexture`.

`framebuffer` Specifies the name of the framebuffer object for `glNamedFramebufferTexture`.

`attachment` Specifies the attachment point of the framebuffer.
`textarget` For `glFramebufferTexture1D`, `glFramebufferTexture2D` and
`glFramebufferTexture3D`, specifies what type of texture is expected in the `texture` parameter,
or for cube map textures, which face is to be attached.

`texture` Specifies the name of an existing texture object to attach.
`level` Specifies the mipmap level of the texture object to attach.
---
### Description
These commands attach a selected mipmap level or image of a texture object as one of the logical
buffers of the specified framebuffer object. Textures cannot be attached to the default draw and
read framebuffer, so they are not valid targets of these commands. For all commands except
`glNamedFramebufferTexture`, the framebuffer object is that bound to `target`, which must be
`GL_DRAW_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER`, or `GL_FRAMEBUFFER`. `GL_FRAMEBUFFER` is
equivalent to `GL_DRAW_FRAMEBUFFER`.

For `glNamedFramebufferTexture`, `framebuffer` is the name of the framebuffer object.

`attachment` specifies the logical attachment of the framebuffer and must be
`GL_COLOR_ATTACHMENT` i, `GL_DEPTH_ATTACHMENT`, `GL_STENCIL_ATTACHMENT` or
`GL_DEPTH_STENCIL_ATTACHMENT`. i in `GL_COLOR_ATTACHMENT` i may range from zero to the value of
`GL_MAX_COLOR_ATTACHMENTS` minus one. Attaching a level of a texture to
`GL_DEPTH_STENCIL_ATTACHMENT` is equivalent to attaching that level to both the
`GL_DEPTH_ATTACHMENT` and the `GL_STENCIL_ATTACHMENT` attachment points simultaneously.

For `glFramebufferTexture1D`, `glFramebufferTexture2D` and `glFramebufferTexture3D`,
`textarget` specifies what type of texture is named by `texture`, and for cube map textures,
specifies the face that is to be attached. If `texture` is not zero, it must be the name of an
existing texture object with effective target `textarget` unless it is a cube map texture, in
which case `textarget` must be `GL_TEXTURE_CUBE_MAP_POSITIVE_X` `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`,
`GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`,
`GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`.

If `texture` is non-zero, the specified `level` of the texture object named `texture` is
attached to the framebuffer attachment point named by `attachment`. For `glFramebufferTexture1D`,
`glFramebufferTexture2D`, and `glFramebufferTexture3D`, `texture` must be zero or the name
of an existing texture with an effective target of `textarget`, or `texture` must be the name of
an existing cube-map texture and `textarget` must be one of `GL_TEXTURE_CUBE_MAP_POSITIVE_X`,
`GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`,
`GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, or
`GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`.

If `textarget` is `GL_TEXTURE_RECTANGLE`, `GL_TEXTURE_2D_MULTISAMPLE`, or
`GL_TEXTURE_2D_MULTISAMPLE_ARRAY`, then `level` must be zero.

If `textarget` is `GL_TEXTURE_3D`, then `level` must be greater than or equal to zero and
less than or equal to $log_2$ of the value of `GL_MAX_3D_TEXTURE_SIZE`.

If `textarget` is one of `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`,
`GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`,
`GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`, then `level` must be
greater than or equal to zero and less than or equal to $log_2$ of the value of
`GL_MAX_CUBE_MAP_TEXTURE_SIZE`.

For all other values of `textarget`, `level` must be greater than or equal to zero and less
than or equal to $log_2$ of the value of `GL_MAX_TEXTURE_SIZE`.

`layer` specifies the layer of a 2-dimensional image within a 3-dimensional texture.

For `glFramebufferTexture1D`, if `texture` is not zero, then `textarget` must be
`GL_TEXTURE_1D`. For `glFramebufferTexture2D`, if `texture` is not zero, `textarget` must be
one of `GL_TEXTURE_2D`, `GL_TEXTURE_RECTANGLE`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`,
`GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`,
`GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`,
`GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`, or `GL_TEXTURE_2D_MULTISAMPLE`. For `glFramebufferTexture3D`,
if `texture` is not zero, then `textarget` must be `GL_TEXTURE_3D`.

For `glFramebufferTexture` and `glNamedFramebufferTexture`, if `texture` is the name of a
three-dimensional, cube map array, cube map, one- or two-dimensional array, or two-dimensional
multisample array texture, the specified texture level is an array of images, and the framebuffer
attachment is considered to be layered.
---
### Errors
`GL_INVALID_ENUM` is generated by all commands accepting a `target` parameter if it is not one
of the accepted framebuffer targets.

`GL_INVALID_OPERATION` is generated by all commands accepting a `target` parameter if zero is
bound to that target.

`GL_INVALID_OPERATION` is generated by `glNamedFramebufferTexture` if `framebuffer` is not
the name of an existing framebuffer object.

`GL_INVALID_ENUM` is generated if `attachment` is not one of the accepted attachment points.

`GL_INVALID_VALUE` is generated if `texture` is not zero or the name of an existing texture
object.

`GL_INVALID_VALUE` is generated if `texture` is not zero and `level` is not a supported
texture level for `texture`.

`GL_INVALID_VALUE` is generated by `glFramebufferTexture3D` if `texture` is not zero and
`layer` is larger than the value of `GL_MAX_3D_TEXTURE_SIZE` minus one.

`GL_INVALID_OPERATION` is generated by all commands accepting a `textarget` parameter if
`texture` is not zero, and `textarget` and the effective target of `texture` are not
compatible.

`GL_INVALID_OPERATION` is generated by if `texture` is a buffer texture.
---
### Version Support
`glFramebufferTexture` `glFramebufferTexture1D` `glFramebufferTexture2D`
`glFramebufferTexture3D` `glNamedFramebufferTexture`
---
### See Also
glGenFramebuffers, glBindFramebuffer, glGenRenderbuffers, glFramebufferTexture,
`glFramebufferTexture1D`, `glFramebufferTexture2D`, `glFramebufferTexture3D`
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Query a named parameter of a framebuffer object
---
### Parameters
`target` Specifies the target to which the framebuffer object is bound for
`glGetFramebufferParameteriv`.

`framebuffer` Specifies the name of the framebuffer object for
`glGetNamedFramebufferParameteriv`.

`pname` Specifies the parameter of the framebuffer object to query.
`params` Returns the value of parameter `pname` for the framebuffer object.

---
### Description
`glGetFramebufferParameteriv` and `glGetNamedFramebufferParameteriv` query parameters of a
specified framebuffer object.

For `glGetFramebufferParameteriv`, the framebuffer object is that bound to `target`, which
must be one of `GL_DRAW_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER` or `GL_FRAMEBUFFER`.
`GL_FRAMEBUFFER` is equivalent to `GL_DRAW_FRAMEBUFFER`. Default framebuffers may also be queried
if bound to `target`.

For `glGetNamedFramebufferParameteriv`, `framebuffer` is the name of the framebuffer object.

If `framebuffer` is zero, the default draw framebuffer is queried.

Upon successful return, `param` will contain the value of the framebuffer parameter specified by
`pname`, as described below.

The following parameters can only be queried for framebuffer objects:
`GL_FRAMEBUFFER_DEFAULT_WIDTH` `params` returns the value of `GL_FRAMEBUFFER_DEFAULT_WIDTH` for
the framebuffer object.

`GL_FRAMEBUFFER_DEFAULT_HEIGHT` `params` returns the value of `GL_FRAMEBUFFER_DEFAULT_HEIGHT`
for the framebuffer object.

`GL_FRAMEBUFFER_DEFAULT_LAYERS` `params` returns the value of `GL_FRAMEBUFFER_DEFAULT_LAYERS`
for the framebuffer object.

`GL_FRAMEBUFFER_DEFAULT_SAMPLES` `params` returns the value of
`GL_FRAMEBUFFER_DEFAULT_SAMPLES` for the framebuffer object.

`GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS` `params` returns the boolean value of
`GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS`.

The following parameters can be queried for both default framebuffers and framebuffer objects:
`GL_DOUBLEBUFFER` `param` returns a boolean value indicating whether double buffering is
supported for the framebuffer object.

`GL_IMPLEMENTATION_COLOR_READ_FORMAT` `param` returns a GLenum value indicating the preferred
pixel data format for the framebuffer object. See glReadPixels.

`GL_IMPLEMENTATION_COLOR_READ_TYPE` `param` returns a GLenum value indicating the
implementation's preferred pixel data type for the framebuffer object. See glReadPixels.

`GL_SAMPLES` `param` returns an integer value indicating the coverage mask size for the
framebuffer object. See glSampleCoverage.

`GL_SAMPLE_BUFFERS` `param` returns an integer value indicating the number of sample buffers
associated with the framebuffer object. See glSampleCoverage.

`GL_STEREO` `param` returns a boolean value indicating whether stereo buffers (left and right)
are supported for the framebuffer object.

---
### Notes
Queries of default framebuffers are supported only if the GL version is 4.5 or higher. Otherwise,
an `GL_INVALID_OPERATION` error is generated.

Queries of the framebuffer-dependent parameters `GL_DOUBLEBUFFER`,
`GL_IMPLEMENTATION_COLOR_READ_FORMAT`, `GL_IMPLEMENTATION_COLOR_READ_TYPE`, `GL_SAMPLES`,
`GL_SAMPLE_BUFFERS` and `GL_STEREO` are supported only if the GL version is 4.5 or higher.

The framebuffer-dependent state `GL_SAMPLE_POSITION` cannot be queried with these commands.
---
### Errors
`GL_INVALID_ENUM` is generated by `glGetFramebufferParameteriv` if `target` is not one of the
accepted framebuffer targets.

`GL_INVALID_OPERATION` is generated by `glGetNamedFramebufferAttachmentParameteriv` if
`framebuffer` is not zero or the name of an existing framebuffer object.

`GL_INVALID_ENUM` is generated if `pname` is not one of the accepted parameter names.

`GL_INVALID_OPERATION` is generated if a default framebuffer is queried, and `pname` is not one
of `GL_DOUBLEBUFFER`, `GL_IMPLEMENTATION_COLOR_READ_FORMAT`,
`GL_IMPLEMENTATION_COLOR_READ_TYPE`, `GL_SAMPLES`, `GL_SAMPLE_BUFFERS` or `GL_STEREO`.
---
### Associated Gets
glGetFramebufferAttachmentParameter
---
### Version Support
`glGetFramebufferParameteriv` `glGetNamedFramebufferParameteriv`
---
### See Also
glFramebufferParameteri, glGetFramebufferAttachmentParameter
---
### Copyright
Copyright 2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Check if the rendering context has not been lost due to software or hardware issues
---
### Description
Certain events can result in a reset of the GL context. Such a reset causes all context state to
be lost and requires the application to recreate all objects in the affected context.
`glGetGraphicsResetStatus` can return one of the following constants:

`GL_NO_ERROR` Indicates that the GL context has not been in a reset state since the last call.

`GL_GUILTY_CONTEXT_RESET` Indicates that a reset has been detected that is attributable to the
current GL context.
`GL_INNOCENT_CONTEXT_RESET` Indicates a reset has been detected that is not attributable to the
current GL context.
`GL_UNKNOWN_CONTEXT_RESET` Indicates a detected graphics reset whose cause is unknown.

If a reset status other than `GL_NO_ERROR` is returned and subsequent calls return
`GL_NO_ERROR`, the context reset was encountered and completed. If a reset status is repeatedly
returned, the context may be in the process of resetting.

Reset notification behavior is determined at context creation time, and may be queried by calling
`GetIntegerv` with the symbolic constant `GL_RESET_NOTIFICATION_STRATEGY`.

If the reset notification behavior is `GL_NO_RESET_NOTIFICATION`, then the implementation will
never deliver notification of reset events, and `glGetGraphicsResetStatus` will always return
`GL_NO_ERROR`.

If the behavior is `GL_LOSE_CONTEXT_ON_RESET`, a graphics reset will result in the loss of all
context state, requiring the recreation of all associated objects. In this case
`glGetGraphicsResetStatus` may return any of the values described above.

If a graphics reset notification occurs in a context, a notification must also occur in all other
contexts which share objects with that context. After a graphics reset has occurred on a context,
subsequent GL commands on that context (or any context which shares with that context) will generate
a `GL_CONTEXT_LOST` error. Such commands will not have side effects (in particular, they will not
modify memory passed by pointer for query results), and will not block indefinitely or cause
termination of the application. There are two important exceptions to this behavior:

`glGetError` and `glGetGraphicsResetStatus` behave normally following a graphics reset, so
that the application can determine a reset has occurred, and when it is safe to destroy and
re-create the context.

Any commands which might cause a polling application to block indefinitely will generate a
`GL_CONTEXT_LOST` error, but will also return a value indicating completion to the application.

Such commands include: `glGetSynciv` with pname `GL_SYNC_STATUS` ignores the other parameters
and returns `GL_SIGNALED` in `values`.

`glGetQueryObjectuiv` with pname `GL_QUERY_RESULT_AVAILABLE` ignores the other parameters and
returns `TRUE` in `params`.


---
### Version Support
`glGetGraphicsResetStatus`
---
### See Also
glGetError `glGetIntegerv`, `glGetQueryObjectuiv` `glGetSynciv`
---
### Copyright
Copyright 2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Attach a single layer of a texture object as a logical buffer of a framebuffer object
---
### Parameters
`target` Specifies the target to which the framebuffer is bound for
`glFramebufferTextureLayer`.

`framebuffer` Specifies the name of the framebuffer object for
`glNamedFramebufferTextureLayer`.

`attachment` Specifies the attachment point of the framebuffer.
`texture` Specifies the name of an existing texture object to attach.
`level` Specifies the mipmap level of the texture object to attach.
`layer` Specifies the layer of the texture object to attach.
---
### Description
`glFramebufferTextureLayer` and `glNamedFramebufferTextureLayer` attach a single layer of a
three-dimensional or array texture object as one of the logical buffers of the specified framebuffer
object. Textures cannot be attached to the default draw and read framebuffer, so they are not valid
targets of these commands.

For `glFramebufferTextureLayer`, the framebuffer object is that bound to `target`, which must
be `GL_DRAW_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER`, or `GL_FRAMEBUFFER`. `GL_FRAMEBUFFER` is
equivalent to `GL_DRAW_FRAMEBUFFER`.

For `glNamedFramebufferTextureLayer`, `framebuffer` is the name of the framebuffer object.

`attachment` specifies the logical attachment of the framebuffer and must be
`GL_COLOR_ATTACHMENT` i, `GL_DEPTH_ATTACHMENT`, `GL_STENCIL_ATTACHMENT` or
`GL_DEPTH_STENCIL_ATTACHMENT`. i in `GL_COLOR_ATTACHMENT` i may range from zero to the value of
`GL_MAX_COLOR_ATTACHMENTS` minus one. Attaching a level of a texture to
`GL_DEPTH_STENCIL_ATTACHMENT` is equivalent to attaching that level to both the
`GL_DEPTH_ATTACHMENT` and the `GL_STENCIL_ATTACHMENT` attachment points simultaneously.

If `texture` is not zero, it must be the name of a three-dimensional, two-dimensional
multisample array, one- or two-dimensional array, or cube map array texture.

If `texture` is a three-dimensional texture, then `level` must be greater than or equal to
zero and less than or equal to $log_2$ of the value of `GL_MAX_3D_TEXTURE_SIZE`.

If `texture` is a two-dimensional array texture, then `level` must be greater than or equal to
zero and less than or equal to $log_2$ of the value of `GL_MAX_TEXTURE_SIZE`.

For cube map textures, `layer` is translated into a cube map face according to $$ face = k \\\\bmod
6. $$ For cube map array textures, `layer` is translated into an array layer and face according to
$$ layer = \\\\left\\\\lfloor { layer \\\\over 6 } \\\\right\\\\rfloor$$ and $$ face = k \\\\bmod 6. $$
---
### Errors
`GL_INVALID_ENUM` is generated by `glFramebufferTexture` if `target` is not one of the
accepted framebuffer targets.

`GL_INVALID_OPERATION` is generated by `glFramebufferTexture` if zero is bound to `target`.

`GL_INVALID_OPERATION` is generated by `glNamedFramebufferTexture` if `framebuffer` is not
the name of an existing framebuffer object.

`GL_INVALID_ENUM` is generated if `attachment` is not one of the accepted attachment points.

`GL_INVALID_OPERATION` is generated if `texture` is not zero and is not the name of an existing
three-dimensional, two-dimensional multisample array, one- or two-dimensional array, cube map, or
cube map array texture.

`GL_INVALID_VALUE` is generated if `texture` is not zero and `level` is not a supported
texture level for `texture`, as described above.

`GL_INVALID_VALUE` is generated if `texture` is not zero and `layer` is larger than the value
of `GL_MAX_3D_TEXTURE_SIZE` minus one (for three-dimensional texture objects), or larger than the
value of `GL_MAX_ARRAY_TEXTURE_LAYERS` minus one (for array texture objects).

`GL_INVALID_VALUE` is generated if `texture` is not zero and `layer` is negative.

`GL_INVALID_OPERATION` is generated by if `texture` is a buffer texture.
---
### Version Support
`glFramebufferTextureLayer` `glNamedFramebufferTextureLayer`
---
### See Also
glGenFramebuffers, glBindFramebuffer, glGenRenderbuffers, glFramebufferTexture,
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Retrieve information about implementation-dependent support for internal formats
---
### Parameters
`target` Indicates the usage of the internal format. `target` must be `GL_TEXTURE_1D`,
`GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_3D`,
`GL_TEXTURE_CUBE_MAP`, `GL_TEXTURE_CUBE_MAP_ARRAY`, `GL_TEXTURE_RECTANGLE`,
`GL_TEXTURE_BUFFER`, `GL_RENDERBUFFER`, `GL_TEXTURE_2D_MULTISAMPLE` or
`GL_TEXTURE_2D_MULTISAMPLE_ARRAY`.

`internalformat` Specifies the internal format about which to retrieve information.
`pname` Specifies the type of information to query.
`bufSize` Specifies the maximum number of integers of the specified width that may be written
to `params` by the function.

`params` Specifies the address of a variable into which to write the retrieved information.
---
### Description
`glGetInternalformativ` and `glGetInternalformati64v` retrieve information about
implementation-dependent support for internal formats. `target` indicates the target with which
the internal format will be used and must be one of `GL_RENDERBUFFER`,
`GL_TEXTURE_2D_MULTISAMPLE`, or `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`, corresponding to usage as a
renderbuffer, two-dimensional multisample texture or two-dimensional multisample array texture,
respectively.

`internalformat` specifies the internal format about which to retrieve information and must be a
color-renderable, depth-renderable or stencil-renderable format.

The information retrieved will be written to memory addressed by the pointer specified in
`params`. No more than `bufSize` integers will be written to this memory.

If `pname` is `GL_NUM_SAMPLE_COUNTS`, the number of sample counts that would be returned by
querying `GL_SAMPLES` will be returned in `params`.

If `pname` is `GL_SAMPLES`, the sample counts supported for `internalformat` and `target`
are written into `params` in descending numeric order. Only positive values are returned. Querying
`GL_SAMPLES` with `bufSize` of one will return just the maximum supported number of samples for
this format. The maximum value in `GL_SAMPLES` is guaranteed to be at least the lowest of the
following: The value of `GL_MAX_INTEGER_SAMPLES` if `internalformat` is a signed or unsigned
integer format.

The value of `GL_MAX_DEPTH_TEXTURE_SAMPLES` if `internalformat` is a depth- or
stencil-renderable format and `target` is `GL_TEXTURE_2D_MULTISAMPLE`,
`GL_TEXTURE_2D_MULTISAMPLE_ARRAY`.

The value of `GL_MAX_COLOR_TEXTURE_SAMPLES` if `internalformat` is a color-renderable format
and `target` is `GL_TEXTURE_2D_MULTISAMPLE` or `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`.

The value of `GL_MAX_SAMPLES`.


If `pname` is `GL_INTERNALFORMAT_SUPPORTED`, `params` is set to `GL_TRUE` if
`internalformat` is a supported internal format for `target` and to `GL_FALSE` otherwise.

If `pname` is `GL_INTERNALFORMAT_PREFERRED`, `params` is set to `GL_TRUE` if
`internalformat` is an format for `target` that is preferred by the implementation and to
`GL_FALSE` otherwise.

If `pname` is `GL_INTERNALFORMAT_RED_SIZE`, `GL_INTERNALFORMAT_GREEN_SIZE`,
`GL_INTERNALFORMAT_BLUE_SIZE`, `GL_INTERNALFORMAT_ALPHA_SIZE`, `GL_INTERNALFORMAT_DEPTH_SIZE`,
`GL_INTERNALFORMAT_STENCIL_SIZE`, or `GL_INTERNALFORMAT_SHARED_SIZE` then `params` is set to
the actual resolutions that would be used for storing image array components for the resource for
the red, green, blue, alpha, depth, stencil and shared channels respectively. If `internalformat`
is a compressed internal format, then `params` is set to the component resolution of an
uncompressed internal format that produces an image of roughly the same quality as the compressed
algorithm. If the internal format is unsupported, or if a particular component is not present in the
format, 0 is written to `params`.

If `pname` is `GL_INTERNALFORMAT_RED_TYPE`, `GL_INTERNALFORMAT_GREEN_TYPE`,
`GL_INTERNALFORMAT_BLUE_TYPE`, `GL_INTERNALFORMAT_ALPHA_TYPE`, `GL_INTERNALFORMAT_DEPTH_TYPE`,
or `GL_INTERNALFORMAT_STENCIL_TYPE` then `params` is set to a token identifying the data type
used to store the respective component. If the `internalformat` represents a compressed internal
format then the types returned specify how components are interpreted after decompression.

If `pname` is `GL_MAX_WIDTH`, `GL_MAX_HEIGHT`, `GL_MAX_DEPTH`, or `GL_MAX_LAYERS` then
`pname` is filled with the maximum width, height, depth or layer count for textures with internal
format `internalformat`, respectively. If `pname` is `GL_MAX_COMBINED_DIMENSIONS` then
`pname` is filled with the maximum combined dimensions of a texture of the specified internal
format.

If `pname` is `GL_COLOR_COMPONENTS` then `params` is set to the value `GL_TRUE` if the
internal format contains any color component (i.e., red, green, blue or alpha) and to `GL_FALSE`
otherwise. If `pname` is `GL_DEPTH_COMPONENTS` or `GL_STENCIL_COMPONENTS` then `params` is
set to `GL_TRUE` if the internal format contains a depth or stencil component, respectively, and
to `GL_FALSE` otherwise.

If `pname` is `GL_COLOR_RENDERABLE`, `GL_DEPTH_RENDERABLE` or `GL_STENCIL_RENDERABLE` then
`params` is set to `GL_TRUE` if the specified internal format is color, depth or stencil
renderable, respectively, and to `GL_FALSE` otherwise.

If `pname` is `GL_FRAMEBUFFER_RENDERABLE` or `GL_FRAMEBUFFER_RENDERABLE_LAYERED` then
`params` is set to one of `GL_FULL_SUPPORT`, `GL_CAVEAT_SUPPORT` or `GL_NONE` to indicate
that framebuffer attachments (layered attachments in the case of
`GL_FRAMEBUFFER_RENDERABLE_LAYERED` ) with that internal format are either renderable with no
restrictions, renderable with some restrictions or not renderable at all.

If `pname` is `GL_FRAMEBUFFER_BLEND`, `params` is set to `GL_TRUE` to indicate that the
internal format is supported for blending operations when attached to a framebuffer, and to
`GL_FALSE` otherwise.

If `pname` is `GL_READ_PIXELS` then `params` is set to `GL_FULL_SUPPORT`,
`GL_CAVEAT_SUPPORT` or `GL_NONE` to that either full support, limited support or no support at
all is supplied for reading pixels from framebuffer attachments in the specified internal format.

If `pname` is `GL_READ_PIXELS_FORMAT` or `GL_READ_PIXELS_TYPE` then `params` is filled
with the format or type, respectively, most recommended to obtain the highest image quality and
performance. For `GL_READ_PIXELS_FORMAT`, the value returned in `params` is a token that is
accepted for the `format` argument to glReadPixels. For `GL_READ_PIXELS_TYPE`, the value
returned in `params` is a token that is accepted for the `type` argument to glReadPixels.

If `pname` is `GL_TEXTURE_IMAGE_FORMAT` or `GL_TEXTURE_IMAGE_TYPE` then `params` is filled
with the implementation-recommended format or type to be used in calls to glTexImage2D and other
similar functions. For `GL_TEXTURE_IMAGE_FORMAT`, `params` is filled with a token suitable for
use as the `format` argument to glTexImage2D. For `GL_TEXTURE_IMAGE_TYPE`, `params` is
filled with a token suitable for use as the `type` argument to glTexImage2D.

If `pname` is `GL_GET_TEXTURE_IMAGE_FORMAT` or `GL_GET_TEXTURE_IMAGE_TYPE` then `params`
is filled with the implementation-recommended format or type to be used in calls to glGetTexImage
and other similar functions. For `GL_GET_TEXTURE_IMAGE_FORMAT`, `params` is filled with a token
suitable for use as the `format` argument to glGetTexImage. For `GL_GET_TEXTURE_IMAGE_TYPE`,
`params` is filled with a token suitable for use as the `type` argument to glGetTexImage.

If `pname` is `GL_MIPMAP` then `pname` is set to `GL_TRUE` to indicate that the specified
internal format supports mipmaps and to `GL_FALSE` otherwise.

If `pname` is `GL_GENERATE_MIPMAP` or `GL_AUTO_GENERATE_MIPMAP` then `params` is indicates
the level of support for manual or automatic mipmap generation for the specified internal format,
respectively. Returned values may be one of `GL_FULL_SUPPORT`, `GL_CAVEAT_SUPPORT` and
`GL_NONE` to indicate either full support, limited support or no support at all.

If `pname` is `GL_COLOR_ENCODING` then the color encoding for the resource is returned in
`params`. Possible values for color buffers are `GL_LINEAR` or `GL_SRGB`, for linear or
sRGB-encoded color components, respectively. For non-color formats (such as depth or stencil), or
for unsupported resources, the value `GL_NONE` is returned.

If `pname` is `GL_SRGB_READ`, or `GL_SRGB_WRITE` then `params` indicates the level of
support for reading and writing to sRGB encoded images, respectively. For `GL_SRGB_READ`, support
for converting from sRGB colorspace on read operations is returned in `params` and for
`GL_SRGB_WRITE`, support for converting to sRGB colorspace on write operations to the resource is
returned in `params`. `params` may be set to `GL_FULL_SUPPORT`, `GL_CAVEAT_SUPPORT`, or
`GL_NONE` to indicate full support, limited support or no support at all, respecitively.

If `pname` is `GL_FILTER` the `params` is set to either `GL_TRUE` or `GL_FALSE` to
indicate support or lack thereof for filter modes other than `GL_NEAREST` or `GL_NEAREST_MIPMAP`
for the specified internal format.

If `pname` is `GL_VERTEX_TEXTURE`, `GL_TESS_CONTROL_TEXTURE`, `GL_TESS_EVALUATION_TEXTURE`,
`GL_GEOMETRY_TEXTURE`, `GL_FRAGMENT_TEXTURE`, or `GL_COMPUTE_TEXTURE`, then the value
written to `params` indicates support for use of the resource as a source of texturing in the
vertex, tessellation control, tessellation evaluation, geometry, fragment and compute shader stages,
respectively. `params` may be set to `GL_FULL_SUPPORT`, `GL_CAVEAT_SUPPORT` or `GL_NONE` to
indicate full support, limited support or no support at all, respectively.

If `pname` is `GL_TEXTURE_SHADOW`, `GL_TEXTURE_GATHER` or `GL_TEXTURE_GATHER_SHADOW` then
the value written to `params` indicates the level of support for using the resource with a shadow
sampler, in gather operations or as a shadow sampler in gather operations, respectively. Returned
values may be `GL_FULL_SUPPORT`, `GL_CAVEAT_SUPPORT` or `GL_NONE` to indicate full support,
limited support or no support at all, respectively.

If `pname` is `GL_SHADER_IMAGE_LOAD`, `GL_SHADER_IMAGE_STORE` or `GL_SHADER_IMAGE_ATOMIC`
then the value returned in `params` indicates the level of support for image loads, stores and
atomics for resources of the specified internal format. Returned values may be `GL_FULL_SUPPORT`,
`GL_CAVEAT_SUPPORT` or `GL_NONE` to indicate full support, limited support or no support at all,
respectively.

If `pname` is `GL_IMAGE_TEXEL_SIZE` then the size of a texel when the resource when used as an
image texture is returned in `params`. If the resource is not supported for image textures zero is
returned.

If `pname` is `GL_IMAGE_COMPATIBILITY_CLASS` then the compatibility class of the resource when
used as an image texture is returned in `params`. The possible values returned are
`GL_IMAGE_CLASS_4_X_32`, `GL_IMAGE_CLASS_2_X_32`, `GL_IMAGE_CLASS_1_X_32`,
`GL_IMAGE_CLASS_4_X_16`, `GL_IMAGE_CLASS_2_X_16`, `GL_IMAGE_CLASS_1_X_16`,
`GL_IMAGE_CLASS_4_X_8`, `GL_IMAGE_CLASS_2_X_8`, `GL_IMAGE_CLASS_1_X_8`,
`GL_IMAGE_CLASS_11_11_10`, and `GL_IMAGE_CLASS_10_10_10_2`, which correspond to the 4x32, 2x32,
1x32, 4x16, 2x16, 1x16, 4x8, 2x8, 1x8, the class (a) 11/11/10 packed floating-point format, and the
class (b) 10/10/10/2 packed formats, respectively. If the resource is not supported for image
textures, `GL_NONE` is returned.

If `pname` is `GL_IMAGE_PIXEL_FORMAT` or `GL_IMAGE_PIXEL_TYPE` then the pixel format or type
of the resource when used as an image texture is returned in `params`, respectively. In either
case, the resource is not supported for image textures `GL_NONE` is returned.

If `pname` is `GL_IMAGE_FORMAT_COMPATIBILITY_TYPE`, the matching criteria use for the resource
when used as an image textures is returned in `params`. Possible values returned in `params` are
`GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE` or `GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS`. If the
resource is not supported for image textures, `GL_NONE` is returned.

If `pname` is `GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST` or
`GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST`, support for using the resource both as a source for
texture sampling while it is bound as a buffer for depth or stencil test, respectively, is written
to `params`. Possible values returned are `GL_FULL_SUPPORT`, `GL_CAVEAT_SUPPORT`, or
`GL_NONE` to indicate full support, limited support or no support at all. If the resource or
operation is not supported, `GL_NONE` is returned.

If `pname` is `GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE` or
`GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE`, support for using the resource both as a source for
texture sampling while performing depth or stencil writes to the resources, respectively, is written
to `params`. Possible values returned are `GL_FULL_SUPPORT`, `GL_CAVEAT_SUPPORT`, or
`GL_NONE` to indicate full support, limited support or no support at all. If the resource or
operation is not supported, `GL_NONE` is returned.

If `pname` is `GL_TEXTURE_COMPRESSED` then `GL_TRUE` is returned in `params` if
`internalformat` is a compressed internal format. `GL_FALSE` is returned in `params` otherwise.

If `pname` is `GL_TEXTURE_COMPRESSED_BLOCK_WIDTH`, `GL_TEXTURE_COMPRESSED_BLOCK_HEIGHT` or
`GL_TEXTURE_COMPRESSED_BLOCK_SIZE` then the width, height or total size, respectively of a block
(in basic machine units) is returned in `params`. If the internal format is not compressed, or the
resource is not supported, 0 is returned.

If `pname` is `GL_CLEAR_BUFFER`, the level of support for using the resource with
glClearBufferData and glClearBufferSubData is returned in `params`. Possible values returned
are `GL_FULL_SUPPORT`, `GL_CAVEAT_SUPPORT`, or `GL_NONE` to indicate full support, limited
support or no support at all, respectively. If the resource or operation is not supported,
`GL_NONE` is returned.

If `pname` is `GL_TEXTURE_VIEW`, the level of support for using the resource with the
glTextureView command is returned in `params`. Possible values returned are `GL_FULL_SUPPORT`,
`GL_CAVEAT_SUPPORT`, or `GL_NONE` to indicate full support, limited support or no support at all,
respectively. If the resource or operation is not supported, `GL_NONE` is returned.

If `pname` is `GL_VIEW_COMPATIBILITY_CLASS` then the compatibility class of the resource when
used as a texture view is returned in `params`. The possible values returned are
`GL_VIEW_CLASS_128_BITS`, `GL_VIEW_CLASS_96_BITS`, `GL_VIEW_CLASS_64_BITS`,
`GL_VIEW_CLASS_48_BITS`, `GL_VIEW_CLASS_32_BITS`, `GL_VIEW_CLASS_24_BITS`,
`GL_VIEW_CLASS_16_BITS`, `GL_VIEW_CLASS_8_BITS`, `GL_VIEW_CLASS_S3TC_DXT1_RGB`,
`GL_VIEW_CLASS_S3TC_DXT1_RGBA`, `GL_VIEW_CLASS_S3TC_DXT3_RGBA`, `GL_VIEW_CLASS_S3TC_DXT5_RGBA`,
`GL_VIEW_CLASS_RGTC1_RED`, `GL_VIEW_CLASS_RGTC2_RG`, `GL_VIEW_CLASS_BPTC_UNORM`, and
`GL_VIEW_CLASS_BPTC_FLOAT`.

If `pname` is `GL_CLEAR_TEXTURE` then the presence of support for using the glClearTexImage
and glClearTexSubImage commands with the resource is written to `params`. Possible values
written are `GL_FULL_SUPPORT`, `GL_CAVEAT_SUPPORT`, or `GL_NONE` to indicate full support,
limited support or no support at all, respectively. If the resource or operation is not supported,
`GL_NONE` is returned.
---
### Notes
`glGetInternalformativ` is available only if the GL version is 4.2 or higher.

The tokens `GL_INTERNALFORMAT_SUPPORTED`, `GL_INTERNALFORMAT_PREFERRED`,
`GL_INTERNALFORMAT_RED_SIZE`, `GL_INTERNALFORMAT_GREEN_SIZE`, `GL_INTERNALFORMAT_BLUE_SIZE`,
`GL_INTERNALFORMAT_ALPHA_SIZE`, `GL_INTERNALFORMAT_DEPTH_SIZE`, `GL_INTERNALFORMAT_STENCIL_SIZE`,
`GL_INTERNALFORMAT_SHARED_SIZE`, `GL_INTERNALFORMAT_RED_TYPE`, `GL_INTERNALFORMAT_GREEN_TYPE`,
`GL_INTERNALFORMAT_BLUE_TYPE`, `GL_INTERNALFORMAT_ALPHA_TYPE`, `GL_INTERNALFORMAT_DEPTH_TYPE`,
`GL_INTERNALFORMAT_STENCIL_TYPE`, `GL_MAX_WIDTH`, `GL_MAX_HEIGHT`, `GL_MAX_DEPTH`,
`GL_MAX_LAYERS`, `GL_MAX_COMBINED_DIMENSIONS`, `GL_COLOR_COMPONENTS`, `GL_DEPTH_COMPONENTS`,
`GL_STENCIL_COMPONENTS`, `GL_COLOR_RENDERABLE`, `GL_DEPTH_RENDERABLE`, `GL_STENCIL_RENDERABLE`,
`GL_FRAMEBUFFER_RENDERABLE`, `GL_FRAMEBUFFER_RENDERABLE_LAYERED`, `GL_FRAMEBUFFER_BLEND`,
`GL_READ_PIXELS`, `GL_READ_PIXELS_FORMAT`, `GL_READ_PIXELS_TYPE`, `GL_TEXTURE_IMAGE_FORMAT`,
`GL_TEXTURE_IMAGE_TYPE`, `GL_GET_TEXTURE_IMAGE_FORMAT`, `GL_GET_TEXTURE_IMAGE_TYPE`,
`GL_MIPMAP`, `GL_GENERATE_MIPMAP`, `GL_AUTO_GENERATE_MIPMAP`, `GL_COLOR_ENCODING`,
`GL_SRGB_READ`, `GL_SRGB_WRITE`, `GL_SRGB_DECODE_ARB`, `GL_FILTER`, `GL_VERTEX_TEXTURE`,
`GL_TESS_CONTROL_TEXTURE`, `GL_TESS_EVALUATION_TEXTURE`, `GL_GEOMETRY_TEXTURE`,
`GL_FRAGMENT_TEXTURE`, `GL_COMPUTE_TEXTURE`, `GL_TEXTURE_SHADOW`, `GL_TEXTURE_GATHER`,
`GL_TEXTURE_GATHER_SHADOW`, `GL_SHADER_IMAGE_LOAD`, `GL_SHADER_IMAGE_STORE`,
`GL_SHADER_IMAGE_ATOMIC`, `GL_IMAGE_TEXEL_SIZE`, `GL_IMAGE_COMPATIBILITY_CLASS`,
`GL_IMAGE_PIXEL_FORMAT`, `GL_IMAGE_PIXEL_TYPE`, `GL_IMAGE_FORMAT_COMPATIBILITY_TYPE`,
`GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST`, `GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST`,
`GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE`, `GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE`,
`GL_TEXTURE_COMPRESSED`, `GL_TEXTURE_COMPRESSED_BLOCK_WIDTH`,
`GL_TEXTURE_COMPRESSED_BLOCK_HEIGHT`, `GL_TEXTURE_COMPRESSED_BLOCK_SIZE`, `GL_CLEAR_BUFFER`,
`GL_TEXTURE_VIEW`, and `GL_VIEW_COMPATIBILITY_CLASS` are supported only if the GL version is 4.3
or higher.

The `GL_CLEAR_TEXTURE` token is accepted for `pname` only if the GL version is 4.4 or higher.

---
### Errors
`GL_INVALID_VALUE` is generated if `bufSize` is negative.

`GL_INVALID_ENUM` is generated if `pname` is not `GL_SAMPLES` or `GL_NUM_SAMPLE_COUNTS`.

`GL_INVALID_ENUM` is generated if `internalformat` is not color-, depth-, or
stencil-renderable.

`GL_INVALID_ENUM` is generated if `target` is not one of `GL_TEXTURE_2D_MULTISAMPLE`,
`GL_TEXTURE_2D_MULTISAMPLE_ARRAY` or `GL_RENDERBUFFER`.
---
### Version Support
`glGetInternalformati64v` `glGetInternalformativ`
---
### See Also
glGet
---
### Copyright
Copyright 2011-2018 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Define front- and back-facing polygons
---
### Parameters
`mode` Specifies the orientation of front-facing polygons. `GL_CW` and `GL_CCW` are
accepted. The initial value is `GL_CCW`.

---
### Description
In a scene composed entirely of opaque closed surfaces, back-facing polygons are never visible.

Eliminating these invisible polygons has the obvious benefit of speeding up the rendering of the
image. To enable and disable elimination of back-facing polygons, call glEnable and `glDisable`
with argument `GL_CULL_FACE`.

The projection of a polygon to window coordinates is said to have clockwise winding if an
imaginary object following the path from its first vertex, its second vertex, and so on, to its last
vertex, and finally back to its first vertex, moves in a clockwise direction about the interior of
the polygon. The polygon's winding is said to be counterclockwise if the imaginary object following
the same path moves in a counterclockwise direction about the interior of the polygon.
`glFrontFace` specifies whether polygons with clockwise winding in window coordinates, or
counterclockwise winding in window coordinates, are taken to be front-facing. Passing `GL_CCW` to
`mode` selects counterclockwise polygons as front-facing; `GL_CW` selects clockwise polygons as
front-facing. By default, counterclockwise polygons are taken to be front-facing.
---
### Errors
`GL_INVALID_ENUM` is generated if `mode` is not an accepted value.
---
### Associated Gets
glGet with argument `GL_FRONT_FACE`
---
### Version Support
`glFrontFace`
---
### See Also
glCullFace,
---
### Copyright
Copyright 1991-2006 Silicon Graphics, Inc. Copyright 2010-2014 Khronos Group. This document
is licensed under the SGI Free Software B License. For details, see
https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.
]],
  [[Retrieve the location of a sample
---
### Parameters
`pname` Specifies the sample parameter name. `pname` must be `GL_SAMPLE_POSITION`.

`index` Specifies the index of the sample whose position to query.
`val` Specifies the address of an array to receive the position of the sample.
---
### Description
`glGetMultisamplefv` queries the location of a given sample. `pname` specifies the sample
parameter to retrieve and must be `GL_SAMPLE_POSITION`. `index` corresponds to the sample for
which the location should be returned. The sample location is returned as two floating-point values
in `val[0]` and `val[1]`, each between 0 and 1, corresponding to the `x` and `y` locations
respectively in the GL pixel space of that sample. (0.5, 0.5) this corresponds to the pixel center.
`index` must be between zero and the value of `GL_SAMPLES` minus one.

If the multisample mode does not have fixed sample locations, the returned values may only reflect
the locations of samples within some pixels.
---
### Errors
`GL_INVALID_ENUM` is generated if `pname` is not one `GL_SAMPLE_POSITION`.

`GL_INVALID_VALUE` is generated if `index` is greater than or equal to the value of
`GL_SAMPLES`.
---
### Version Support
`glGetMultisamplefv`
---
### See Also
glGenFramebuffers, glBindFramebuffer
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Generate buffer object names
---
### Parameters
`n` Specifies the number of buffer object names to be generated.
`buffers` Specifies an array in which the generated buffer object names are stored.
---
### Description
`glGenBuffers` returns `n` buffer object names in `buffers`. There is no guarantee that the
names form a contiguous set of integers; however, it is guaranteed that none of the returned names
was in use immediately before the call to `glGenBuffers`.

Buffer object names returned by a call to `glGenBuffers` are not returned by subsequent calls,
unless they are first deleted with glDeleteBuffers.

No buffer objects are associated with the returned buffer object names until they are first bound
by calling glBindBuffer.
---
### Errors
`GL_INVALID_VALUE` is generated if `n` is negative.
---
### Associated Gets
glIsBuffer
---
### Version Support
`glGenBuffers`
---
### See Also
glBindBuffer, glDeleteBuffers, glGet
---
### Copyright
Copyright 2005 Addison-Wesley. Copyright 2010-2014 Khronos Group. This material may be
distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8
June 1999. https://opencontent.org/openpub/.
]],
  [[Retrieve the label of a named object identified within a namespace
---
### Parameters
`identifier` The namespace from which the name of the object is allocated.
`name` The name of the object whose label to retrieve.
`bufSize` The length of the buffer whose address is in `label`.

`length` The address of a variable to receive the length of the object label.
`label` The address of a string that will receive the object label.
---
### Description
`glGetObjectLabel` retrieves the label of the object identified by `name` within the namespace
given by `identifier`. `identifier` must be one of `GL_BUFFER`, `GL_SHADER`, `GL_PROGRAM`,
`GL_VERTEX_ARRAY`, `GL_QUERY`, `GL_PROGRAM_PIPELINE`, `GL_TRANSFORM_FEEDBACK`, `GL_SAMPLER`,
`GL_TEXTURE`, `GL_RENDERBUFFER`, `GL_FRAMEBUFFER`, to indicate the namespace containing the
names of buffers, shaders, programs, vertex array objects, query objects, program pipelines,
transform feedback objects, samplers, textures, renderbuffers and frame buffers, respectively.

`label` is the address of a string that will be used to store the object label. `bufSize`
specifies the number of characters in the array identified by `label`. `length` contains the
address of a variable which will receive the number of characters in the object label. If `length`
is NULL, then it is ignored and no data is written. Likewise, if `label` is NULL, or if `bufSize`
is zero then no data is written to `label`.
---
### Errors
`GL_INVALID_ENUM` is generated if `identifier` is not one of the accepted object types.

`GL_INVALID_OPERATION` is generated if `name` is not the name of an existing object of the type
specified by `identifier`.

`GL_INVALID_VALUE` is generated if `bufSize` is zero.

If not NULL, `length` and `label` should be addresses to which the client has write access,
otherwise undefined behavior, including process termination may occur.
---
### Associated Gets
glGet with argument `GL_MAX_LABEL_LENGTH`.
---
### Version Support
`glGetObjectLabel`
---
### See Also
glPushDebugGroup, glPopDebugGroup, glObjectLabel, glGetObjectPtrLabel.
---
### Copyright
Copyright 2013-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Generate framebuffer object names
---
### Parameters
`n` Specifies the number of framebuffer object names to generate.
`ids` Specifies an array in which the generated framebuffer object names are stored.
---
### Description
`glGenFramebuffers` returns `n` framebuffer object names in `ids`. There is no guarantee that
the names form a contiguous set of integers; however, it is guaranteed that none of the returned
names was in use immediately before the call to `glGenFramebuffers`.

Framebuffer object names returned by a call to `glGenFramebuffers` are not returned by
subsequent calls, unless they are first deleted with glDeleteFramebuffers.

The names returned in `ids` are marked as used, for the purposes of `glGenFramebuffers` only,
but they acquire state and type only when they are first bound.
---
### Errors
`GL_INVALID_VALUE` is generated if `n` is negative.
---
### Version Support
`glGenFramebuffers`
---
### See Also
glBindFramebuffer, glDeleteFramebuffers
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Retrieve the label of a sync object identified by a pointer
---
### Parameters
`ptr` The name of the sync object whose label to retrieve.
`bufSize` The length of the buffer whose address is in `label`.

`length` The address of a variable to receive the length of the object label.
`label` The address of a string that will receive the object label.
---
### Description
`glGetObjectPtrLabel` retrieves the label of the sync object identified by `ptr`.

`label` is the address of a string that will be used to store the object label. `bufSize`
specifies the number of characters in the array identified by `label`. `length` contains the
address of a variable which will receive the number of characters in the object label. If `length`
is NULL, then it is ignored and no data is written. Likewise, if `label` is NULL, or if `bufSize`
is zero then no data is written to `label`.
---
### Errors
`GL_INVALID_ENUM` is generated if `identifier` is not one of the accepted object types.

`GL_INVALID_VALUE` is generated if `ptr` is not the name of an existing sync object.

`GL_INVALID_VALUE` is generated if `bufSize` is zero.

If not NULL, `length` and `label` should be addresses to which the client has write access,
otherwise undefined behavior, including process termination may occur.
---
### Associated Gets
glGet with argument `GL_MAX_LABEL_LENGTH`.
---
### Version Support
`glGetObjectPtrLabel`
---
### See Also
glPushDebugGroup, glPopDebugGroup, glObjectLabel, glGetObjectLabel.
---
### Copyright
Copyright 2013-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Reserve program pipeline object names
---
### Parameters
`n` Specifies the number of program pipeline object names to reserve.
`pipelines` Specifies an array of into which the reserved names will be written.
---
### Description
`glGenProgramPipelines` returns `n` previously unused program pipeline object names in
`pipelines`. These names are marked as used, for the purposes of `glGenProgramPipelines` only,
but they acquire program pipeline state only when they are first bound.
---
### Associated Gets
glGet with argument `GL_PROGRAM_PIPELINE_BINDING`

glIsProgramPipeline
---
### Version Support
`glGenProgramPipelines`
---
### See Also
glDeleteProgramPipelines, glBindProgramPipeline, glIsProgramPipeline, glUseProgramStages,
glUseProgram
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Return the address of the specified pointer
---
### Parameters
`pname` Specifies the pointer to be returned. Must be one of `GL_DEBUG_CALLBACK_FUNCTION` or
`GL_DEBUG_CALLBACK_USER_PARAM`.

`params` Returns the pointer value specified by `pname`.

---
### Description
`glGetPointerv` returns pointer information. `pname` indicates the pointer to be returned, and
`params` is a pointer to a location in which to place the returned data. The parameters that may be
queried include:

`GL_DEBUG_CALLBACK_FUNCTION` Returns the current callback function set with the `callback`
argument of glDebugMessageCallback.

`GL_DEBUG_CALLBACK_USER_PARAM` Returns the user parameter to the current callback function set
with the `userParam` argument of glDebugMessageCallback.

---
### Notes
`glGetPointerv` is available in the OpenGL core profile only if the GL version is 4.3 or later.

It is available in the compatibility profile for all GL versions, and accepts additional queries.

However, these reference pages document only the core profile.
---
### Errors
`GL_INVALID_ENUM` is generated if `pname` is not an accepted value.
---
### Version Support
`glGetPointerv`
---
### See Also
glDebugMessageCallback
---
### Copyright
Copyright 2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Generate query object names
---
### Parameters
`n` Specifies the number of query object names to be generated.
`ids` Specifies an array in which the generated query object names are stored.
---
### Description
`glGenQueries` returns `n` query object names in `ids`. There is no guarantee that the names
form a contiguous set of integers; however, it is guaranteed that none of the returned names was in
use immediately before the call to `glGenQueries`.

Query object names returned by a call to `glGenQueries` are not returned by subsequent calls,
unless they are first deleted with glDeleteQueries.

No query objects are associated with the returned query object names until they are first used by
calling glBeginQuery.
---
### Errors
`GL_INVALID_VALUE` is generated if `n` is negative.
---
### Associated Gets
glIsQuery
---
### Version Support
`glGenQueries`
---
### See Also
glBeginQuery, glDeleteQueries, `glEndQuery`
---
### Copyright
Copyright 2005 Addison-Wesley. Copyright 2010-2014 Khronos Group. This material may be
distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8
June 1999. https://opencontent.org/openpub/.
]],
  [[Returns a parameter from a program object
---
### Parameters
`program` Specifies the program object to be queried.
`pname` Specifies the object parameter. Accepted symbolic names are `GL_DELETE_STATUS`,
`GL_LINK_STATUS`, `GL_VALIDATE_STATUS`, `GL_INFO_LOG_LENGTH`, `GL_ATTACHED_SHADERS`,
`GL_ACTIVE_ATOMIC_COUNTER_BUFFERS`, `GL_ACTIVE_ATTRIBUTES`, `GL_ACTIVE_ATTRIBUTE_MAX_LENGTH`,
`GL_ACTIVE_UNIFORMS`, `GL_ACTIVE_UNIFORM_BLOCKS`, `GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH`,
`GL_ACTIVE_UNIFORM_MAX_LENGTH`, `GL_COMPUTE_WORK_GROUP_SIZE`, `GL_PROGRAM_BINARY_LENGTH`,
`GL_TRANSFORM_FEEDBACK_BUFFER_MODE`, `GL_TRANSFORM_FEEDBACK_VARYINGS`,
`GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH`, `GL_GEOMETRY_VERTICES_OUT`, `GL_GEOMETRY_INPUT_TYPE`,
and `GL_GEOMETRY_OUTPUT_TYPE`.

`params` Returns the requested object parameter.
---
### Description
`glGetProgram` returns in `params` the value of a parameter for a specific program object. The
following parameters are defined:

`GL_DELETE_STATUS` `params` returns `GL_TRUE` if `program` is currently flagged for
deletion, and `GL_FALSE` otherwise.

`GL_LINK_STATUS` `params` returns `GL_TRUE` if the last link operation on `program` was
successful, and `GL_FALSE` otherwise.

`GL_VALIDATE_STATUS` `params` returns `GL_TRUE` or if the last validation operation on
`program` was successful, and `GL_FALSE` otherwise.

`GL_INFO_LOG_LENGTH` `params` returns the number of characters in the information log for
`program` including the null termination character (i.e., the size of the character buffer required
to store the information log). If `program` has no information log, a value of 0 is returned.

`GL_ATTACHED_SHADERS` `params` returns the number of shader objects attached to `program`.

`GL_ACTIVE_ATOMIC_COUNTER_BUFFERS` `params` returns the number of active attribute atomic
counter buffers used by `program`.

`GL_ACTIVE_ATTRIBUTES` `params` returns the number of active attribute variables for
`program`.

`GL_ACTIVE_ATTRIBUTE_MAX_LENGTH` `params` returns the length of the longest active attribute
name for `program`, including the null termination character (i.e., the size of the character
buffer required to store the longest attribute name). If no active attributes exist, 0 is returned.

`GL_ACTIVE_UNIFORMS` `params` returns the number of active uniform variables for `program`.


`GL_ACTIVE_UNIFORM_MAX_LENGTH` `params` returns the length of the longest active uniform
variable name for `program`, including the null termination character (i.e., the size of the
character buffer required to store the longest uniform variable name). If no active uniform
variables exist, 0 is returned.

`GL_PROGRAM_BINARY_LENGTH` `params` returns the length of the program binary, in bytes that
will be returned by a call to glGetProgramBinary. When a progam's `GL_LINK_STATUS` is
`GL_FALSE`, its program binary length is zero.

`GL_COMPUTE_WORK_GROUP_SIZE` `params` returns an array of three integers containing the local
work group size of the compute program as specified by its input layout qualifier(s). `program`
must be the name of a program object that has been previously linked successfully and contains a
binary for the compute shader stage.

`GL_TRANSFORM_FEEDBACK_BUFFER_MODE` `params` returns a symbolic constant indicating the
buffer mode used when transform feedback is active. This may be `GL_SEPARATE_ATTRIBS` or
`GL_INTERLEAVED_ATTRIBS`.

`GL_TRANSFORM_FEEDBACK_VARYINGS` `params` returns the number of varying variables to capture
in transform feedback mode for the program.

`GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH` `params` returns the length of the longest
variable name to be used for transform feedback, including the null-terminator.

`GL_GEOMETRY_VERTICES_OUT` `params` returns the maximum number of vertices that the geometry
shader in `program` will output.

`GL_GEOMETRY_INPUT_TYPE` `params` returns a symbolic constant indicating the primitive type
accepted as input to the geometry shader contained in `program`.

`GL_GEOMETRY_OUTPUT_TYPE` `params` returns a symbolic constant indicating the primitive type
that will be output by the geometry shader contained in `program`.

---
### Notes
`GL_ACTIVE_UNIFORM_BLOCKS` and `GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH` are available only if
the GL version 3.1 or greater.

`GL_GEOMETRY_VERTICES_OUT`, `GL_GEOMETRY_INPUT_TYPE` and `GL_GEOMETRY_OUTPUT_TYPE` are
accepted only if the GL version is 3.2 or greater.

`GL_COMPUTE_WORK_GROUP_SIZE` is accepted only if the GL version is 4.3 or greater.

If an error is generated, no change is made to the contents of `params`.
---
### Errors
`GL_INVALID_VALUE` is generated if `program` is not a value generated by OpenGL.

`GL_INVALID_OPERATION` is generated if `program` does not refer to a program object.

`GL_INVALID_OPERATION` is generated if `pname` is `GL_GEOMETRY_VERTICES_OUT`,
`GL_GEOMETRY_INPUT_TYPE`, or `GL_GEOMETRY_OUTPUT_TYPE`, and `program` does not contain a
geometry shader.

`GL_INVALID_ENUM` is generated if `pname` is not an accepted value.

`GL_INVALID_OPERATION` is generated if `pname` is `GL_COMPUTE_WORK_GROUP_SIZE` and `program`
does not contain a binary for the compute shader stage.
---
### Associated Gets
glGetActiveAttrib with argument `program`

glGetActiveUniform with argument `program`

glGetAttachedShaders with argument `program`

glGetProgramInfoLog with argument `program`

glIsProgram ``
---
### Version Support
`glGetProgramiv`
---
### See Also
glAttachShader, glCreateProgram, glDeleteProgram, glGetShader, glLinkProgram,
glValidateProgram
---
### Copyright
Copyright 2003-2005 3Dlabs Inc. Ltd. Copyright 2010-2014 Khronos Group. This material may be
distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8
June 1999. https://opencontent.org/openpub/.
]],
  [[Generate renderbuffer object names
---
### Parameters
`n` Specifies the number of renderbuffer object names to generate.
`renderbuffers` Specifies an array in which the generated renderbuffer object names are stored.
---
### Description
`glGenRenderbuffers` returns `n` renderbuffer object names in `renderbuffers`. There is no
guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of
the returned names was in use immediately before the call to `glGenRenderbuffers`.

Renderbuffer object names returned by a call to `glGenRenderbuffers` are not returned by
subsequent calls, unless they are first deleted with glDeleteRenderbuffers.

The names returned in `renderbuffers` are marked as used, for the purposes of
`glGenRenderbuffers` only, but they acquire state and type only when they are first bound.
---
### Errors
`GL_INVALID_VALUE` is generated if `n` is negative.
---
### Version Support
`glGenRenderbuffers`
---
### See Also
glFramebufferRenderbuffer, glDeleteRenderbuffers
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Return a binary representation of a program object's compiled and linked executable source
---
### Parameters
`program` Specifies the name of a program object whose binary representation to retrieve.
`bufSize` Specifies the size of the buffer whose address is given by `binary`.

`length` Specifies the address of a variable to receive the number of bytes written into
`binary`.

`binaryFormat` Specifies the address of a variable to receive a token indicating the format of
the binary data returned by the GL.
`binary` Specifies the address an array into which the GL will return `program` 's binary
representation.

---
### Description
`glGetProgramBinary` returns a binary representation of the compiled and linked executable for
`program` into the array of bytes whose address is specified in `binary`. The maximum number of
bytes that may be written into `binary` is specified by `bufSize`. If the program binary is
greater in size than `bufSize` bytes, then an error is generated, otherwise the actual number of
bytes written into `binary` is returned in the variable whose address is given by `length`. If
`length` is `NULL`, then no length is returned.

The format of the program binary written into `binary` is returned in the variable whose address
is given by `binaryFormat`, and may be implementation dependent. The binary produced by the GL may
subsequently be returned to the GL by calling glProgramBinary, with `binaryFormat` and
`length` set to the values returned by `glGetProgramBinary`, and passing the returned binary data
in the `binary` parameter.
---
### Errors
`GL_INVALID_OPERATION` is generated if `bufSize` is less than the size of
`GL_PROGRAM_BINARY_LENGTH` for `program`.

`GL_INVALID_OPERATION` is generated if `GL_LINK_STATUS` for the program object is false.
---
### Associated Gets
glGetProgram with argument `GL_PROGRAM_BINARY_LENGTH`
---
### Version Support
`glGetProgramBinary`
---
### See Also
glGetProgram, glProgramBinary
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Generate sampler object names
---
### Parameters
`n` Specifies the number of sampler object names to generate.
`samplers` Specifies an array in which the generated sampler object names are stored.
---
### Description
`glGenSamplers` returns `n` sampler object names in `samplers`. There is no guarantee that
the names form a contiguous set of integers; however, it is guaranteed that none of the returned
names was in use immediately before the call to `glGenSamplers`.

Sampler object names returned by a call to `glGenSamplers` are not returned by subsequent calls,
unless they are first deleted with glDeleteSamplers.

The names returned in `samplers` are marked as used, for the purposes of `glGenSamplers` only,
but they acquire state and type only when they are first bound.
---
### Notes
`glGenSamplers` is available only if the GL version is 3.3 or higher.
---
### Errors
`GL_INVALID_VALUE` is generated if `n` is negative.
---
### Version Support
`glGenSamplers`
---
### See Also
glBindSampler, glIsSampler, glDeleteSamplers
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Returns the information log for a program object
---
### Parameters
`program` Specifies the program object whose information log is to be queried.
`maxLength` Specifies the size of the character buffer for storing the returned information log.

`length` Returns the length of the string returned in `infoLog` (excluding the null
terminator).

`infoLog` Specifies an array of characters that is used to return the information log.
---
### Description
`glGetProgramInfoLog` returns the information log for the specified program object. The
information log for a program object is modified when the program object is linked or validated. The
string that is returned will be null terminated.

`glGetProgramInfoLog` returns in `infoLog` as much of the information log as it can, up to a
maximum of `maxLength` characters. The number of characters actually returned, excluding the null
termination character, is specified by `length`. If the length of the returned string is not
required, a value of `NULL` can be passed in the `length` argument. The size of the buffer
required to store the returned information log can be obtained by calling glGetProgram with the
value `GL_INFO_LOG_LENGTH`.

The information log for a program object is either an empty string, or a string containing
information about the last link operation, or a string containing information about the last
validation operation. It may contain diagnostic messages, warning messages, and other information.

When a program object is created, its information log will be a string of length 0.
---
### Notes
The information log for a program object is the OpenGL implementer's primary mechanism for
conveying information about linking and validating. Therefore, the information log can be helpful to
application developers during the development process, even when these operations are successful.

Application developers should not expect different OpenGL implementations to produce identical
information logs.
---
### Errors
`GL_INVALID_VALUE` is generated if `program` is not a value generated by OpenGL.

`GL_INVALID_OPERATION` is generated if `program` is not a program object.

`GL_INVALID_VALUE` is generated if `maxLength` is less than 0.
---
### Associated Gets
glGetProgram with argument `GL_INFO_LOG_LENGTH`

glIsProgram
---
### Version Support
`glGetProgramInfoLog`
---
### See Also
glCompileShader, glGetShaderInfoLog, glLinkProgram, glValidateProgram
---
### Copyright
Copyright 2003-2005 3Dlabs Inc. Ltd. Copyright 2010-2014 Khronos Group. This material may be
distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8
June 1999. https://opencontent.org/openpub/.
]],
  [[Generate texture names
---
### Parameters
`n` Specifies the number of texture names to be generated.
`textures` Specifies an array in which the generated texture names are stored.
---
### Description
`glGenTextures` returns `n` texture names in `textures`. There is no guarantee that the names
form a contiguous set of integers; however, it is guaranteed that none of the returned names was in
use immediately before the call to `glGenTextures`.

The generated textures have no dimensionality; they assume the dimensionality of the texture
target to which they are first bound (see glBindTexture ).

Texture names returned by a call to `glGenTextures` are not returned by subsequent calls, unless
they are first deleted with glDeleteTextures.
---
### Errors
`GL_INVALID_VALUE` is generated if `n` is negative.
---
### Associated Gets
glIsTexture
---
### Version Support
`glGenTextures`
---
### See Also
glBindTexture, glCopyTexImage1D, glCopyTexImage2D, glDeleteTextures, glGet,
glGetTexParameter, glTexImage1D, glTexImage2D, glTexImage3D, glTexParameter
---
### Copyright
Copyright 1991-2006 Silicon Graphics, Inc. Copyright 2010-2014 Khronos Group. This document
is licensed under the SGI Free Software B License. For details, see
https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.
]],
  [[Query a property of an interface in a program
---
### Parameters
`program` The name of a program object whose interface to query.
`programInterface` A token identifying the interface within `program` to query.

`pname` The name of the parameter within `programInterface` to query.

`params` The address of a variable to retrieve the value of `pname` for the program
interface.

---
### Description
`glGetProgramInterfaceiv` queries the property of the interface identifed by `programInterface`
in `program`, the property name of which is given by `pname`.

`program` must be the name of an existing program object. `programInterface` is the name of the
interface within `program` to query and must be one of the following values:

`GL_UNIFORM` The query is targeted at the set of active uniforms within `program`.

`GL_UNIFORM_BLOCK` The query is targeted at the set of active uniform blocks within `program`.

`GL_ATOMIC_COUNTER_BUFFER` The query is targeted at the set of active atomic counter buffer
binding points within `program`.

`GL_PROGRAM_INPUT` The query is targeted at the set of active input variables used by the first
shader stage of `program`. If `program` contains multiple shader stages then input variables
from any stage other than the first will not be enumerated.

`GL_PROGRAM_OUTPUT` The query is targeted at the set of active output variables produced by the
last shader stage of `program`. If `program` contains multiple shader stages then output
variables from any stage other than the last will not be enumerated.

`GL_VERTEX_SUBROUTINE` `GL_TESS_CONTROL_SUBROUTINE` `GL_TESS_EVALUATION_SUBROUTINE`
`GL_GEOMETRY_SUBROUTINE` `GL_FRAGMENT_SUBROUTINE` `GL_COMPUTE_SUBROUTINE` The query is targeted
at the set of active subroutines for the vertex, tessellation control, tessellation evaluation,
geometry, fragment and compute shader stages of `program`, respectively.

`GL_VERTEX_SUBROUTINE_UNIFORM` `GL_TESS_CONTROL_SUBROUTINE_UNIFORM`
`GL_TESS_EVALUATION_SUBROUTINE_UNIFORM` `GL_GEOMETRY_SUBROUTINE_UNIFORM`
`GL_FRAGMENT_SUBROUTINE_UNIFORM` `GL_COMPUTE_SUBROUTINE_UNIFORM` The query is targeted at the set
of active subroutine uniform variables used by the vertex, tessellation control, tessellation
evaluation, geometry, fragment and compute shader stages of `program`, respectively.

`GL_TRANSFORM_FEEDBACK_VARYING` The query is targeted at the set of output variables from the
last non-fragment stage of `program` that would be captured if transform feedback were active.

`GL_BUFFER_VARIABLE` The query is targeted at the set of active buffer variables used by
`program`.

`GL_SHADER_STORAGE_BLOCK` The query is targeted at the set of active shader storage blocks used
by `program`.

`GL_TRANSFORM_FEEDBACK_BUFFER` The query is targeted at the set of active buffer binding points
to which output variables in the `GL_TRANSFORM_FEEDBACK_VARYING` interface are written.

`pname` identifies the property of `programInterface` to return in `params`.

If `pname` is `GL_ACTIVE_RESOURCES`, the value returned is the number of resources in the
active resource list for `programInterface`. If the list of active resources for
`programInterface` is empty, zero is returned.

If `pname` is `GL_MAX_NAME_LENGTH`, the value returned is the length of the longest active
name string for an active resource in `programInterface`. This length includes an extra character
for the null terminator. If the list of active resources for `programInterface` is empty, zero is
returned. It is an error to specify `GL_MAX_NAME_LENGTH` when `programInterface` is
`GL_ATOMIC_COUNTER_BUFFER`, as active atomic counter buffer resources are not assigned name
strings.

If `pname` is `GL_MAX_NUM_ACTIVE_VARIABLES`, the value returned is the number of active
variables belonging to the interface block or atomic counter buffer resource in `programInterface`
with the most active variables. If the list of active resources for `programInterface` is empty,
zero is returned. When `pname` is `GL_MAX_NUM_ACTIVE_VARIABLES`, `programInterface` must be
`GL_UNIFORM_BLOCK`, `GL_ATOMIC_COUNTER_BUFFER`, or `GL_SHADER_STORAGE_BLOCK`.

If `pname` is `GL_MAX_NUM_COMPATIBLE_SUBROUTINES`, the value returned is the number of
compatible subroutines belonging to the active subroutine uniform in `programInterface` with the
most compatible subroutines. If the list of active resources for `programInterface` is empty, zero
is returned. When `pname` is `GL_MAX_NUM_COMPATIBLE_SUBROUTINES`, `programInterface` must be
one of `GL_VERTEX_SUBROUTINE_UNIFORM`, `GL_TESS_CONTROL_SUBROUTINE_UNIFORM`,
`GL_TESS_EVALUATION_SUBROUTINE_UNIFORM`, `GL_GEOMETRY_SUBROUTINE_UNIFORM`,
`GL_FRAGMENT_SUBROUTINE_UNIFORM`, or `GL_COMPUTE_SUBROUTINE_UNIFORM`.
---
### Errors
`GL_INVALID_ENUM` is generated if `identifier` is not one of the accepted object types.

`GL_INVALID_VALUE` is generated if `program` is not the name of an existing sync object.

`GL_INVALID_VALUE` is generated if `bufSize` is zero.

`GL_INVALID_OPERATION` is generated if `pname` is `GL_MAX_NAME_LENGTH` and
`programInterface` is `GL_ATOMIC_COUNTER_BUFFER` or `GL_TRANSFORM_FEEDBACK_BUFFER`, since
active atomic counter and transform feedback buffer resources are not assigned name strings.

`GL_INVALID_OPERATION` error is generated if `pname` is `GL_MAX_NUM_ACTIVE_VARIABLES` and
`programInterface` is not `GL_UNIFORM_BLOCK`, `GL_SHADER_STORAGE_BLOCK`,
`GL_ATOMIC_COUNTER_BUFFER`, or `GL_TRANSFORM_FEEDBACK_BUFFER`.

If not NULL, `length` and `label` should be addresses to which the client has write access,
otherwise undefined behavior, including process termination may occur.
---
### Associated Gets
glGet with argument `GL_MAX_LABEL_LENGTH`.
---
### Version Support
`glGetProgramInterfaceiv`
---
### See Also
glPushDebugGroup, glPopDebugGroup, glObjectLabel, glGetObjectLabel.
---
### Copyright
Copyright 2013-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Reserve transform feedback object names
---
### Parameters
`n` Specifies the number of transform feedback object names to reserve.
`ids` Specifies an array of into which the reserved names will be written.
---
### Description
`glGenTransformFeedbacks` returns `n` previously unused transform feedback object names in
`ids`. These names are marked as used, for the purposes of `glGenTransformFeedbacks` only, but
they acquire transform feedback state only when they are first bound.
---
### Associated Gets
glGet with argument `GL_TRANSFORM_FEEDBACK_BINDING`

glIsTransformFeedback
---
### Version Support
`glGenTransformFeedbacks`
---
### See Also
glDeleteTransformFeedbacks, glBindTransformFeedback, glIsTransformFeedback,
glBeginTransformFeedback, glPauseTransformFeedback, glResumeTransformFeedback,
`glEndTransformFeedback`
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Retrieve properties of a program pipeline object
---
### Parameters
`pipeline` Specifies the name of a program pipeline object whose parameter retrieve.
`pname` Specifies the name of the parameter to retrieve.
`params` Specifies the address of a variable into which will be written the value or values of
`pname` for `pipeline`.

---
### Description
`glGetProgramPipelineiv` retrieves the value of a property of the program pipeline object
`pipeline`. `pname` specifies the name of the parameter whose value to retrieve. The value of the
parameter is written to the variable whose address is given by `params`.

If `pname` is `GL_ACTIVE_PROGRAM`, the name of the active program object of the program
pipeline object is returned in `params`.

If `pname` is `GL_VERTEX_SHADER`, the name of the current program object for the vertex shader
type of the program pipeline object is returned in `params`.

If `pname` is `GL_TESS_CONTROL_SHADER`, the name of the current program object for the
tessellation control shader type of the program pipeline object is returned in `params`.

If `pname` is `GL_TESS_EVALUATION_SHADER`, the name of the current program object for the
tessellation evaluation shader type of the program pipeline object is returned in `params`.

If `pname` is `GL_GEOMETRY_SHADER`, the name of the current program object for the geometry
shader type of the program pipeline object is returned in `params`.

If `pname` is `GL_FRAGMENT_SHADER`, the name of the current program object for the fragment
shader type of the program pipeline object is returned in `params`.

If `pname` is `GL_INFO_LOG_LENGTH`, the length of the info log, including the null terminator,
is returned in `params`. If there is no info log, zero is returned.
---
### Errors
`GL_INVALID_OPERATION` is generated if `pipeline` is not zero or a name previously returned
from a call to glGenProgramPipelines or if such a name has been deleted by a call to
glDeleteProgramPipelines.

`GL_INVALID_ENUM` is generated if `pname` is not one of the accepted values.
---
### Version Support
`glGetProgramPipelineiv`
---
### See Also
glGenProgramPipelines, glBindProgramPipeline, glDeleteProgramPipelines
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Generate vertex array object names
---
### Parameters
`n` Specifies the number of vertex array object names to generate.
`arrays` Specifies an array in which the generated vertex array object names are stored.
---
### Description
`glGenVertexArrays` returns `n` vertex array object names in `arrays`. There is no guarantee
that the names form a contiguous set of integers; however, it is guaranteed that none of the
returned names was in use immediately before the call to `glGenVertexArrays`.

Vertex array object names returned by a call to `glGenVertexArrays` are not returned by
subsequent calls, unless they are first deleted with glDeleteVertexArrays.

The names returned in `arrays` are marked as used, for the purposes of `glGenVertexArrays`
only, but they acquire state and type only when they are first bound.
---
### Errors
`GL_INVALID_VALUE` is generated if `n` is negative.
---
### Version Support
`glGenVertexArrays`
---
### See Also
glBindVertexArray, glDeleteVertexArrays
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Retrieve the info log string from a program pipeline object
---
### Parameters
`pipeline` Specifies the name of a program pipeline object from which to retrieve the info
log.
`bufSize` Specifies the maximum number of characters, including the null terminator, that may
be written into `infoLog`.

`length` Specifies the address of a variable into which will be written the number of
characters written into `infoLog`.

`infoLog` Specifies the address of an array of characters into which will be written the info
log for `pipeline`.

---
### Description
`glGetProgramPipelineInfoLog` retrieves the info log for the program pipeline object `pipeline`.
The info log, including its null terminator, is written into the array of characters whose address
is given by `infoLog`. The maximum number of characters that may be written into `infoLog` is
given by `bufSize`, and the actual number of characters written into `infoLog` is returned in
the integer whose address is given by `length`. If `length` is `NULL`, no length is returned.

The actual length of the info log for the program pipeline may be determined by calling
glGetProgramPipeline with `pname` set to `GL_INFO_LOG_LENGTH`.
---
### Errors
`GL_INVALID_OPERATION` is generated if `pipeline` is not a name previously returned from a call
to glGenProgramPipelines or if such a name has been deleted by a call to
glDeleteProgramPipelines.
---
### Associated Gets
glGetProgramPipeline with parameter `GL_INFO_LOG_LENGTH`.
---
### Version Support
`glGetProgramPipelineInfoLog`
---
### See Also
glGenProgramPipelines, glBindProgramPipeline, glDeleteProgramPipelines,
glGetProgramPipeline
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Generate mipmaps for a specified texture object
---
### Parameters
`target` Specifies the target to which the texture object is bound for `glGenerateMipmap`.

Must be one of `GL_TEXTURE_1D`, `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_1D_ARRAY`,
`GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_CUBE_MAP`, or `GL_TEXTURE_CUBE_MAP_ARRAY`.

`texture` Specifies the texture object name for `glGenerateTextureMipmap`.

---
### Description
`glGenerateMipmap` and `glGenerateTextureMipmap` generates mipmaps for the specified texture
object. For `glGenerateMipmap`, the texture object that is bound to `target`. For
`glGenerateTextureMipmap`, `texture` is the name of the texture object.

For cube map and cube map array textures, the texture object must be cube complete or cube array
complete respectively. Mipmap generation replaces texel image levels $level_{base} + 1$ through
$q$ with images derived from the $level_{base}$ image, regardless of their previous contents. All
other mimap images, including the $level_{base}$ image, are left unchanged by this computation.

The internal formats of the derived mipmap images all match those of the $level_{base}$ image. The
contents of the derived images are computed by repeated, filtered reduction of the $level_{base}$
image. For one- and two-dimensional array and cube map array textures, each layer is filtered
independently.
---
### Notes
Cube map array textures are accepted only if the GL version is 4.0 or higher.
---
### Errors
`GL_INVALID_ENUM` is generated by `glGenerateMipmap` if `target` is not one of the accepted
texture targets.

`GL_INVALID_OPERATION` is generated by `glGenerateTextureMipmap` if `texture` is not the name
of an existing texture object.

`GL_INVALID_OPERATION` is generated if `target` is `GL_TEXTURE_CUBE_MAP` or
`GL_TEXTURE_CUBE_MAP_ARRAY`, and the specified texture object is not cube complete or cube array
complete, respectively.
---
### Version Support
`glGenerateMipmap` `glGenerateTextureMipmap`
---
### See Also
glTexImage2D, glBindTexture, glGenTextures
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Retrieve values for multiple properties of a single active resource within a program object
---
### Parameters
`program` The name of a program object whose resources to query.
`programInterface` A token identifying the interface within `program` containing the resource
named `name`.

---
### Description
`glGetProgramResourceiv` returns values for multiple properties of a single active resource with
an index of `index` in the interface `programInterface` of program object `program`. For each
resource, values for `propCount` properties specified by the array `props` are returned.
`propCount` may not be zero. An error is generated if any value in `props` is not one of the
properties described immediately belowor if any value in `props` is not allowed for
`programInterface`. The set of allowed `programInterface` values for each property can be found
in the following table:

Property Supported Interfaces `GL_NAME_LENGTH` Any except `GL_ATOMIC_COUNTER_BUFFER` and
`GL_TRANSFORM_FEEDBACK_BUFFER` `GL_TYPE` `GL_UNIFORM`, `GL_PROGRAM_INPUT`,
`GL_PROGRAM_OUTPUT`, `GL_TRANSFORM_FEEDBACK_VARYING`, `GL_BUFFER_VARIABLE` `GL_ARRAY_SIZE`
`GL_UNIFORM`, `GL_BUFFER_VARIABLE`, `GL_PROGRAM_INPUT`, `GL_PROGRAM_OUTPUT,
VERTEX_SUBROUTINE_UNIFORM`, `GL_TESS_CONTROL_SUBROUTINE_UNIFORM`,
`GL_TESS_EVALUATION_SUBROUTINE_UNIFORM`, `GL_GEOMETRY_SUBROUTINE_UNIFORM`,
`GL_FRAGMENT_SUBROUTINE_UNIFORM`, `GL_COMPUTE_SUBROUTINE_UNIFORM`,
`GL_TRANSFORM_FEEDBACK_VARYING` `GL_OFFSET` `GL_UNIFORM`, `GL_BUFFER_VARIABLE`,
`GL_TRANSFORM_FEEDBACK_VARYING` `GL_BLOCK_INDEX` `GL_UNIFORM`, `GL_BUFFER_VARIABLE`
`GL_ARRAY_STRIDE` `GL_UNIFORM`, `GL_BUFFER_VARIABLE` `GL_MATRIX_STRIDE` `GL_UNIFORM`,
`GL_BUFFER_VARIABLE` `GL_IS_ROW_MAJOR` `GL_UNIFORM`, `GL_BUFFER_VARIABLE`
`GL_ATOMIC_COUNTER_BUFFER_INDEX` `GL_UNIFORM` `GL_TEXTURE_BUFFER` none `GL_BUFFER_BINDING`
`GL_UNIFORM_BLOCK`, `GL_ATOMIC_COUNTER_BUFFER`, `GL_SHADER_STORAGE_BLOCK`,
`GL_TRANSFORM_FEEDBACK_BUFFER` `GL_BUFFER_DATA_SIZE` `GL_UNIFORM_BLOCK`,
`GL_ATOMIC_COUNTER_BUFFER`, `GL_SHADER_STORAGE_BLOCK` `GL_NUM_ACTIVE_VARIABLES`
`GL_UNIFORM_BLOCK`, `GL_ATOMIC_COUNTER_BUFFER`, `GL_SHADER_STORAGE_BLOCK`,
`GL_TRANSFORM_FEEDBACK_BUFFER` `GL_ACTIVE_VARIABLES` `GL_UNIFORM_BLOCK`,
`GL_ATOMIC_COUNTER_BUFFER`, `GL_SHADER_STORAGE_BLOCK`, `GL_TRANSFORM_FEEDBACK_BUFFER`
`GL_REFERENCED_BY_VERTEX_SHADER` `GL_UNIFORM`, `GL_UNIFORM_BLOCK`, `GL_ATOMIC_COUNTER_SHADER`,
`GL_BUFFER`, `GL_SHADER_STORAGE_BLOCK`, `GL_BUFFER_VARIABLE`, `GL_PROGRAM_INPUT`,
`GL_PROGRAM_OUTPUT` `GL_REFERENCED_BY_TESS_CONTROL_SHADER` `GL_UNIFORM`, `GL_UNIFORM_BLOCK`,
`GL_ATOMIC_COUNTER_SHADER`, `GL_BUFFER`, `GL_SHADER_STORAGE_BLOCK`, `GL_BUFFER_VARIABLE`,
`GL_PROGRAM_INPUT`, `GL_PROGRAM_OUTPUT` `GL_REFERENCED_BY_TESS_EVALUATION_SHADER` `GL_UNIFORM`,
`GL_UNIFORM_BLOCK`, `GL_ATOMIC_COUNTER_SHADER`, `GL_BUFFER`, `GL_SHADER_STORAGE_BLOCK`,
`GL_BUFFER_VARIABLE`, `GL_PROGRAM_INPUT`, `GL_PROGRAM_OUTPUT`
`GL_REFERENCED_BY_GEOMETRY_SHADER` `GL_UNIFORM`, `GL_UNIFORM_BLOCK`, `GL_ATOMIC_COUNTER_SHADER`,
`GL_BUFFER`, `GL_SHADER_STORAGE_BLOCK`, `GL_BUFFER_VARIABLE`, `GL_PROGRAM_INPUT`,
`GL_PROGRAM_OUTPUT` `GL_REFERENCED_BY_FRAGMENT_SHADER` `GL_UNIFORM`, `GL_UNIFORM_BLOCK`,
`GL_ATOMIC_COUNTER_SHADER`, `GL_BUFFER`, `GL_SHADER_STORAGE_BLOCK`, `GL_BUFFER_VARIABLE`,
`GL_PROGRAM_INPUT`, `GL_PROGRAM_OUTPUT` `GL_REFERENCED_BY_COMPUTE_SHADER` `GL_UNIFORM`,
`GL_UNIFORM_BLOCK`, `GL_ATOMIC_COUNTER_SHADER`, `GL_BUFFER`, `GL_SHADER_STORAGE_BLOCK`,
`GL_BUFFER_VARIABLE`, `GL_PROGRAM_INPUT`, `GL_PROGRAM_OUTPUT` `GL_NUM_COMPATIBLE_SUBROUTINES`
`GL_VERTEX_SUBROUTINE_UNIFORM`, `GL_TESS_CONTROL_SUBROUTINE_UNIFORM`,
`GL_TESS_EVALUATION_SUBROUTINE_UNIFORM`, `GL_GEOMETRY_SUBROUTINE_UNIFORM`,
`GL_FRAGMENT_SUBROUTINE_UNIFORM`, `GL_COMPUTE_SUBROUTINE_UNIFORM` `GL_COMPATIBLE_SUBROUTINES`
`GL_VERTEX_SUBROUTINE_UNIFORM`, `GL_TESS_CONTROL_SUBROUTINE_UNIFORM`,
`GL_TESS_EVALUATION_SUBROUTINE_UNIFORM`, `GL_GEOMETRY_SUBROUTINE_UNIFORM`,
`GL_FRAGMENT_SUBROUTINE_UNIFORM`, `GL_COMPUTE_SUBROUTINE_UNIFORM` `GL_TOP_LEVEL_ARRAY_SIZE`
`GL_BUFFER_VARIABLE` `GL_TOP_LEVEL_ARRAY_STRIDE` `GL_BUFFER_VARIABLE` `GL_LOCATION`
`GL_UNIFORM`, `GL_PROGRAM_INPUT`, `GL_PROGRAM_OUTPUT`, `GL_VERTEX_SUBROUTINE_UNIFORM`,
`GL_TESS_CONTROL_SUBROUTINE_UNIFORM`, `GL_TESS_EVALUATION_SUBROUTINE_UNIFORM`,
`GL_GEOMETRY_SUBROUTINE_UNIFORM`, `GL_FRAGMENT_SUBROUTINE_UNIFORM`,
`GL_COMPUTE_SUBROUTINE_UNIFORM` `GL_LOCATION_INDEX` `GL_PROGRAM_OUTPUT` `GL_IS_PER_PATCH`
`GL_PROGRAM_INPUT`, `GL_PROGRAM_OUTPUT` `GL_LOCATION_COMPONENT` `GL_PROGRAM_INPUT`,
`GL_PROGRAM_OUTPUT` `GL_TRANSFORM_FEEDBACK_BUFFER_INDEX` `GL_TRANSFORM_FEEDBACK_VARYING`
`GL_TRANSFORM_FEEDBACK_BUFFER_STRIDE` `GL_TRANSFORM_FEEDBACK_BUFFER` For the property
`GL_NAME_LENGTH`, a single integer identifying the length of the name string associated with an
active variable, interface block, or subroutine is written to `params`. The name length includes a
terminating null character.

For the property `GL_TYPE`, a single integer identifying the type of an active variable is
written to `params`. The integer returned is one of the values found in table 2.16.

For the property `GL_ARRAY_SIZE`, a single integer identifying the number of active array
elements of an active variable is written to `params`. The array size returned is in units of the
type associated with the property `GL_TYPE`. For active variables not corresponding to an array of
basic types, the value zero is written to `params`.

For the property `GL_BLOCK_INDEX`, a single integer identifying the index of the active
interface block containing an active variable is written to `params`. If the variable is not the
member of an interface block, the value -1 is written to `params`.

For the property `GL_OFFSET`, a single integer identifying the offset of an active variable is
written to `params`. For variables in the `GL_UNIFORM` and `GL_BUFFER_VARIABLE` interfaces
that are backed by a buffer object, the value written is the offset of that variable relative to the
base of the buffer range holding its value. For variables in the `GL_TRANSFORM_FEEDBACK_VARYING`
interface, the value written is the offset in the transform feedback buffer storage assigned to each
vertex captured in transform feedback mode where the value of the variable will be stored. Such
offsets are specified via the xfb_offset layout qualifier or assigned according to the variables
position in the list of strings passed to glTransformFeedbackVaryings. Offsets are expressed in
basic machine units. For all variables not recorded in transform feedback mode, including the
special names "gl_NextBuffer", "gl_SkipComponents1", "gl_SkipComponents2",
"gl_SkipComponents3", and "gl_SkipComponents4", -1 is written to `params`.

For the property `GL_ARRAY_STRIDE`, a single integer identifying the stride between array
elements in an active variable is written to `params`. For active variables declared as an array
of basic types, the value written is the difference, in basic machine units, between the offsets of
consecutive elements in an array. For active variables not declared as an array of basic types, zero
is written to `params`. For active variables not backed by a buffer object, -1 is written to
`params`, regardless of the variable type.

For the property `GL_MATRIX_STRIDE`, a single integer identifying the stride between columns of
a column-major matrix or rows of a row-major matrix is written to `params`. For active variables
declared a single matrix or array of matrices, the value written is the difference, in basic machine
units, between the offsets of consecutive columns or rows in each matrix. For active variables not
declared as a matrix or array of matrices, zero is written to `params`. For active variables not
backed by a buffer object, -1 is written to `params`, regardless of the variable type.

For the property `GL_IS_ROW_MAJOR`, a single integer identifying whether an active variable is a
row-major matrix is written to `params`. For active variables backed by a buffer object, declared
as a single matrix or array of matrices, and stored in row-major order, one is written to `params`.
For all other active variables, zero is written to `params`.

For the property `GL_ATOMIC_COUNTER_BUFFER_INDEX`, a single integer identifying the index of the
active atomic counter buffer containing an active variable is written to `params`. If the variable
is not an atomic counter uniform, the value -1 is written to `params`.

For the property `GL_BUFFER_BINDING`, to index of the buffer binding point associated with the
active uniform block, shader storage block, atomic counter buffer or transform feedback buffer is
written to `params`.

For the property `GL_BUFFER_DATA_SIZE`, then the implementation-dependent minimum total buffer
object size, in basic machine units, required to hold all active variables associated with an active
uniform block, shader storage block, or atomic counter buffer is written to `params`. If the final
member of an active shader storage block is array with no declared size, the minimum buffer size is
computed assuming the array was declared as an array with one element.

For the property `GL_NUM_ACTIVE_VARIABLES`, the number of active variables associated with an
active uniform block, shader storage block, atomic counter buffer or transform feedback buffer is
written to `params`.

For the property `GL_ACTIVE_VARIABLES`, an array of active variable indices associated with an
active uniform block, shader storage block, atomic counter buffer or transform feedback buffer is
written to `params`. The number of values written to `params` for an active resource is given by
the value of the property `GL_NUM_ACTIVE_VARIABLES` for the resource.

For the properties `GL_REFERENCED_BY_VERTEX_SHADER`, `GL_REFERENCED_BY_TESS_CONTROL_SHADER`,
`GL_REFERENCED_BY_TESS_EVALUATION_SHADER`, `GL_REFERENCED_BY_GEOMETRY_SHADER`,
`GL_REFERENCED_BY_FRAGMENT_SHADER`, and `GL_REFERENCED_BY_COMPUTE_SHADER`, a single integer is
written to `params`, identifying whether the active resource is referenced by the vertex,
tessellation control, tessellation evaluation, geometry, or fragment shaders, respectively, in the
program object. The value one is written to `params` if an active variable is referenced by the
corresponding shader, or if an active uniform block, shader storage block, or atomic counter buffer
contains at least one variable referenced by the corresponding shader. Otherwise, the value zero is
written to `params`.

For the property `GL_TOP_LEVEL_ARRAY_SIZE`, a single integer identifying the number of active
array elements of the top-level shader storage block member containing to the active variable is
written to `params`. If the top-level block member is not declared as an array, the value one is
written to `params`. If the top-level block member is an array with no declared size, the value
zero is written to `params`.

For the property `GL_TOP_LEVEL_ARRAY_STRIDE`, a single integer identifying the stride between
array elements of the top-level shader storage block member containing the active variable is
written to `params`. For top-level block members declared as arrays, the value written is the
difference, in basic machine units, between the offsets of the active variable for consecutive
elements in the top-level array. For top-level block members not declared as an array, zero is
written to `params`.

For the property `GL_LOCATION`, a single integer identifying the assigned location for an active
uniform, input, output, or subroutine uniform variable is written to `params`. For input, output,
or uniform variables with locations specified by a layout qualifier, the specified location is used.

For vertex shader input or fragment shader output variables without a layout qualifier, the location
assigned when a program is linked is written to `params`. For all other input and output
variables, the value -1 is written to `params`. For uniforms in uniform blocks, the value -1 is
written to `params`.

For the property `GL_LOCATION_INDEX`, a single integer identifying the fragment color index of
an active fragment shader output variable is written to `params`. If the active variable is an
output for a non-fragment shader, the value -1 will be written to `params`.

For the property `GL_IS_PER_PATCH`, a single integer identifying whether the input or output is
a per-patch attribute. If the active variable is a per-patch attribute (declared with the patch
qualifier), the value one is written to `params` ; otherwise, the value zero is written to
`params`.

For the property `GL_LOCATION_COMPONENT`, a single integer indicating the first component of the
location assigned to an active input or output variable is written to `params`. For input and
output variables with a component specified by a layout qualifier, the specified component is
written. For all other input and output variables, the value zero is written.

For the property `GL_TRANSFORM_FEEDBACK_BUFFER_INDEX`, a single integer identifying the index of
the active transform feedback buffer associated with an active variable is written to `params`.

For variables corresponding to the special names "gl_NextBuffer", "gl_SkipComponents1",
"gl_SkipComponents2", "gl_SkipComponents3", and "gl_SkipComponents4", -1 is written to
`params`.

For the property `GL_TRANSFORM_FEEDBACK_BUFFER_STRIDE`, a single integer identifying the stride,
in basic machine units, between consecutive vertices written to the transform feedback buffer is
written to `params`.
---
### Errors
`GL_INVALID_VALUE` is generated if `program` is not the name of an existing program object.

`GL_INVALID_VALUE` is generated if `propCount` is zero.

`GL_INVALID_ENUM` is generated if `programInterface` is not one of the accepted interface
types.

`GL_INVLALID_ENUM` is generated if any value in `props` is not one of the accepted tokens for
the interface `programInterface`
---
### Version Support
`glGetProgramResourceiv`
---
### See Also
glGetProgramResourceName, glGetProgramResourceIndex, glGetProgramResourceLocation,
glGetProgramResourceLocationIndex.
---
### Copyright
Copyright 2013-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Query the index of a named resource within a program
---
### Parameters
`program` The name of a program object whose resources to query.
`programInterface` A token identifying the interface within `program` containing the resource
named `name`.

`name` The name of the resource to query the index of.
---
### Description
`glGetProgramResourceIndex` returns the unsigned integer index assigned to a resource named
`name` in the interface type `programInterface` of program object `program`.

`program` must be the name of an existing program object. `programInterface` is the name of the
interface within `program` which contains the resource named `name` and must be one of the
following values:

`GL_UNIFORM` The query is targeted at the set of active uniforms within `program`.

`GL_UNIFORM_BLOCK` The query is targeted at the set of active uniform blocks within `program`.

`GL_PROGRAM_INPUT` The query is targeted at the set of active input variables used by the first
shader stage of `program`. If `program` contains multiple shader stages then input variables
from any stage other than the first will not be enumerated.

`GL_PROGRAM_OUTPUT` The query is targeted at the set of active output variables produced by the
last shader stage of `program`. If `program` contains multiple shader stages then output
variables from any stage other than the last will not be enumerated.

`GL_VERTEX_SUBROUTINE` `GL_TESS_CONTROL_SUBROUTINE` `GL_TESS_EVALUATION_SUBROUTINE`
`GL_GEOMETRY_SUBROUTINE` `GL_FRAGMENT_SUBROUTINE` `GL_COMPUTE_SUBROUTINE` The query is targeted
at the set of active subroutines for the vertex, tessellation control, tessellation evaluation,
geometry, fragment and compute shader stages of `program`, respectively.

`GL_VERTEX_SUBROUTINE_UNIFORM` `GL_TESS_CONTROL_SUBROUTINE_UNIFORM`
`GL_TESS_EVALUATION_SUBROUTINE_UNIFORM` `GL_GEOMETRY_SUBROUTINE_UNIFORM`
`GL_FRAGMENT_SUBROUTINE_UNIFORM` `GL_COMPUTE_SUBROUTINE_UNIFORM` The query is targeted at the set
of active subroutine uniform variables used by the vertex, tessellation control, tessellation
evaluation, geometry, fragment and compute shader stages of `program`, respectively.

`GL_TRANSFORM_FEEDBACK_VARYING` The query is targeted at the set of output variables from the
last non-fragment stage of `program` that would be captured if transform feedback were active.

`GL_TRANSFORM_FEEDBACK_BUFFER` The query is targeted at the set of active buffer binding points
to which output variables in the `GL_TRANSFORM_FEEDBACK_VARYING` interface are written.

`GL_BUFFER_VARIABLE` The query is targeted at the set of active buffer variables used by
`program`.

`GL_SHADER_STORAGE_BLOCK` The query is targeted at the set of active shader storage blocks used
by `program`.

If `name` exactly matches the name string of one of the active resources for `programInterface`,
the index of the matched resource is returned. Additionally, if `name` would exactly match the
name string of an active resource if "[0]" were appended to `name`, the index of the matched
resource is returned. Otherwise, `name` is considered not to be the name of an active resource,
and `GL_INVALID_INDEX` is returned.

For the interface `GL_TRANSFORM_FEEDBACK_VARYING`, the value `GL_INVALID_INDEX` should be
returned when querying the index assigned to the special names gl_NextBuffer, gl_SkipComponents1,
gl_SkipComponents2, gl_SkipComponents3, or gl_SkipComponents4.
---
### Errors
`GL_INVALID_ENUM` is generated if `programInterface` is not one of the accepted interface
types.

`GL_INVALID_ENUM` is generated if `programInterface` is `GL_ATOMIC_COUNTER_BUFFER` or
`GL_TRANSFORM_FEEDBACK_BUFFER`, since active atomic counter and transform feedback buffer resources
are not assigned name strings.

Although not an error, `GL_INVALID_INDEX` is returned if `name` is not the name of a resource
within the interface identified by `programInterface`.
---
### Version Support
`glGetProgramResourceIndex`
---
### See Also
glGetProgramResourceName, glGetProgramResource, glGetProgramResourceLocation,
glGetProgramResourceLocationIndex.
---
### Copyright
Copyright 2013-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Return the value or values of a selected parameter
---
### Parameters
`pname` Specifies the parameter value to be returned for non-indexed versions of `glGet`.

The symbolic constants in the list below are accepted.

`target` Specifies the parameter value to be returned for indexed versions of `glGet`. The
symbolic constants in the list below are accepted.

`index` Specifies the index of the particular element being queried.
`data` Returns the value or values of the specified parameter.
---
### Description
These commands return values for simple state variables in GL. `pname` is a symbolic constant
indicating the state variable to be returned, and `data` is a pointer to an array of the indicated
type in which to place the returned data.

Type conversion is performed if `data` has a different type than the state variable value being
requested. If `glGetBooleanv` is called, a floating-point (or integer) value is converted to
`GL_FALSE` if and only if it is 0.0 (or 0). Otherwise, it is converted to `GL_TRUE`. If
`glGetIntegerv` is called, boolean values are returned as `GL_TRUE` or `GL_FALSE`, and most
floating-point values are rounded to the nearest integer value. Floating-point colors and normals,
however, are returned with a linear mapping that maps 1.0 to the most positive representable integer
value and -1.0 to the most negative representable integer value. If `glGetFloatv` or
`glGetDoublev` is called, boolean values are returned as `GL_TRUE` or `GL_FALSE`, and integer
values are converted to floating-point values.

The following symbolic constants are accepted by `pname` :

`GL_ACTIVE_TEXTURE` `data` returns a single value indicating the active multitexture unit.

The initial value is `GL_TEXTURE0`. See glActiveTexture.

`GL_ALIASED_LINE_WIDTH_RANGE` `data` returns a pair of values indicating the range of widths
supported for aliased lines. See glLineWidth.

`GL_ARRAY_BUFFER_BINDING` `data` returns a single value, the name of the buffer object
currently bound to the target `GL_ARRAY_BUFFER`. If no buffer object is bound to this target, 0 is
returned. The initial value is 0. See glBindBuffer.

`GL_BLEND` `data` returns a single boolean value indicating whether blending is enabled. The
initial value is `GL_FALSE`. See glBlendFunc.

`GL_BLEND_COLOR` `data` returns four values, the red, green, blue, and alpha values which are
the components of the blend color. See glBlendColor.

`GL_BLEND_DST_ALPHA` `data` returns one value, the symbolic constant identifying the alpha
destination blend function. The initial value is `GL_ZERO`. See glBlendFunc and
glBlendFuncSeparate.

`GL_BLEND_DST_RGB` `data` returns one value, the symbolic constant identifying the RGB
destination blend function. The initial value is `GL_ZERO`. See glBlendFunc and
glBlendFuncSeparate.

`GL_BLEND_EQUATION_RGB` `data` returns one value, a symbolic constant indicating whether the
RGB blend equation is `GL_FUNC_ADD`, `GL_FUNC_SUBTRACT`, `GL_FUNC_REVERSE_SUBTRACT`, `GL_MIN`
or `GL_MAX`. See glBlendEquationSeparate.

`GL_BLEND_EQUATION_ALPHA` `data` returns one value, a symbolic constant indicating whether the
Alpha blend equation is `GL_FUNC_ADD`, `GL_FUNC_SUBTRACT`, `GL_FUNC_REVERSE_SUBTRACT`,
`GL_MIN` or `GL_MAX`. See glBlendEquationSeparate.

`GL_BLEND_SRC_ALPHA` `data` returns one value, the symbolic constant identifying the alpha
source blend function. The initial value is `GL_ONE`. See glBlendFunc and glBlendFuncSeparate.

`GL_BLEND_SRC_RGB` `data` returns one value, the symbolic constant identifying the RGB source
blend function. The initial value is `GL_ONE`. See glBlendFunc and glBlendFuncSeparate.

`GL_COLOR_CLEAR_VALUE` `data` returns four values: the red, green, blue, and alpha values used
to clear the color buffers. Integer values, if requested, are linearly mapped from the internal
floating-point representation such that 1.0 returns the most positive representable integer value,
and -1.0 returns the most negative representable integer value. The initial value is (0, 0, 0,
0). See glClearColor.

`GL_COLOR_LOGIC_OP` `data` returns a single boolean value indicating whether a fragment's RGBA
color values are merged into the framebuffer using a logical operation. The initial value is
`GL_FALSE`. See glLogicOp.

`GL_COLOR_WRITEMASK` `data` returns four boolean values: the red, green, blue, and alpha write
enables for the color buffers. The initial value is ( `GL_TRUE`, `GL_TRUE`, `GL_TRUE`,
`GL_TRUE` ). See glColorMask.

`GL_COMPRESSED_TEXTURE_FORMATS` `data` returns a list of symbolic constants of length
`GL_NUM_COMPRESSED_TEXTURE_FORMATS` indicating which compressed texture formats are available. See
glCompressedTexImage2D.

`GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS` `data` returns one value, the maximum number of active
shader storage blocks that may be accessed by a compute shader.

`GL_MAX_COMBINED_SHADER_STORAGE_BLOCKS` `data` returns one value, the maximum total number of
active shader storage blocks that may be accessed by all active shaders.

`GL_MAX_COMPUTE_UNIFORM_BLOCKS` `data` returns one value, the maximum number of uniform blocks
per compute shader. The value must be at least 14. See glUniformBlockBinding.

`GL_MAX_COMPUTE_TEXTURE_IMAGE_UNITS` `data` returns one value, the maximum supported texture
image units that can be used to access texture maps from the compute shader. The value must be at
least 16. See glActiveTexture.

`GL_MAX_COMPUTE_UNIFORM_COMPONENTS` `data` returns one value, the maximum number of individual
floating-point, integer, or boolean values that can be held in uniform variable storage for a
compute shader. The value must be at least 1024. See glUniform.

`GL_MAX_COMPUTE_ATOMIC_COUNTERS` `data` returns a single value, the maximum number of atomic
counters available to compute shaders.

`GL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS` `data` returns a single value, the maximum number of
atomic counter buffers that may be accessed by a compute shader.

`GL_MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS` `data` returns one value, the number of words for
compute shader uniform variables in all uniform blocks (including default). The value must be at
least 1. See glUniform.

`GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS` `data` returns one value, the number of invocations in
a single local work group (i.e., the product of the three dimensions) that may be dispatched to a
compute shader.

`GL_MAX_COMPUTE_WORK_GROUP_COUNT` Accepted by the indexed versions of `glGet`. `data` the
maximum number of work groups that may be dispatched to a compute shader. Indices 0, 1, and 2
correspond to the X, Y and Z dimensions, respectively.

`GL_MAX_COMPUTE_WORK_GROUP_SIZE` Accepted by the indexed versions of `glGet`. `data` the
maximum size of a work groups that may be used during compilation of a compute shader. Indices 0, 1,
and 2 correspond to the X, Y and Z dimensions, respectively.

`GL_DISPATCH_INDIRECT_BUFFER_BINDING` `data` returns a single value, the name of the buffer
object currently bound to the target `GL_DISPATCH_INDIRECT_BUFFER`. If no buffer object is bound
to this target, 0 is returned. The initial value is 0. See glBindBuffer.

`GL_MAX_DEBUG_GROUP_STACK_DEPTH` `data` returns a single value, the maximum depth of the debug
message group stack.

`GL_DEBUG_GROUP_STACK_DEPTH` `data` returns a single value, the current depth of the debug
message group stack.

`GL_CONTEXT_FLAGS` `data` returns one value, the flags with which the context was created
(such as debugging functionality).

`GL_CULL_FACE` `data` returns a single boolean value indicating whether polygon culling is
enabled. The initial value is `GL_FALSE`. See glCullFace.

`GL_CULL_FACE_MODE` `data` returns a single value indicating the mode of polygon culling. The
initial value is `GL_BACK`. See glCullFace.

`GL_CURRENT_PROGRAM` `data` returns one value, the name of the program object that is
currently active, or 0 if no program object is active. See glUseProgram.

`GL_DEPTH_CLEAR_VALUE` `data` returns one value, the value that is used to clear the depth
buffer. Integer values, if requested, are linearly mapped from the internal floating-point
representation such that 1.0 returns the most positive representable integer value, and -1.0
returns the most negative representable integer value. The initial value is 1. See glClearDepth.


`GL_DEPTH_FUNC` `data` returns one value, the symbolic constant that indicates the depth
comparison function. The initial value is `GL_LESS`. See glDepthFunc.

`GL_DEPTH_RANGE` `data` returns two values: the near and far mapping limits for the depth
buffer. Integer values, if requested, are linearly mapped from the internal floating-point
representation such that 1.0 returns the most positive representable integer value, and -1.0
returns the most negative representable integer value. The initial value is (0, 1). See
glDepthRange.

`GL_DEPTH_TEST` `data` returns a single boolean value indicating whether depth testing of
fragments is enabled. The initial value is `GL_FALSE`. See glDepthFunc and glDepthRange.

`GL_DEPTH_WRITEMASK` `data` returns a single boolean value indicating if the depth buffer is
enabled for writing. The initial value is `GL_TRUE`. See glDepthMask.

`GL_DITHER` `data` returns a single boolean value indicating whether dithering of fragment
colors and indices is enabled. The initial value is `GL_TRUE`.

`GL_DOUBLEBUFFER` `data` returns a single boolean value indicating whether double buffering is
supported.

`GL_DRAW_BUFFER` `data` returns one value, a symbolic constant indicating which buffers are
being drawn to. See glDrawBuffer. The initial value is `GL_BACK` if there are back buffers,
otherwise it is `GL_FRONT`.

`GL_DRAW_BUFFER` i `data` returns one value, a symbolic constant indicating which buffers are
being drawn to by the corresponding output color. See glDrawBuffers. The initial value of
`GL_DRAW_BUFFER0` is `GL_BACK` if there are back buffers, otherwise it is `GL_FRONT`. The
initial values of draw buffers for all other output colors is `GL_NONE`.

`GL_DRAW_FRAMEBUFFER_BINDING` `data` returns one value, the name of the framebuffer object
currently bound to the `GL_DRAW_FRAMEBUFFER` target. If the default framebuffer is bound, this
value will be zero. The initial value is zero. See glBindFramebuffer.

`GL_READ_FRAMEBUFFER_BINDING` `data` returns one value, the name of the framebuffer object
currently bound to the `GL_READ_FRAMEBUFFER` target. If the default framebuffer is bound, this
value will be zero. The initial value is zero. See glBindFramebuffer.

`GL_ELEMENT_ARRAY_BUFFER_BINDING` `data` returns a single value, the name of the buffer object
currently bound to the target `GL_ELEMENT_ARRAY_BUFFER`. If no buffer object is bound to this
target, 0 is returned. The initial value is 0. See glBindBuffer.

`GL_FRAGMENT_SHADER_DERIVATIVE_HINT` `data` returns one value, a symbolic constant indicating
the mode of the derivative accuracy hint for fragment shaders. The initial value is `GL_DONT_CARE`. See glHint.

`GL_IMPLEMENTATION_COLOR_READ_FORMAT` `data` returns a single GLenum value indicating the
implementation's preferred pixel data format. See glReadPixels.

`GL_IMPLEMENTATION_COLOR_READ_TYPE` `data` returns a single GLenum value indicating the
implementation's preferred pixel data type. See glReadPixels.

`GL_LINE_SMOOTH` `data` returns a single boolean value indicating whether antialiasing of
lines is enabled. The initial value is `GL_FALSE`. See glLineWidth.

`GL_LINE_SMOOTH_HINT` `data` returns one value, a symbolic constant indicating the mode of the
line antialiasing hint. The initial value is `GL_DONT_CARE`. See glHint.

`GL_LINE_WIDTH` `data` returns one value, the line width as specified with glLineWidth. The
initial value is 1.

`GL_LAYER_PROVOKING_VERTEX` `data` returns one value, the implementation dependent specifc
vertex of a primitive that is used to select the rendering layer. If the value returned is
equivalent to `GL_PROVOKING_VERTEX`, then the vertex selection follows the convention specified by
glProvokingVertex. If the value returned is equivalent to `GL_FIRST_VERTEX_CONVENTION`, then
the selection is always taken from the first vertex in the primitive. If the value returned is
equivalent to `GL_LAST_VERTEX_CONVENTION`, then the selection is always taken from the last vertex
in the primitive. If the value returned is equivalent to `GL_UNDEFINED_VERTEX`, then the selection
is not guaranteed to be taken from any specific vertex in the primitive.

`GL_LOGIC_OP_MODE` `data` returns one value, a symbolic constant indicating the selected logic
operation mode. The initial value is `GL_COPY`. See glLogicOp.

`GL_MAJOR_VERSION` `data` returns one value, the major version number of the OpenGL API
supported by the current context.

`GL_MAX_3D_TEXTURE_SIZE` `data` returns one value, a rough estimate of the largest 3D texture
that the GL can handle. The value must be at least 64. Use `GL_PROXY_TEXTURE_3D` to determine if a
texture is too large. See glTexImage3D.

`GL_MAX_ARRAY_TEXTURE_LAYERS` `data` returns one value. The value indicates the maximum number
of layers allowed in an array texture, and must be at least 256. See glTexImage2D.

`GL_MAX_CLIP_DISTANCES` `data` returns one value, the maximum number of application-defined
clipping distances. The value must be at least 8.

`GL_MAX_COLOR_TEXTURE_SAMPLES` `data` returns one value, the maximum number of samples in a
color multisample texture.

`GL_MAX_COMBINED_ATOMIC_COUNTERS` `data` returns a single value, the maximum number of atomic
counters available to all active shaders.

`GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS` `data` returns one value, the number of words
for fragment shader uniform variables in all uniform blocks (including default). The value must be
at least 1. See glUniform.

`GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS` `data` returns one value, the number of words
for geometry shader uniform variables in all uniform blocks (including default). The value must be
at least 1. See glUniform.

`GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS` `data` returns one value, the maximum supported texture
image units that can be used to access texture maps from the vertex shader and the fragment
processor combined. If both the vertex shader and the fragment processing stage access the same
texture image unit, then that counts as using two texture image units against this limit. The value
must be at least 48. See glActiveTexture.

`GL_MAX_COMBINED_UNIFORM_BLOCKS` `data` returns one value, the maximum number of uniform
blocks per program. The value must be at least 70. See glUniformBlockBinding.

`GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS` `data` returns one value, the number of words for
vertex shader uniform variables in all uniform blocks (including default). The value must be at
least 1. See glUniform.

`GL_MAX_CUBE_MAP_TEXTURE_SIZE` `data` returns one value. The value gives a rough estimate of
the largest cube-map texture that the GL can handle. The value must be at least 1024. Use
`GL_PROXY_TEXTURE_CUBE_MAP` to determine if a texture is too large. See glTexImage2D.

`GL_MAX_DEPTH_TEXTURE_SAMPLES` `data` returns one value, the maximum number of samples in a
multisample depth or depth-stencil texture.

`GL_MAX_DRAW_BUFFERS` `data` returns one value, the maximum number of simultaneous outputs
that may be written in a fragment shader. The value must be at least 8. See glDrawBuffers.

`GL_MAX_DUAL_SOURCE_DRAW_BUFFERS` `data` returns one value, the maximum number of active draw
buffers when using dual-source blending. The value must be at least 1. See glBlendFunc and
glBlendFuncSeparate.

`GL_MAX_ELEMENTS_INDICES` `data` returns one value, the recommended maximum number of vertex
array indices. See glDrawRangeElements.

`GL_MAX_ELEMENTS_VERTICES` `data` returns one value, the recommended maximum number of vertex
array vertices. See glDrawRangeElements.

`GL_MAX_FRAGMENT_ATOMIC_COUNTERS` `data` returns a single value, the maximum number of atomic
counters available to fragment shaders.

`GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS` `data` returns one value, the maximum number of active
shader storage blocks that may be accessed by a fragment shader.

`GL_MAX_FRAGMENT_INPUT_COMPONENTS` `data` returns one value, the maximum number of components
of the inputs read by the fragment shader, which must be at least 128.

`GL_MAX_FRAGMENT_UNIFORM_COMPONENTS` `data` returns one value, the maximum number of
individual floating-point, integer, or boolean values that can be held in uniform variable storage
for a fragment shader. The value must be at least 1024. See glUniform.

`GL_MAX_FRAGMENT_UNIFORM_VECTORS` `data` returns one value, the maximum number of individual
4-vectors of floating-point, integer, or boolean values that can be held in uniform variable storage
for a fragment shader. The value is equal to the value of `GL_MAX_FRAGMENT_UNIFORM_COMPONENTS`
divided by 4 and must be at least 256. See glUniform.

`GL_MAX_FRAGMENT_UNIFORM_BLOCKS` `data` returns one value, the maximum number of uniform
blocks per fragment shader. The value must be at least 12. See glUniformBlockBinding.

`GL_MAX_FRAMEBUFFER_WIDTH` `data` returns one value, the maximum width for a framebuffer that
has no attachments, which must be at least 16384. See `glFramebufferParameter`.

`GL_MAX_FRAMEBUFFER_HEIGHT` `data` returns one value, the maximum height for a framebuffer
that has no attachments, which must be at least 16384. See `glFramebufferParameter`.

`GL_MAX_FRAMEBUFFER_LAYERS` `data` returns one value, the maximum number of layers for a
framebuffer that has no attachments, which must be at least 2048. See `glFramebufferParameter`.

`GL_MAX_FRAMEBUFFER_SAMPLES` `data` returns one value, the maximum samples in a framebuffer
that has no attachments, which must be at least 4. See `glFramebufferParameter`.

`GL_MAX_GEOMETRY_ATOMIC_COUNTERS` `data` returns a single value, the maximum number of atomic
counters available to geometry shaders.

`GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS` `data` returns one value, the maximum number of active
shader storage blocks that may be accessed by a geometry shader.

`GL_MAX_GEOMETRY_INPUT_COMPONENTS` `data` returns one value, the maximum number of components
of inputs read by a geometry shader, which must be at least 64.

`GL_MAX_GEOMETRY_OUTPUT_COMPONENTS` `data` returns one value, the maximum number of components
of outputs written by a geometry shader, which must be at least 128.

`GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS` `data` returns one value, the maximum supported texture
image units that can be used to access texture maps from the geometry shader. The value must be at
least 16. See glActiveTexture.

`GL_MAX_GEOMETRY_UNIFORM_BLOCKS` `data` returns one value, the maximum number of uniform
blocks per geometry shader. The value must be at least 12. See glUniformBlockBinding.

`GL_MAX_GEOMETRY_UNIFORM_COMPONENTS` `data` returns one value, the maximum number of
individual floating-point, integer, or boolean values that can be held in uniform variable storage
for a geometry shader. The value must be at least 1024. See glUniform.

`GL_MAX_INTEGER_SAMPLES` `data` returns one value, the maximum number of samples supported in
integer format multisample buffers.

`GL_MIN_MAP_BUFFER_ALIGNMENT` `data` returns one value, the minimum alignment in basic machine
units of pointers returned from glMapBuffer and glMapBufferRange. This value must be a power of
two and must be at least 64.

`GL_MAX_LABEL_LENGTH` `data` returns one value, the maximum length of a label that may be
assigned to an object. See glObjectLabel and glObjectPtrLabel.

`GL_MAX_PROGRAM_TEXEL_OFFSET` `data` returns one value, the maximum texel offset allowed in a
texture lookup, which must be at least 7.

`GL_MIN_PROGRAM_TEXEL_OFFSET` `data` returns one value, the minimum texel offset allowed in a
texture lookup, which must be at most -8.

`GL_MAX_RECTANGLE_TEXTURE_SIZE` `data` returns one value. The value gives a rough estimate of
the largest rectangular texture that the GL can handle. The value must be at least 1024. Use
`GL_PROXY_TEXTURE_RECTANGLE` to determine if a texture is too large. See glTexImage2D.

`GL_MAX_RENDERBUFFER_SIZE` `data` returns one value. The value indicates the maximum supported
size for renderbuffers. See glFramebufferRenderbuffer.

`GL_MAX_SAMPLE_MASK_WORDS` `data` returns one value, the maximum number of sample mask words.


`GL_MAX_SERVER_WAIT_TIMEOUT` `data` returns one value, the maximum glWaitSync timeout
interval.

`GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS` `data` returns one value, the maximum number of shader
storage buffer binding points on the context, which must be at least 8.

`GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS` `data` returns a single value, the maximum number of
atomic counters available to tessellation control shaders.

`GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS` `data` returns a single value, the maximum number of
atomic counters available to tessellation evaluation shaders.

`GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS` `data` returns one value, the maximum number of
active shader storage blocks that may be accessed by a tessellation control shader.

`GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS` `data` returns one value, the maximum number of
active shader storage blocks that may be accessed by a tessellation evaluation shader.

`GL_MAX_TEXTURE_BUFFER_SIZE` `data` returns one value. The value gives the maximum number of
texels allowed in the texel array of a texture buffer object. Value must be at least 65536.

`GL_MAX_TEXTURE_IMAGE_UNITS` `data` returns one value, the maximum supported texture image
units that can be used to access texture maps from the fragment shader. The value must be at least
16. See glActiveTexture.

`GL_MAX_TEXTURE_LOD_BIAS` `data` returns one value, the maximum, absolute value of the texture
level-of-detail bias. The value must be at least 2.0.

`GL_MAX_TEXTURE_SIZE` `data` returns one value. The value gives a rough estimate of the
largest texture that the GL can handle. The value must be at least 1024. Use a proxy texture target
such as `GL_PROXY_TEXTURE_1D` or `GL_PROXY_TEXTURE_2D` to determine if a texture is too large.

See glTexImage1D and glTexImage2D.

`GL_MAX_UNIFORM_BUFFER_BINDINGS` `data` returns one value, the maximum number of uniform
buffer binding points on the context, which must be at least 36.

`GL_MAX_UNIFORM_BLOCK_SIZE` `data` returns one value, the maximum size in basic machine units
of a uniform block, which must be at least 16384.

`GL_MAX_UNIFORM_LOCATIONS` `data` returns one value, the maximum number of explicitly
assignable uniform locations, which must be at least 1024.

`GL_MAX_VARYING_COMPONENTS` `data` returns one value, the number components for varying
variables, which must be at least 60.

`GL_MAX_VARYING_VECTORS` `data` returns one value, the number 4-vectors for varying variables,
which is equal to the value of `GL_MAX_VARYING_COMPONENTS` and must be at least 15.

`GL_MAX_VARYING_FLOATS` `data` returns one value, the maximum number of interpolators
available for processing varying variables used by vertex and fragment shaders. This value
represents the number of individual floating-point values that can be interpolated; varying
variables declared as vectors, matrices, and arrays will all consume multiple interpolators. The
value must be at least 32.

`GL_MAX_VERTEX_ATOMIC_COUNTERS` `data` returns a single value, the maximum number of atomic
counters available to vertex shaders.

`GL_MAX_VERTEX_ATTRIBS` `data` returns one value, the maximum number of 4-component generic
vertex attributes accessible to a vertex shader. The value must be at least 16. See glVertexAttrib.

`GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS` `data` returns one value, the maximum number of active
shader storage blocks that may be accessed by a vertex shader.

`GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS` `data` returns one value, the maximum supported texture
image units that can be used to access texture maps from the vertex shader. The value may be at
least 16. See glActiveTexture.

`GL_MAX_VERTEX_UNIFORM_COMPONENTS` `data` returns one value, the maximum number of individual
floating-point, integer, or boolean values that can be held in uniform variable storage for a vertex
shader. The value must be at least 1024. See glUniform.

`GL_MAX_VERTEX_UNIFORM_VECTORS` `data` returns one value, the maximum number of 4-vectors that
may be held in uniform variable storage for the vertex shader. The value of
`GL_MAX_VERTEX_UNIFORM_VECTORS` is equal to the value of `GL_MAX_VERTEX_UNIFORM_COMPONENTS` and
must be at least 256.

`GL_MAX_VERTEX_OUTPUT_COMPONENTS` `data` returns one value, the maximum number of components
of output written by a vertex shader, which must be at least 64.

`GL_MAX_VERTEX_UNIFORM_BLOCKS` `data` returns one value, the maximum number of uniform blocks
per vertex shader. The value must be at least 12. See glUniformBlockBinding.

`GL_MAX_VIEWPORT_DIMS` `data` returns two values: the maximum supported width and height of
the viewport. These must be at least as large as the visible dimensions of the display being
rendered to. See glViewport.

`GL_MAX_VIEWPORTS` `data` returns one value, the maximum number of simultaneous viewports that
are supported. The value must be at least 16. See glViewportIndexed.

`GL_MINOR_VERSION` `data` returns one value, the minor version number of the OpenGL API
supported by the current context.

`GL_NUM_COMPRESSED_TEXTURE_FORMATS` `data` returns a single integer value indicating the
number of available compressed texture formats. The minimum value is 4. See glCompressedTexImage2D.

`GL_NUM_EXTENSIONS` `data` returns one value, the number of extensions supported by the GL
implementation for the current context. See glGetString.

`GL_NUM_PROGRAM_BINARY_FORMATS` `data` returns one value, the number of program binary formats
supported by the implementation.

`GL_NUM_SHADER_BINARY_FORMATS` `data` returns one value, the number of binary shader formats
supported by the implementation. If this value is greater than zero, then the implementation
supports loading binary shaders. If it is zero, then the loading of binary shaders by the
implementation is not supported.

`GL_PACK_ALIGNMENT` `data` returns one value, the byte alignment used for writing pixel data
to memory. The initial value is 4. See glPixelStore.

`GL_PACK_IMAGE_HEIGHT` `data` returns one value, the image height used for writing pixel data
to memory. The initial value is 0. See glPixelStore.

`GL_PACK_LSB_FIRST` `data` returns a single boolean value indicating whether single-bit pixels
being written to memory are written first to the least significant bit of each unsigned byte. The
initial value is `GL_FALSE`. See glPixelStore.

`GL_PACK_ROW_LENGTH` `data` returns one value, the row length used for writing pixel data to
memory. The initial value is 0. See glPixelStore.

`GL_PACK_SKIP_IMAGES` `data` returns one value, the number of pixel images skipped before the
first pixel is written into memory. The initial value is 0. See glPixelStore.

`GL_PACK_SKIP_PIXELS` `data` returns one value, the number of pixel locations skipped before
the first pixel is written into memory. The initial value is 0. See glPixelStore.

`GL_PACK_SKIP_ROWS` `data` returns one value, the number of rows of pixel locations skipped
before the first pixel is written into memory. The initial value is 0. See glPixelStore.

`GL_PACK_SWAP_BYTES` `data` returns a single boolean value indicating whether the bytes of
two-byte and four-byte pixel indices and components are swapped before being written to memory. The
initial value is `GL_FALSE`. See glPixelStore.

`GL_PIXEL_PACK_BUFFER_BINDING` `data` returns a single value, the name of the buffer object
currently bound to the target `GL_PIXEL_PACK_BUFFER`. If no buffer object is bound to this target,
0 is returned. The initial value is 0. See glBindBuffer.

`GL_PIXEL_UNPACK_BUFFER_BINDING` `data` returns a single value, the name of the buffer object
currently bound to the target `GL_PIXEL_UNPACK_BUFFER`. If no buffer object is bound to this
target, 0 is returned. The initial value is 0. See glBindBuffer.

`GL_POINT_FADE_THRESHOLD_SIZE` `data` returns one value, the point size threshold for
determining the point size. See glPointParameter.

`GL_PRIMITIVE_RESTART_INDEX` `data` returns one value, the current primitive restart index.

The initial value is 0. See glPrimitiveRestartIndex.

`GL_PROGRAM_BINARY_FORMATS` `data` an array of `GL_NUM_PROGRAM_BINARY_FORMATS` values,
indicating the proram binary formats supported by the implementation.

`GL_PROGRAM_PIPELINE_BINDING` `data` a single value, the name of the currently bound program
pipeline object, or zero if no program pipeline object is bound. See glBindProgramPipeline.

`GL_PROGRAM_POINT_SIZE` `data` returns a single boolean value indicating whether vertex
program point size mode is enabled. If enabled, then the point size is taken from the shader
built-in gl_PointSize. If disabled, then the point size is taken from the point state as specified
by glPointSize. The initial value is `GL_FALSE`.

`GL_PROVOKING_VERTEX` `data` returns one value, the currently selected provoking vertex
convention. The initial value is `GL_LAST_VERTEX_CONVENTION`. See glProvokingVertex.

`GL_POINT_SIZE` `data` returns one value, the point size as specified by glPointSize. The
initial value is 1.

`GL_POINT_SIZE_GRANULARITY` `data` returns one value, the size difference between adjacent
supported sizes for antialiased points. See glPointSize.

`GL_POINT_SIZE_RANGE` `data` returns two values: the smallest and largest supported sizes for
antialiased points. The smallest size must be at most 1, and the largest size must be at least 1.

See glPointSize.

`GL_POLYGON_OFFSET_FACTOR` `data` returns one value, the scaling factor used to determine the
variable offset that is added to the depth value of each fragment generated when a polygon is
rasterized. The initial value is 0. See glPolygonOffset.

`GL_POLYGON_OFFSET_UNITS` `data` returns one value. This value is multiplied by an
implementation-specific value and then added to the depth value of each fragment generated when a
polygon is rasterized. The initial value is 0. See glPolygonOffset.

`GL_POLYGON_OFFSET_FILL` `data` returns a single boolean value indicating whether polygon
offset is enabled for polygons in fill mode. The initial value is `GL_FALSE`. See
glPolygonOffset.

`GL_POLYGON_OFFSET_LINE` `data` returns a single boolean value indicating whether polygon
offset is enabled for polygons in line mode. The initial value is `GL_FALSE`. See
glPolygonOffset.

`GL_POLYGON_OFFSET_POINT` `data` returns a single boolean value indicating whether polygon
offset is enabled for polygons in point mode. The initial value is `GL_FALSE`. See
glPolygonOffset.

`GL_POLYGON_SMOOTH` `data` returns a single boolean value indicating whether antialiasing of
polygons is enabled. The initial value is `GL_FALSE`. See glPolygonMode.

`GL_POLYGON_SMOOTH_HINT` `data` returns one value, a symbolic constant indicating the mode of
the polygon antialiasing hint. The initial value is `GL_DONT_CARE`. See glHint.

`GL_READ_BUFFER` `data` returns one value, a symbolic constant indicating which color buffer
is selected for reading. The initial value is `GL_BACK` if there is a back buffer, otherwise it is
`GL_FRONT`. See glReadPixels.

`GL_RENDERBUFFER_BINDING` `data` returns a single value, the name of the renderbuffer object
currently bound to the target `GL_RENDERBUFFER`. If no renderbuffer object is bound to this
target, 0 is returned. The initial value is 0. See glBindRenderbuffer.

`GL_SAMPLE_BUFFERS` `data` returns a single integer value indicating the number of sample
buffers associated with the framebuffer. See glSampleCoverage.

`GL_SAMPLE_COVERAGE_VALUE` `data` returns a single positive floating-point value indicating
the current sample coverage value. See glSampleCoverage.

`GL_SAMPLE_COVERAGE_INVERT` `data` returns a single boolean value indicating if the temporary
coverage value should be inverted. See glSampleCoverage.

`GL_SAMPLE_MASK_VALUE` `params` returns one value indicating the current sample mask value.

See glSampleMaski.

`GL_SAMPLER_BINDING` `data` returns a single value, the name of the sampler object currently
bound to the active texture unit. The initial value is 0. See glBindSampler.

`GL_SAMPLES` `data` returns a single integer value indicating the coverage mask size. See
glSampleCoverage.

`GL_SCISSOR_BOX` `data` returns four values: the x and y window coordinates of the
scissor box, followed by its width and height. Initially the x and y window coordinates are
both 0 and the width and height are set to the size of the window. See glScissor.

`GL_SCISSOR_TEST` `data` returns a single boolean value indicating whether scissoring is
enabled. The initial value is `GL_FALSE`. See glScissor.

`GL_SHADER_COMPILER` `data` returns a single boolean value indicating whether an online shader
compiler is present in the implementation. All desktop OpenGL implementations must support online
shader compilations, and therefore the value of `GL_SHADER_COMPILER` will always be `GL_TRUE`.

`GL_SHADER_STORAGE_BUFFER_BINDING` When used with non-indexed variants of `glGet` (such as
`glGetIntegerv` ), `data` returns a single value, the name of the buffer object currently bound to
the target `GL_SHADER_STORAGE_BUFFER`. If no buffer object is bound to this target, 0 is returned.

When used with indexed variants of `glGet` (such as `glGetIntegeri_v` ), `data` returns a
single value, the name of the buffer object bound to the indexed shader storage buffer binding
points. The initial value is 0 for all targets. See glBindBuffer, glBindBufferBase, and
glBindBufferRange.

`GL_SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT` `data` returns a single value, the minimum
required alignment for shader storage buffer sizes and offset. The initial value is 1. See
glShaderStorageBlockBinding.

`GL_SHADER_STORAGE_BUFFER_START` When used with indexed variants of `glGet` (such as
`glGetInteger64i_v` ), `data` returns a single value, the start offset of the binding range for
each indexed shader storage buffer binding. The initial value is 0 for all bindings. See
glBindBufferRange.

`GL_SHADER_STORAGE_BUFFER_SIZE` When used with indexed variants of `glGet` (such as
`glGetInteger64i_v` ), `data` returns a single value, the size of the binding range for each
indexed shader storage buffer binding. The initial value is 0 for all bindings. See
glBindBufferRange.

`GL_SMOOTH_LINE_WIDTH_RANGE` `data` returns a pair of values indicating the range of widths
supported for smooth (antialiased) lines. See glLineWidth.

`GL_SMOOTH_LINE_WIDTH_GRANULARITY` `data` returns a single value indicating the level of
quantization applied to smooth line width parameters.

`GL_STENCIL_BACK_FAIL` `data` returns one value, a symbolic constant indicating what action is
taken for back-facing polygons when the stencil test fails. The initial value is `GL_KEEP`. See
glStencilOpSeparate.

`GL_STENCIL_BACK_FUNC` `data` returns one value, a symbolic constant indicating what function
is used for back-facing polygons to compare the stencil reference value with the stencil buffer
value. The initial value is `GL_ALWAYS`. See glStencilFuncSeparate.

`GL_STENCIL_BACK_PASS_DEPTH_FAIL` `data` returns one value, a symbolic constant indicating
what action is taken for back-facing polygons when the stencil test passes, but the depth test
fails. The initial value is `GL_KEEP`. See glStencilOpSeparate.

`GL_STENCIL_BACK_PASS_DEPTH_PASS` `data` returns one value, a symbolic constant indicating
what action is taken for back-facing polygons when the stencil test passes and the depth test
passes. The initial value is `GL_KEEP`. See glStencilOpSeparate.

`GL_STENCIL_BACK_REF` `data` returns one value, the reference value that is compared with the
contents of the stencil buffer for back-facing polygons. The initial value is 0. See
glStencilFuncSeparate.

`GL_STENCIL_BACK_VALUE_MASK` `data` returns one value, the mask that is used for back-facing
polygons to mask both the stencil reference value and the stencil buffer value before they are
compared. The initial value is all 1's. See glStencilFuncSeparate.

`GL_STENCIL_BACK_WRITEMASK` `data` returns one value, the mask that controls writing of the
stencil bitplanes for back-facing polygons. The initial value is all 1's. See
glStencilMaskSeparate.

`GL_STENCIL_CLEAR_VALUE` `data` returns one value, the index to which the stencil bitplanes
are cleared. The initial value is 0. See glClearStencil.

`GL_STENCIL_FAIL` `data` returns one value, a symbolic constant indicating what action is
taken when the stencil test fails. The initial value is `GL_KEEP`. See glStencilOp. This
stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate
stencil state. See glStencilOpSeparate.

`GL_STENCIL_FUNC` `data` returns one value, a symbolic constant indicating what function is
used to compare the stencil reference value with the stencil buffer value. The initial value is
`GL_ALWAYS`. See glStencilFunc. This stencil state only affects non-polygons and front-facing
polygons. Back-facing polygons use separate stencil state. See glStencilFuncSeparate.

`GL_STENCIL_PASS_DEPTH_FAIL` `data` returns one value, a symbolic constant indicating what
action is taken when the stencil test passes, but the depth test fails. The initial value is
`GL_KEEP`. See glStencilOp. This stencil state only affects non-polygons and front-facing
polygons. Back-facing polygons use separate stencil state. See glStencilOpSeparate.

`GL_STENCIL_PASS_DEPTH_PASS` `data` returns one value, a symbolic constant indicating what
action is taken when the stencil test passes and the depth test passes. The initial value is
`GL_KEEP`. See glStencilOp. This stencil state only affects non-polygons and front-facing
polygons. Back-facing polygons use separate stencil state. See glStencilOpSeparate.

`GL_STENCIL_REF` `data` returns one value, the reference value that is compared with the
contents of the stencil buffer. The initial value is 0. See glStencilFunc. This stencil state
only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil
state. See glStencilFuncSeparate.

`GL_STENCIL_TEST` `data` returns a single boolean value indicating whether stencil testing of
fragments is enabled. The initial value is `GL_FALSE`. See glStencilFunc and glStencilOp.

`GL_STENCIL_VALUE_MASK` `data` returns one value, the mask that is used to mask both the
stencil reference value and the stencil buffer value before they are compared. The initial value is
all 1's. See glStencilFunc. This stencil state only affects non-polygons and front-facing
polygons. Back-facing polygons use separate stencil state. See glStencilFuncSeparate.

`GL_STENCIL_WRITEMASK` `data` returns one value, the mask that controls writing of the stencil
bitplanes. The initial value is all 1's. See glStencilMask. This stencil state only affects
non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See
glStencilMaskSeparate.

`GL_STEREO` `data` returns a single boolean value indicating whether stereo buffers (left and
right) are supported.

`GL_SUBPIXEL_BITS` `data` returns one value, an estimate of the number of bits of subpixel
resolution that are used to position rasterized geometry in window coordinates. The value must be at
least 4.

`GL_TEXTURE_BINDING_1D` `data` returns a single value, the name of the texture currently bound
to the target `GL_TEXTURE_1D`. The initial value is 0. See glBindTexture.

`GL_TEXTURE_BINDING_1D_ARRAY` `data` returns a single value, the name of the texture currently
bound to the target `GL_TEXTURE_1D_ARRAY`. The initial value is 0. See glBindTexture.

`GL_TEXTURE_BINDING_2D` `data` returns a single value, the name of the texture currently bound
to the target `GL_TEXTURE_2D`. The initial value is 0. See glBindTexture.

`GL_TEXTURE_BINDING_2D_ARRAY` `data` returns a single value, the name of the texture currently
bound to the target `GL_TEXTURE_2D_ARRAY`. The initial value is 0. See glBindTexture.

`GL_TEXTURE_BINDING_2D_MULTISAMPLE` `data` returns a single value, the name of the texture
currently bound to the target `GL_TEXTURE_2D_MULTISAMPLE`. The initial value is 0. See
glBindTexture.

`GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY` `data` returns a single value, the name of the
texture currently bound to the target `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`. The initial value is 0.

See glBindTexture.

`GL_TEXTURE_BINDING_3D` `data` returns a single value, the name of the texture currently bound
to the target `GL_TEXTURE_3D`. The initial value is 0. See glBindTexture.

`GL_TEXTURE_BINDING_BUFFER` `data` returns a single value, the name of the texture currently
bound to the target `GL_TEXTURE_BUFFER`. The initial value is 0. See glBindTexture.

`GL_TEXTURE_BINDING_CUBE_MAP` `data` returns a single value, the name of the texture currently
bound to the target `GL_TEXTURE_CUBE_MAP`. The initial value is 0. See glBindTexture.

`GL_TEXTURE_BINDING_RECTANGLE` `data` returns a single value, the name of the texture
currently bound to the target `GL_TEXTURE_RECTANGLE`. The initial value is 0. See glBindTexture.

`GL_TEXTURE_COMPRESSION_HINT` `data` returns a single value indicating the mode of the texture
compression hint. The initial value is `GL_DONT_CARE`.

`GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT` `data` returns a single value, the minimum required
alignment for texture buffer sizes and offset. The initial value is 1. See glUniformBlockBinding.


`GL_TIMESTAMP` `data` returns a single value, the 64-bit value of the current GL time. See
glQueryCounter.

`GL_TRANSFORM_FEEDBACK_BUFFER_BINDING` When used with non-indexed variants of `glGet` (such
as `glGetIntegerv` ), `data` returns a single value, the name of the buffer object currently
bound to the target `GL_TRANSFORM_FEEDBACK_BUFFER`. If no buffer object is bound to this target, 0
is returned. When used with indexed variants of `glGet` (such as `glGetIntegeri_v` ), `data`
returns a single value, the name of the buffer object bound to the indexed transform feedback
attribute stream. The initial value is 0 for all targets. See glBindBuffer, glBindBufferBase,
and glBindBufferRange.

`GL_TRANSFORM_FEEDBACK_BUFFER_START` When used with indexed variants of `glGet` (such as
`glGetInteger64i_v` ), `data` returns a single value, the start offset of the binding range for
each transform feedback attribute stream. The initial value is 0 for all streams. See
glBindBufferRange.

`GL_TRANSFORM_FEEDBACK_BUFFER_SIZE` When used with indexed variants of `glGet` (such as
`glGetInteger64i_v` ), `data` returns a single value, the size of the binding range for each
transform feedback attribute stream. The initial value is 0 for all streams. See glBindBufferRange.

`GL_UNIFORM_BUFFER_BINDING` When used with non-indexed variants of `glGet` (such as
`glGetIntegerv` ), `data` returns a single value, the name of the buffer object currently bound to
the target `GL_UNIFORM_BUFFER`. If no buffer object is bound to this target, 0 is returned. When
used with indexed variants of `glGet` (such as `glGetIntegeri_v` ), `data` returns a single
value, the name of the buffer object bound to the indexed uniform buffer binding point. The initial
value is 0 for all targets. See glBindBuffer, glBindBufferBase, and glBindBufferRange.

`GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT` `data` returns a single value, the minimum required
alignment for uniform buffer sizes and offset. The initial value is 1. See glUniformBlockBinding.


`GL_UNIFORM_BUFFER_SIZE` When used with indexed variants of `glGet` (such as
`glGetInteger64i_v` ), `data` returns a single value, the size of the binding range for each
indexed uniform buffer binding. The initial value is 0 for all bindings. See glBindBufferRange.

`GL_UNIFORM_BUFFER_START` When used with indexed variants of `glGet` (such as
`glGetInteger64i_v` ), `data` returns a single value, the start offset of the binding range for
each indexed uniform buffer binding. The initial value is 0 for all bindings. See
glBindBufferRange.

`GL_UNPACK_ALIGNMENT` `data` returns one value, the byte alignment used for reading pixel data
from memory. The initial value is 4. See glPixelStore.

`GL_UNPACK_IMAGE_HEIGHT` `data` returns one value, the image height used for reading pixel
data from memory. The initial is 0. See glPixelStore.

`GL_UNPACK_LSB_FIRST` `data` returns a single boolean value indicating whether single-bit
pixels being read from memory are read first from the least significant bit of each unsigned byte.

The initial value is `GL_FALSE`. See glPixelStore.

`GL_UNPACK_ROW_LENGTH` `data` returns one value, the row length used for reading pixel data
from memory. The initial value is 0. See glPixelStore.

`GL_UNPACK_SKIP_IMAGES` `data` returns one value, the number of pixel images skipped before
the first pixel is read from memory. The initial value is 0. See glPixelStore.

`GL_UNPACK_SKIP_PIXELS` `data` returns one value, the number of pixel locations skipped before
the first pixel is read from memory. The initial value is 0. See glPixelStore.

`GL_UNPACK_SKIP_ROWS` `data` returns one value, the number of rows of pixel locations skipped
before the first pixel is read from memory. The initial value is 0. See glPixelStore.

`GL_UNPACK_SWAP_BYTES` `data` returns a single boolean value indicating whether the bytes of
two-byte and four-byte pixel indices and components are swapped after being read from memory. The
initial value is `GL_FALSE`. See glPixelStore.

`GL_VERTEX_ARRAY_BINDING` `data` returns a single value, the name of the vertex array object
currently bound to the context. If no vertex array object is bound to the context, 0 is returned.

The initial value is 0. See glBindVertexArray.

`GL_VERTEX_BINDING_DIVISOR` Accepted by the indexed forms. `data` returns a single integer
value representing the instance step divisor of the first element in the bound buffer's data store
for vertex attribute bound to `index`.

`GL_VERTEX_BINDING_OFFSET` Accepted by the indexed forms. `data` returns a single integer
value representing the byte offset of the first element in the bound buffer's data store for vertex
attribute bound to `index`.

`GL_VERTEX_BINDING_STRIDE` Accepted by the indexed forms. `data` returns a single integer
value representing the byte offset between the start of each element in the bound buffer's data
store for vertex attribute bound to `index`.

`GL_VERTEX_BINDING_BUFFER` Accepted by the indexed forms. `data` returns a single integer
value representing the name of the buffer bound to vertex binding `index`.

`GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET` `data` returns a single integer value containing the
maximum offset that may be added to a vertex binding offset.

`GL_MAX_VERTEX_ATTRIB_BINDINGS` `data` returns a single integer value containing the maximum
number of vertex buffers that may be bound.

`GL_VIEWPORT` When used with non-indexed variants of `glGet` (such as `glGetIntegerv` ),
`data` returns four values: the x and y window coordinates of the viewport, followed by its
width and height. Initially the x and y window coordinates are both set to 0, and the width
and height are set to the width and height of the window into which the GL will do its rendering.

See glViewport.

When used with indexed variants of `glGet` (such as `glGetIntegeri_v` ), `data` returns four
values: the x and y window coordinates of the indexed viewport, followed by its width and
height. Initially the x and y window coordinates are both set to 0, and the width and height
are set to the width and height of the window into which the GL will do its rendering. See
`glViewportIndexedf`.

`GL_VIEWPORT_BOUNDS_RANGE` `data` returns two values, the minimum and maximum viewport bounds
range. The minimum range should be at least [-32768, 32767].

`GL_VIEWPORT_INDEX_PROVOKING_VERTEX` `data` returns one value, the implementation dependent
specifc vertex of a primitive that is used to select the viewport index. If the value returned is
equivalent to `GL_PROVOKING_VERTEX`, then the vertex selection follows the convention specified by
glProvokingVertex. If the value returned is equivalent to `GL_FIRST_VERTEX_CONVENTION`, then
the selection is always taken from the first vertex in the primitive. If the value returned is
equivalent to `GL_LAST_VERTEX_CONVENTION`, then the selection is always taken from the last vertex
in the primitive. If the value returned is equivalent to `GL_UNDEFINED_VERTEX`, then the selection
is not guaranteed to be taken from any specific vertex in the primitive.

`GL_VIEWPORT_SUBPIXEL_BITS` `data` returns a single value, the number of bits of sub-pixel
precision which the GL uses to interpret the floating point viewport bounds. The minimum value is 0.


`GL_MAX_ELEMENT_INDEX` `data` returns a single value, the maximum index that may be specified
during the transfer of generic vertex attributes to the GL.

Many of the boolean parameters can also be queried more easily using glIsEnabled.
---
### Notes
The following parameters return the associated value for the active texture unit: `GL_TEXTURE_1D`,
`GL_TEXTURE_BINDING_1D`, `GL_TEXTURE_2D`, `GL_TEXTURE_BINDING_2D`, `GL_TEXTURE_3D` and
`GL_TEXTURE_BINDING_3D`.

`GL_MAX_VIEWPORTS`, `GL_VIEWPORT_SUBPIXEL_BITS`, `GL_VIEWPORT_BOUNDS_RANGE`,
`GL_LAYER_PROVOKING_VERTEX`, and `GL_VIEWPORT_INDEX_PROVOKING_VERTEX` are available only if the
GL version is 4.1 or greater.

`GL_MAX_VERTEX_ATOMIC_COUNTERS`, `GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS`,
`GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS`, `GL_MAX_GEOMETRY_ATOMIC_COUNTERS`,
`GL_MAX_FRAMGENT_ATOMIC_COUNTERS`, and `GL_MIN_MAP_BUFFER_ALIGNMENT` are accepted by `pname`
only if the GL version is 4.2 or greater.

`GL_MAX_ELEMENT_INDEX` is accepted by `pname` only if the GL version is 4.3 or greater.

`GL_MAX_COMPUTE_UNIFORM_BLOCKS`, `GL_MAX_COMPUTE_TEXTURE_IMAGE_UNITS`,
`GL_MAX_COMPUTE_UNIFORM_COMPONENTS`, `GL_MAX_COMPUTE_ATOMIC_COUNTERS`,
`GL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS`, `GL_MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS`,
`GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS`, `GL_MAX_COMPUTE_WORK_GROUP_COUNT`, and
`GL_MAX_COMPUTE_WORK_GROUP_SIZE` and `GL_DISPATCH_INDIRECT_BUFFER_BINDING` are available only if
the GL version is 4.3 or greater.

`GL_MAX_DEBUG_GROUP_STACK_DEPTH`, `GL_DEBUG_GROUP_STACK_DEPTH` and `GL_MAX_LABEL_LENGTH` are
accepted only if the GL version is 4.3 or greater.

`GL_MAX_UNIFORM_LOCATIONS` is accepted only if the GL version is 4.3 or greater.

`GL_MAX_FRAMEBUFFER_WIDTH`, `GL_MAX_FRAMEBUFFER_HEIGHT`, `GL_MAX_FRAMEBUFFER_LAYERS`, and
`GL_MAX_FRAMEBUFFER_SAMPLES` are available only if the GL version is 4.3 or greater.

`GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS`, `GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS`,
`GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS`, `GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS`,
`GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS`, and `GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS` are available
only if the GL version is 4.3 or higher.

`GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT` is available only if the GL version is 4.3 or greater.

`GL_VERTEX_BINDING_DIVISOR`, `GL_VERTEX_BINDING_OFFSET`, `GL_VERTEX_BINDING_STRIDE`,
`GL_VERTEX_BINDING_BUFFER`, `GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET` and
`GL_MAX_VERTEX_ATTRIB_BINDINGS` are available only if the GL version is 4.3 or greater.
---
### Errors
`GL_INVALID_ENUM` is generated if `pname` is not an accepted value.

`GL_INVALID_VALUE` is generated on any of `glGetBooleani_v`, `glGetIntegeri_v`, or
`glGetInteger64i_v` if `index` is outside of the valid range for the indexed state `target`.
---
### Version Support
`glGetBooleani_v` `glGetBooleanv` `glGetDoublei_v` `glGetDoublev` `glGetFloati_v`
`glGetFloatv` `glGetInteger64i_v` `glGetInteger64v` `glGetIntegeri_v` `glGetIntegerv`
---
### See Also
glGetActiveUniform, glGetAttachedShaders, glGetAttribLocation, glGetBufferParameter,
glGetBufferPointerv, glGetBufferSubData, glGetCompressedTexImage, glGetError,
glGetProgram, glGetProgramInfoLog, glGetQueryiv, glGetQueryObject, glGetShader,
glGetShaderInfoLog, glGetShaderSource, glGetString, glGetTexImage,
glGetTexLevelParameter, glGetTexParameter, glGetUniform, glGetUniformLocation,
glGetVertexAttrib, glGetVertexAttribPointerv, glIsEnabled
---
### Copyright
Copyright 1991-2006 Silicon Graphics, Inc. Copyright 2010-2014 Khronos Group. This document
is licensed under the SGI Free Software B License. For details, see
https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.
]],
  [[Query the location of a named resource within a program
---
### Parameters
`program` The name of a program object whose resources to query.
`programInterface` A token identifying the interface within `program` containing the resource
named `name`.

`name` The name of the resource to query the location of.
---
### Description
`glGetProgramResourceLocation` returns the location assigned to the variable named `name` in
interface `programInterface` of program object `program`. `program` must be the name of a
program that has been linked successfully. `programInterface` must be one of `GL_UNIFORM`,
`GL_PROGRAM_INPUT`, `GL_PROGRAM_OUTPUT`, `GL_VERTEX_SUBROUTINE_UNIFORM`,
`GL_TESS_CONTROL_SUBROUTINE_UNIFORM`, `GL_TESS_EVALUATION_SUBROUTINE_UNIFORM`,
`GL_GEOMETRY_SUBROUTINE_UNIFORM`, `GL_FRAGMENT_SUBROUTINE_UNIFORM`,
`GL_COMPUTE_SUBROUTINE_UNIFORM`, or `GL_TRANSFORM_FEEDBACK_BUFFER`.

The value -1 will be returned if an error occurs, if `name` does not identify an active variable
on `programInterface`, or if `name` identifies an active variable that does not have a valid
location assigned, as described above. The locations returned by these commands are the same
locations returned when querying the `GL_LOCATION` and `GL_LOCATION_INDEX` resource properties.

A string provided to `glGetProgramResourceLocation` is considered to match an active variable
if:

the string exactly matches the name of the active variable if the string identifies the base
name of an active array, where the string would exactly match the name of the variable if the suffix
"[0]" were appended to the string if the string identifies an active element of the array, where
the string ends with the concatenation of the "[" character, an integer with no "+" sign, extra
leading zeroes, or whitespace identifying an array element, and the "]" character, the integer is
less than the number of active elements of the array variable, and where the string would exactly
match the enumerated name of the array if the decimal integer were replaced with zero.

Any other string is considered not to identify an active variable. If the string specifies an
element of an array variable, `glGetProgramResourceLocation` returns the location assigned to that
element. If it specifies the base name of an array, it identifies the resources associated with the
first element of the array.
---
### Errors
`GL_INVALID_VALUE` is generated if `program` is not the name of an existing program object.

`GL_INVALID_ENUM` is generated if `programInterface` is not one of the accepted interface
types.

`GL_INVALID_OPERATION` is generated if `program` has not been linked successfully.
---
### Version Support
`glGetProgramResourceLocation`
---
### See Also
glGetProgramResourceName, glGetProgramResourceIndex, glGetProgramResource,
glGetProgramResourceLocationIndex.
---
### Copyright
Copyright 2013-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Query the fragment color index of a named variable within a program
---
### Parameters
`program` The name of a program object whose resources to query.
`programInterface` A token identifying the interface within `program` containing the resource
named `name`.

`name` The name of the resource to query the location of.
---
### Description
`glGetProgramResourceLocationIndex` returns the fragment color index assigned to the variable
named `name` in interface `programInterface` of program object `program`. `program` must be
the name of a program that has been linked successfully. `programInterface` must be
`GL_PROGRAM_OUTPUT`.

The value -1 will be returned if an error occurs, if `name` does not identify an active variable
on `programInterface`, or if `name` identifies an active variable that does not have a valid
location assigned, as described above. The locations returned by these commands are the same
locations returned when querying the `GL_LOCATION` and `GL_LOCATION_INDEX` resource properties.

A string provided to `glGetProgramResourceLocationIndex` is considered to match an active
variable if:

the string exactly matches the name of the active variable if the string identifies the base
name of an active array, where the string would exactly match the name of the variable if the suffix
"[0]" were appended to the string if the string identifies an active element of the array, where
the string ends with the concatenation of the "[" character, an integer with no "+" sign, extra
leading zeroes, or whitespace identifying an array element, and the "]" character, the integer is
less than the number of active elements of the array variable, and where the string would exactly
match the enumerated name of the array if the decimal integer were replaced with zero.

Any other string is considered not to identify an active variable. If the string specifies an
element of an array variable, `glGetProgramResourceLocation` returns the location assigned to that
element. If it specifies the base name of an array, it identifies the resources associated with the
first element of the array.
---
### Errors
`GL_INVALID_VALUE` is generated if `program` is not the name of an existing program object.

`GL_INVALID_ENUM` is generated if `programInterface` is not one of the accepted interface
types.

`GL_INVALID_OPERATION` is generated if `program` has not been linked successfully.
---
### Version Support
`glGetProgramResourceLocationIndex`
---
### See Also
glGetProgramResourceName, glGetProgramResourceIndex, glGetProgramResource,
glGetProgramResourceLocationIndex.
---
### Copyright
Copyright 2013-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Query the name of an indexed resource within a program
---
### Parameters
`program` The name of a program object whose resources to query.
`programInterface` A token identifying the interface within `program` containing the indexed
resource.

`index` The index of the resource within `programInterface` of `program`.

`bufSize` The size of the character array whose address is given by `name`.

`length` The address of a variable which will receive the length of the resource name.
`name` The address of a character array into which will be written the name of the resource.
---
### Description
`glGetProgramResourceName` retrieves the name string assigned to the single active resource with
an index of `index` in the interface `programInterface` of program object `program`. `index`
must be less than the number of entries in the active resource list for `programInterface`.

`program` must be the name of an existing program object. `programInterface` is the name of the
interface within `program` which contains the resource and must be one of the following values:

`GL_UNIFORM` The query is targeted at the set of active uniforms within `program`.

`GL_UNIFORM_BLOCK` The query is targeted at the set of active uniform blocks within `program`.

`GL_PROGRAM_INPUT` The query is targeted at the set of active input variables used by the first
shader stage of `program`. If `program` contains multiple shader stages then input variables
from any stage other than the first will not be enumerated.

`GL_PROGRAM_OUTPUT` The query is targeted at the set of active output variables produced by the
last shader stage of `program`. If `program` contains multiple shader stages then output
variables from any stage other than the last will not be enumerated.

`GL_VERTEX_SUBROUTINE` `GL_TESS_CONTROL_SUBROUTINE` `GL_TESS_EVALUATION_SUBROUTINE`
`GL_GEOMETRY_SUBROUTINE` `GL_FRAGMENT_SUBROUTINE` `GL_COMPUTE_SUBROUTINE` The query is targeted
at the set of active subroutines for the vertex, tessellation control, tessellation evaluation,
geometry, fragment and compute shader stages of `program`, respectively.

`GL_VERTEX_SUBROUTINE_UNIFORM` `GL_TESS_CONTROL_SUBROUTINE_UNIFORM`
`GL_TESS_EVALUATION_SUBROUTINE_UNIFORM` `GL_GEOMETRY_SUBROUTINE_UNIFORM`
`GL_FRAGMENT_SUBROUTINE_UNIFORM` `GL_COMPUTE_SUBROUTINE_UNIFORM` The query is targeted at the set
of active subroutine uniform variables used by the vertex, tessellation control, tessellation
evaluation, geometry, fragment and compute shader stages of `program`, respectively.

`GL_TRANSFORM_FEEDBACK_VARYING` The query is targeted at the set of output variables from the
last non-fragment stage of `program` that would be captured if transform feedback were active.

`GL_BUFFER_VARIABLE` The query is targeted at the set of active buffer variables used by
`program`.

`GL_SHADER_STORAGE_BLOCK` The query is targeted at the set of active shader storage blocks used
by `program`.

The name string assigned to the active resource identified by `index` is returned as a
null-terminated string in the character array whose address is given in `name`. The actual number
of characters written into `name`, excluding the null terminator, is returned in `length`. If
`length` is NULL, no length is returned. The maximum number of characters that may be written into
`name`, including the null terminator, is specified by `bufSize`. If the length of the name
string including the null terminator is greater than `bufSize`, the first `bufSize` -1
characters of the name string will be written to `name`, followed by a null terminator. If
`bufSize` is zero, no error will be generated but no characters will be written to `name`. The
length of the longest name string for `programInterface` >, including a null terminator, can be
queried by calling glGetProgramInterface with a `pname` of `GL_MAX_NAME_LENGTH`.
---
### Errors
`GL_INVALID_ENUM` is generated if `programInterface` is not one of the accepted interface
types.

`GL_INVALID_VALUE` is generated if `progam` is not the name of an existing program.

`GL_INVALID_VALUE` is generated if `index` is greater than or equal to the number of entries in
the active resource list for `programInterface`.

`GL_INVALID_ENUM` is generated if `programInterface` is `GL_ATOMIC_COUNTER_BUFFER` or
`GL_TRANSFORM_FEEDBACK_BUFFER`, since active atomic counter and transform feedback buffer resources
are not assigned name strings.
---
### Version Support
`glGetProgramResourceName`
---
### See Also
glGetProgramResourceIndex, glGetProgramResource, glGetProgramResourceLocation,
glGetProgramResourceLocationIndex.
---
### Copyright
Copyright 2013-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Retrieve properties of a program object corresponding to a specified shader stage
---
### Parameters
`program` Specifies the name of the program containing shader stage.
`shadertype` Specifies the shader stage from which to query for the subroutine parameter.
`shadertype` must be one of `GL_VERTEX_SHADER`, `GL_TESS_CONTROL_SHADER`,
`GL_TESS_EVALUATION_SHADER`, `GL_GEOMETRY_SHADER` or `GL_FRAGMENT_SHADER`.

`pname` Specifies the parameter of the shader to query. `pname` must be
`GL_ACTIVE_SUBROUTINE_UNIFORMS`, `GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS`,
`GL_ACTIVE_SUBROUTINES`, `GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH`, or
`GL_ACTIVE_SUBROUTINE_MAX_LENGTH`.

`values` Specifies the address of a variable into which the queried value or values will be
placed.
---
### Description
`glGetProgramStage` queries a parameter of a shader stage attached to a program object.
`program` contains the name of the program to which the shader is attached. `shadertype`
specifies the stage from which to query the parameter. `pname` specifies which parameter should be
queried. The value or values of the parameter to be queried is returned in the variable whose
address is given in `values`.

If `pname` is `GL_ACTIVE_SUBROUTINE_UNIFORMS`, the number of active subroutine variables in
the stage is returned in `values`.

If `pname` is `GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS`, the number of active subroutine
variable locations in the stage is returned in `values`.

If `pname` is `GL_ACTIVE_SUBROUTINES`, the number of active subroutines in the stage is
returned in `values`.

If `pname` is `GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH`, the length of the longest subroutine
uniform for the stage is returned in `values`.

If `pname` is `GL_ACTIVE_SUBROUTINE_MAX_LENGTH`, the length of the longest subroutine name for
the stage is returned in `values`. The returned name length includes space for the
null-terminator.

If there is no shader present of type `shadertype`, the returned value will be consistent with a
shader containing no subroutines or subroutine uniforms.
---
### Errors
`GL_INVALID_ENUM` is generated if `shadertype` or `pname` is not one of the accepted values.

`GL_INVALID_VALUE` is generated if `program` is not the name of an existing program object.
---
### Version Support
`glGetProgramStageiv`
---
### See Also
glGetProgram
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Return parameters of an indexed query object target
---
### Parameters
`target` Specifies a query object target. Must be `GL_SAMPLES_PASSED`,
`GL_ANY_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED_CONSERVATIVE` `GL_PRIMITIVES_GENERATED`,
`GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`, `GL_TIME_ELAPSED`, or `GL_TIMESTAMP`.

`index` Specifies the index of the query object target.
`pname` Specifies the symbolic name of a query object target parameter. Accepted values are
`GL_CURRENT_QUERY` or `GL_QUERY_COUNTER_BITS`.

`params` Returns the requested data.
---
### Description
`glGetQueryIndexediv` returns in `params` a selected parameter of the indexed query object
target specified by `target` and `index`. `index` specifies the index of the query object
target and must be between zero and a target-specific maxiumum.

`pname` names a specific query object target parameter. When `pname` is `GL_CURRENT_QUERY`,
the name of the currently active query for the specified `index` of `target`, or zero if no
query is active, will be placed in `params`. If `pname` is `GL_QUERY_COUNTER_BITS`, the
implementation-dependent number of bits used to hold the result of queries for `target` is
returned in `params`.
---
### Notes
The target `GL_ANY_SAMPLES_PASSED_CONSERVATIVE` is available only if the GL version is 4.3 or
greater.

If an error is generated, no change is made to the contents of `params`.

Calling glGetQueryiv is equivalent to calling `glGetQueryIndexediv` with `index` set to
zero.
---
### Errors
`GL_INVALID_ENUM` is generated if `target` or `pname` is not an accepted value.

`GL_INVALID_VALUE` is generated if `index` is greater than or equal to the `target` -specific
maximum.
---
### Version Support
`glGetQueryIndexediv`
---
### See Also
glGetQueryObject, glIsQuery
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Return parameters of a query object
---
### Parameters
`id` Specifies the name of a query object.
`buffer` Specifies the name of a buffer object.
`pname` Specifies the symbolic name of a query object parameter. Accepted values are
`GL_QUERY_RESULT`, `GL_QUERY_RESULT_AVAILABLE`, `GL_QUERY_RESULT_NO_WAIT`, or
`GL_QUERY_TARGET`.

`params` If a buffer is bound to the `GL_QUERY_RESULT_BUFFER` target, then `params` is
treated as an offset to a location within that buffer's data store to receive the result of the
query. If no buffer is bound to `GL_QUERY_RESULT_BUFFER`, then `params` is treated as an address
in client memory of a variable to receive the resulting data.

`offset` Specifies the byte offset into `buffer` 's data store where the queried result will
be written.

---
### Description
These commands return a selected parameter of the query object specified by `id`.
`glGetQueryObject` returns in `params` a selected parameter of the query object specified by
`id`. `glGetQueryBufferObject` returns in `buffer` a selected parameter of the query object
specified by `id`, by writing it to `buffer` 's data store at the byte offset specified by
`offset`.

`pname` names a specific query object parameter. `pname` can be as follows:

`GL_QUERY_RESULT` `params` or `buffer` returns the value of the query object's passed
samples counter. The initial value is 0.

`GL_QUERY_RESULT_NO_WAIT` If the result of the query is available (that is, a query of
`GL_QUERY_RESULT_AVAILABLE` would return non-zero), then `params` or `buffer` returns the value
of the query object's passed samples counter, otherwise, the data referred to by `params` or
`buffer` is not modified. The initial value is 0.

`GL_QUERY_RESULT_AVAILABLE` `params` or `buffer` returns whether the passed samples counter
is immediately available. If a delay would occur waiting for the query result, `GL_FALSE` is
returned. Otherwise, `GL_TRUE` is returned, which also indicates that the results of all previous
queries are available as well.

`GL_QUERY_TARGET` `params` or `buffer` returns the query object's target.

---
### Notes
If an error is generated, no change is made to the contents of `params` or `buffer`.

`glGetQueryObject` and `glGetQueryBufferObject` implicitly flush the GL pipeline so that any
incomplete rendering delimited by the occlusion query completes in finite time.

If multiple queries are issued using the same query object `id` before calling
`glGetQueryObject` or `glGetQueryBufferObject`, the results of the most recent query will be
returned. In this case, when issuing a new query, the results of the previous query are discarded.

`glGetQueryObjecti64v` and `glGetQueryObjectui64v` are available only if the GL version is 3.3
or greater.

`GL_QUERY_RESULT_NO_WAIT` is accepted for `pname` only if the GL version is 4.4 or greater.

The `GL_QUERY_RESULT_BUFFER` target is available only if the GL version is 4.4 or higher. On
earlier versions of the GL, `params` is always an address in client memory.
---
### Errors
`GL_INVALID_ENUM` is generated if `pname` is not an accepted value.

`GL_INVALID_OPERATION` is generated if `id` is not the name of a query object.

`GL_INVALID_OPERATION` is generated by `glGetQueryBufferObject` if `buffer` is not the name
of an already created buffer object.

`GL_INVALID_OPERATION` is generated if `id` is the name of a currently active query object.

`GL_INVALID_OPERATION` is generated by `glGetQueryObject` if a buffer is currently bound to the
`GL_QUERY_RESULT_BUFFER` target and the command would cause data to be written beyond the bounds
of that buffer's data store.

`GL_INVALID_OPERATION` is generated by `glGetQueryBufferObject` if the command would cause data
to be written beyond the bounds of `buffer` 's data store.

`GL_INVALID_VALUE` is generated by `glGetQueryBufferObject` if `offset` is negative.
---
### Version Support
`glGetQueryObjecti64v` `glGetQueryObjectiv` `glGetQueryObjectui64v`
`glGetQueryObjectuiv` `glGetQueryBufferObjecti64v` `glGetQueryBufferObjectiv`
`glGetQueryBufferObjectui64v` `glGetQueryBufferObjectuiv`
---
### See Also
glBeginQuery, `glEndQuery`, glGetQueryiv, glIsQuery, glQueryCounter
---
### Copyright
Copyright 2005 Addison-Wesley. Copyright 2010-2014 Khronos Group. This material may be
distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8
June 1999. https://opencontent.org/openpub/.
]],
  [[Retrieve information about the set of active atomic counter buffers for a program
---
### Parameters
`program` The name of a program object from which to retrieve information.
`bufferIndex` Specifies index of an active atomic counter buffer.
`pname` Specifies which parameter of the atomic counter buffer to retrieve.
`params` Specifies the address of a variable into which to write the retrieved information.
---
### Description
`glGetActiveAtomicCounterBufferiv` retrieves information about the set of active atomic counter
buffers for a program object. `program` is the name of a program object for which the command
glLinkProgram has been issued in the past. It is not necessary for `program` to have been linked
successfully. The link may have failed because the number of active atomic counters exceeded the
limits.

`bufferIndex` specifies the index of an active atomic counter buffer and must be in the range
zero to the value of `GL_ACTIVE_ATOMIC_COUNTER_BUFFERS` minus one. The value of
`GL_ACTIVE_ATOMIC_COUNTER_BUFFERS` for `program` indicates the number of active atomic counter
buffer and can be queried with glGetProgram.

If no error occurs, the parameter(s) specified by `pname` are returned in `params`. If an
error is generated, the contents of `params` are not modified.

If `pname` is `GL_ATOMIC_COUNTER_BUFFER_BINDING`, then the index of the counter buffer binding
point associated with the active atomic counter buffer `bufferIndex` for `program` is returned.

If `pname` is `GL_ATOMIC_COUNTER_BUFFER_DATA_SIZE`, then the implementation-dependent minimum
total buffer object size, in baseic machine units, required to hold all active atomic counters in
the atomic counter binding point identified by `bufferIndex` is returned.

If `pname` is `GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS`, then the number of active
atomic counters for the atomic counter buffer identified by `bufferIndex` is returned.

If `pname` is `GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES`, then a list of the
active atomic counter indices for the atomic counter buffer identified by `bufferIndex` is
returned. The number of elements that will be written into `params` is the value of
`GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS` for `bufferIndex`.

If `pname` is `GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER`,
`GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER`,
`GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER`,
`GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER`,
`GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER`,
`GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER` then a boolean value indicating whether the
atomic counter buffer identified by `bufferIndex` is referenced by the vertex, tessellation
control, tessellation evaluation, geometry, fragment or compute processing stages of `program`,
respectively, is returned.
---
### Notes
`glGetActiveAtomicCounterBufferiv` is available only if the GL version is 4.2 or higher.

`GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER` is available only of the GL version is
4.3 or higher.
---
### Errors
`GL_INVALID_VALUE` is generated if `program` is not the name of a program object for which
glLinkProgram has been called in the past.

`GL_INVALID_VALUE` is generated if `bufferIndex` is greater than or equal to the value of
`GL_ACTIVE_ATOMIC_COUNTER_BUFFERS` for `program`.

`GL_INVALID_ENUM` is generated if `pname` is not one of the accepted tokens.
---
### Version Support
`glGetActiveAtomicCounterBufferiv`
---
### See Also
glGetProgram, glGetActiveSubroutineUniform, glGetActiveSubroutineUniformName,
glGetUniformLocation
---
### Copyright
Copyright 2011-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Returns information about an active attribute variable for the specified program object
---
### Parameters
`program` Specifies the program object to be queried.
`index` Specifies the index of the attribute variable to be queried.
`bufSize` Specifies the maximum number of characters OpenGL is allowed to write in the character
buffer indicated by `name`.

`length` Returns the number of characters actually written by OpenGL in the string indicated by
`name` (excluding the null terminator) if a value other than `NULL` is passed.

`size` Returns the size of the attribute variable.
`type` Returns the data type of the attribute variable.
`name` Returns a null terminated string containing the name of the attribute variable.
---
### Description
`glGetActiveAttrib` returns information about an active attribute variable in the program object
specified by `program`. The number of active attributes can be obtained by calling glGetProgram
with the value `GL_ACTIVE_ATTRIBUTES`. A value of 0 for `index` selects the first active
attribute variable. Permissible values for `index` range from zero to the number of active
attribute variables minus one.

A vertex shader may use either built-in attribute variables, user-defined attribute variables, or
both. Built-in attribute variables have a prefix of \\\"gl_\\\" and reference conventional OpenGL vertex
attribtes (e.g., `gl_Vertex`, `gl_Normal`, etc., see the OpenGL Shading Language specification
for a complete list.) User-defined attribute variables have arbitrary names and obtain their values
through numbered generic vertex attributes. An attribute variable (either built-in or user-defined)
is considered active if it is determined during the link operation that it may be accessed during
program execution. Therefore, `program` should have previously been the target of a call to
glLinkProgram, but it is not necessary for it to have been linked successfully.

The size of the character buffer required to store the longest attribute variable name in
`program` can be obtained by calling glGetProgram with the value
`GL_ACTIVE_ATTRIBUTE_MAX_LENGTH`. This value should be used to allocate a buffer of sufficient size
to store the returned attribute name. The size of this character buffer is passed in `bufSize`,
and a pointer to this character buffer is passed in `name`.

`glGetActiveAttrib` returns the name of the attribute variable indicated by `index`, storing it
in the character buffer specified by `name`. The string returned will be null terminated. The
actual number of characters written into this buffer is returned in `length`, and this count does
not include the null termination character. If the length of the returned string is not required, a
value of `NULL` can be passed in the `length` argument.

The `type` argument specifies a pointer to a variable into which the attribute variable's data
type will be written. The symbolic constants `GL_FLOAT`, `GL_FLOAT_VEC2`, `GL_FLOAT_VEC3`,
`GL_FLOAT_VEC4`, `GL_FLOAT_MAT2`, `GL_FLOAT_MAT3`, `GL_FLOAT_MAT4`, `GL_FLOAT_MAT2x3`,
`GL_FLOAT_MAT2x4`, `GL_FLOAT_MAT3x2`, `GL_FLOAT_MAT3x4`, `GL_FLOAT_MAT4x2`,
`GL_FLOAT_MAT4x3`, `GL_INT`, `GL_INT_VEC2`, `GL_INT_VEC3`, `GL_INT_VEC4`,
`GL_UNSIGNED_INT`, `GL_UNSIGNED_INT_VEC2`, `GL_UNSIGNED_INT_VEC3`, `GL_UNSIGNED_INT_VEC4`,
`GL_DOUBLE`, `GL_DOUBLE_VEC2`, `GL_DOUBLE_VEC3`, `GL_DOUBLE_VEC4`, `GL_DOUBLE_MAT2`,
`GL_DOUBLE_MAT3`, `GL_DOUBLE_MAT4`, `GL_DOUBLE_MAT2x3`, `GL_DOUBLE_MAT2x4`,
`GL_DOUBLE_MAT3x2`, `GL_DOUBLE_MAT3x4`, `GL_DOUBLE_MAT4x2`, or `GL_DOUBLE_MAT4x3` may be
returned. The `size` argument will return the size of the attribute, in units of the type returned
in `type`.

The list of active attribute variables may include both built-in attribute variables (which begin
with the prefix \\\"gl_\\\") as well as user-defined attribute variable names. This function will return
as much information as it can about the specified active attribute variable. If no information is
available, `length` will be 0, and `name` will be an empty string. This situation could occur if
this function is called after a link operation that failed. If an error occurs, the return values
`length`, `size`, `type`, and `name` will be unmodified.
---
### Errors
`GL_INVALID_VALUE` is generated if `program` is not a value generated by OpenGL.

`GL_INVALID_OPERATION` is generated if `program` is not a program object.

`GL_INVALID_VALUE` is generated if `index` is greater than or equal to the number of active
attribute variables in `program`.

`GL_INVALID_VALUE` is generated if `bufSize` is less than 0.
---
### Associated Gets
glGet with argument `GL_MAX_VERTEX_ATTRIBS`.

glGetProgram with argument `GL_ACTIVE_ATTRIBUTES` or `GL_ACTIVE_ATTRIBUTE_MAX_LENGTH`.

glIsProgram
---
### Version Support
`glGetActiveAttrib`
---
### See Also
glBindAttribLocation, glLinkProgram, glVertexAttrib, glVertexAttribPointer
---
### Copyright
Copyright 2003-2005 3Dlabs Inc. Ltd. Copyright 2010-2014 Khronos Group. This material may be
distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8
June 1999. https://opencontent.org/openpub/.
]],
  [[Query the name of an active shader subroutine
---
### Parameters
`program` Specifies the name of the program containing the subroutine.
`shadertype` Specifies the shader stage from which to query the subroutine name.
`index` Specifies the index of the shader subroutine uniform.
`bufSize` Specifies the size of the buffer whose address is given in `name`.

`length` Specifies the address of a variable which is to receive the length of the shader
subroutine uniform name.
`name` Specifies the address of an array into which the name of the shader subroutine uniform
will be written.
---
### Description
`glGetActiveSubroutineName` queries the name of an active shader subroutine uniform from the
program object given in `program`. `index` specifies the index of the shader subroutine uniform
within the shader stage given by `stage`, and must between zero and the value of
`GL_ACTIVE_SUBROUTINES` minus one for the shader stage.

The name of the selected subroutine is returned as a null-terminated string in `name`. The
actual number of characters written into `name`, not including the null-terminator, is returned in
`length`. If `length` is `NULL`, no length is returned. The maximum number of characters that
may be written into `name`, including the null-terminator, is given in `bufSize`.
---
### Errors
`GL_INVALID_VALUE` is generated if `index` is greater than or equal to the value of
`GL_ACTIVE_SUBROUTINES`.

`GL_INVALID_VALUE` is generated if `program` is not the name of an existing program object.
---
### Associated Gets
glGetProgramStage with argument `GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH`
---
### Version Support
`glGetActiveSubroutineName`
---
### See Also
glGetSubroutineIndex, glGetActiveSubroutineUniform, glGetProgramStage
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Query a property of an active shader subroutine uniform
---
### Parameters
`program` Specifies the name of the program containing the subroutine.
`shadertype` Specifies the shader stage from which to query for the subroutine parameter.
`shadertype` must be one of `GL_VERTEX_SHADER`, `GL_TESS_CONTROL_SHADER`,
`GL_TESS_EVALUATION_SHADER`, `GL_GEOMETRY_SHADER` or `GL_FRAGMENT_SHADER`.

`index` Specifies the index of the shader subroutine uniform.
`pname` Specifies the parameter of the shader subroutine uniform to query. `pname` must be
`GL_NUM_COMPATIBLE_SUBROUTINES`, `GL_COMPATIBLE_SUBROUTINES`, `GL_UNIFORM_SIZE` or
`GL_UNIFORM_NAME_LENGTH`.

`values` Specifies the address of a into which the queried value or values will be placed.
---
### Description
`glGetActiveSubroutineUniform` queries a parameter of an active shader subroutine uniform.
`program` contains the name of the program containing the uniform. `shadertype` specifies the
stage which the uniform location, given by `index`, is valid. `index` must be between zero and
the value of `GL_ACTIVE_SUBROUTINE_UNIFORMS` minus one for the shader stage.

If `pname` is `GL_NUM_COMPATIBLE_SUBROUTINES`, a single integer indicating the number of
subroutines that can be assigned to the uniform is returned in `values`.

If `pname` is `GL_COMPATIBLE_SUBROUTINES`, an array of integers is returned in `values`,
with each integer specifying the index of an active subroutine that can be assigned to the selected
subroutine uniform. The number of integers returned is the same as the value returned for
`GL_NUM_COMPATIBLE_SUBROUTINES`.

If `pname` is `GL_UNIFORM_SIZE`, a single integer is returned in `values`. If the selected
subroutine uniform is an array, the declared size of the array is returned; otherwise, one is
returned.

If `pname` is `GL_UNIFORM_NAME_LENGTH`, a single integer specifying the length of the
subroutine uniform name (including the terminating null character) is returned in `values`.
---
### Errors
`GL_INVALID_ENUM` is generated if `shadertype` or `pname` is not one of the accepted values.

`GL_INVALID_VALUE` is generated if `index` is greater than or equal to the value of
`GL_ACTIVE_SUBROUTINES`.

`GL_INVALID_VALUE` is generated if `program` is not the name of an existing program object.
---
### Associated Gets
glGetProgramStage with argument `GL_ACTIVE_SUBROUTINE_UNIFORMS`
---
### Version Support
`glGetActiveSubroutineUniformiv`
---
### See Also
glGetSubroutineIndex, glGetActiveSubroutineUniformName, glGetProgramStage
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Query the name of an active shader subroutine uniform
---
### Parameters
`program` Specifies the name of the program containing the subroutine.
`shadertype` Specifies the shader stage from which to query for the subroutine parameter.
`shadertype` must be one of `GL_VERTEX_SHADER`, `GL_TESS_CONTROL_SHADER`,
`GL_TESS_EVALUATION_SHADER`, `GL_GEOMETRY_SHADER` or `GL_FRAGMENT_SHADER`.

`index` Specifies the index of the shader subroutine uniform.
`bufSize` Specifies the size of the buffer whose address is given in `name`.

`length` Specifies the address of a variable into which is written the number of characters
copied into `name`.

`name` Specifies the address of a buffer that will receive the name of the specified shader
subroutine uniform.
---
### Description
`glGetActiveSubroutineUniformName` retrieves the name of an active shader subroutine uniform.
`program` contains the name of the program containing the uniform. `shadertype` specifies the
stage for which the uniform location, given by `index`, is valid. `index` must be between zero
and the value of `GL_ACTIVE_SUBROUTINE_UNIFORMS` minus one for the shader stage.

The uniform name is returned as a null-terminated string in `name`. The actual number of
characters written into `name`, excluding the null terminator is returned in `length`. If
`length` is `NULL`, no length is returned. The maximum number of characters that may be written
into `name`, including the null terminator, is specified by `bufSize`. The length of the longest
subroutine uniform name in `program` and `shadertype` is given by the value of
`GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH`, which can be queried with glGetProgramStage.
---
### Errors
`GL_INVALID_ENUM` is generated if `shadertype` or `pname` is not one of the accepted values.

`GL_INVALID_VALUE` is generated if `index` is greater than or equal to the value of
`GL_ACTIVE_SUBROUTINE_UNIFORMS`.

`GL_INVALID_VALUE` is generated if `program` is not the name of an existing program object.
---
### Associated Gets
glGetProgramStage with argument `GL_ACTIVE_SUBROUTINE_UNIFORMS`
---
### Version Support
`glGetActiveSubroutineUniformName`
---
### See Also
glGetSubroutineIndex, glGetActiveSubroutineUniform, glGetProgramStage
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Returns information about an active uniform variable for the specified program object
---
### Parameters
`program` Specifies the program object to be queried.
`index` Specifies the index of the uniform variable to be queried.
`bufSize` Specifies the maximum number of characters OpenGL is allowed to write in the character
buffer indicated by `name`.

`length` Returns the number of characters actually written by OpenGL in the string indicated by
`name` (excluding the null terminator) if a value other than `NULL` is passed.

`size` Returns the size of the uniform variable.
`type` Returns the data type of the uniform variable.
`name` Returns a null terminated string containing the name of the uniform variable.
---
### Description
`glGetActiveUniform` returns information about an active uniform variable in the program object
specified by `program`. The number of active uniform variables can be obtained by calling
glGetProgram with the value `GL_ACTIVE_UNIFORMS`. A value of 0 for `index` selects the first
active uniform variable. Permissible values for `index` range from zero to the number of active
uniform variables minus one.

Shaders may use either built-in uniform variables, user-defined uniform variables, or both.

Built-in uniform variables have a prefix of \\\"gl_\\\" and reference existing OpenGL state or values
derived from such state (e.g., `gl_DepthRangeParameters`, see the OpenGL Shading Language
specification for a complete list.) User-defined uniform variables have arbitrary names and obtain
their values from the application through calls to glUniform. A uniform variable (either built-in
or user-defined) is considered active if it is determined during the link operation that it may be
accessed during program execution. Therefore, `program` should have previously been the target of
a call to glLinkProgram, but it is not necessary for it to have been linked successfully.

The size of the character buffer required to store the longest uniform variable name in `program`
can be obtained by calling glGetProgram with the value `GL_ACTIVE_UNIFORM_MAX_LENGTH`. This
value should be used to allocate a buffer of sufficient size to store the returned uniform variable
name. The size of this character buffer is passed in `bufSize`, and a pointer to this character
buffer is passed in `name.`

`glGetActiveUniform` returns the name of the uniform variable indicated by `index`, storing it
in the character buffer specified by `name`. The string returned will be null terminated. The
actual number of characters written into this buffer is returned in `length`, and this count does
not include the null termination character. If the length of the returned string is not required, a
value of `NULL` can be passed in the `length` argument.

The `type` argument will return a pointer to the uniform variable's data type. The symbolic
constants returned for uniform types are shown in the table below. Returned Symbolic
Contant Shader Uniform Type `GL_FLOAT` `float` `GL_FLOAT_VEC2` `vec2` `GL_FLOAT_VEC3`
`vec3` `GL_FLOAT_VEC4` `vec4` `GL_DOUBLE` `double` `GL_DOUBLE_VEC2` `dvec2`
`GL_DOUBLE_VEC3` `dvec3` `GL_DOUBLE_VEC4` `dvec4` `GL_INT` `int` `GL_INT_VEC2` `ivec2`
`GL_INT_VEC3` `ivec3` `GL_INT_VEC4` `ivec4` `GL_UNSIGNED_INT` `unsigned int`
`GL_UNSIGNED_INT_VEC2` `uvec2` `GL_UNSIGNED_INT_VEC3` `uvec3` `GL_UNSIGNED_INT_VEC4` `uvec4`
`GL_BOOL` `bool` `GL_BOOL_VEC2` `bvec2` `GL_BOOL_VEC3` `bvec3` `GL_BOOL_VEC4` `bvec4`
`GL_FLOAT_MAT2` `mat2` `GL_FLOAT_MAT3` `mat3` `GL_FLOAT_MAT4` `mat4` `GL_FLOAT_MAT2x3`
`mat2x3` `GL_FLOAT_MAT2x4` `mat2x4` `GL_FLOAT_MAT3x2` `mat3x2` `GL_FLOAT_MAT3x4` `mat3x4`
`GL_FLOAT_MAT4x2` `mat4x2` `GL_FLOAT_MAT4x3` `mat4x3` `GL_DOUBLE_MAT2` `dmat2`
`GL_DOUBLE_MAT3` `dmat3` `GL_DOUBLE_MAT4` `dmat4` `GL_DOUBLE_MAT2x3` `dmat2x3`
`GL_DOUBLE_MAT2x4` `dmat2x4` `GL_DOUBLE_MAT3x2` `dmat3x2` `GL_DOUBLE_MAT3x4` `dmat3x4`
`GL_DOUBLE_MAT4x2` `dmat4x2` `GL_DOUBLE_MAT4x3` `dmat4x3` `GL_SAMPLER_1D` `sampler1D`
`GL_SAMPLER_2D` `sampler2D` `GL_SAMPLER_3D` `sampler3D` `GL_SAMPLER_CUBE` `samplerCube`
`GL_SAMPLER_1D_SHADOW` `sampler1DShadow` `GL_SAMPLER_2D_SHADOW` `sampler2DShadow`
`GL_SAMPLER_1D_ARRAY` `sampler1DArray` `GL_SAMPLER_2D_ARRAY` `sampler2DArray`
`GL_SAMPLER_1D_ARRAY_SHADOW` `sampler1DArrayShadow` `GL_SAMPLER_2D_ARRAY_SHADOW`
`sampler2DArrayShadow` `GL_SAMPLER_2D_MULTISAMPLE` `sampler2DMS`
`GL_SAMPLER_2D_MULTISAMPLE_ARRAY` `sampler2DMSArray` `GL_SAMPLER_CUBE_SHADOW`
`samplerCubeShadow` `GL_SAMPLER_BUFFER` `samplerBuffer` `GL_SAMPLER_2D_RECT` `sampler2DRect`
`GL_SAMPLER_2D_RECT_SHADOW` `sampler2DRectShadow` `GL_INT_SAMPLER_1D` `isampler1D`
`GL_INT_SAMPLER_2D` `isampler2D` `GL_INT_SAMPLER_3D` `isampler3D` `GL_INT_SAMPLER_CUBE`
`isamplerCube` `GL_INT_SAMPLER_1D_ARRAY` `isampler1DArray` `GL_INT_SAMPLER_2D_ARRAY`
`isampler2DArray` `GL_INT_SAMPLER_2D_MULTISAMPLE` `isampler2DMS`
`GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY` `isampler2DMSArray` `GL_INT_SAMPLER_BUFFER`
`isamplerBuffer` `GL_INT_SAMPLER_2D_RECT` `isampler2DRect` `GL_UNSIGNED_INT_SAMPLER_1D`
`usampler1D` `GL_UNSIGNED_INT_SAMPLER_2D` `usampler2D` `GL_UNSIGNED_INT_SAMPLER_3D`
`usampler3D` `GL_UNSIGNED_INT_SAMPLER_CUBE` `usamplerCube` `GL_UNSIGNED_INT_SAMPLER_1D_ARRAY`
`usampler2DArray` `GL_UNSIGNED_INT_SAMPLER_2D_ARRAY` `usampler2DArray`
`GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE` `usampler2DMS`
`GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY` `usampler2DMSArray`
`GL_UNSIGNED_INT_SAMPLER_BUFFER` `usamplerBuffer` `GL_UNSIGNED_INT_SAMPLER_2D_RECT`
`usampler2DRect` `GL_IMAGE_1D` `image1D` `GL_IMAGE_2D` `image2D` `GL_IMAGE_3D` `image3D`
`GL_IMAGE_2D_RECT` `image2DRect` `GL_IMAGE_CUBE` `imageCube` `GL_IMAGE_BUFFER` `imageBuffer`
`GL_IMAGE_1D_ARRAY` `image1DArray` `GL_IMAGE_2D_ARRAY` `image2DArray`
`GL_IMAGE_2D_MULTISAMPLE` `image2DMS` `GL_IMAGE_2D_MULTISAMPLE_ARRAY` `image2DMSArray`
`GL_INT_IMAGE_1D` `iimage1D` `GL_INT_IMAGE_2D` `iimage2D` `GL_INT_IMAGE_3D` `iimage3D`
`GL_INT_IMAGE_2D_RECT` `iimage2DRect` `GL_INT_IMAGE_CUBE` `iimageCube` `GL_INT_IMAGE_BUFFER`
`iimageBuffer` `GL_INT_IMAGE_1D_ARRAY` `iimage1DArray` `GL_INT_IMAGE_2D_ARRAY` `iimage2DArray`
`GL_INT_IMAGE_2D_MULTISAMPLE` `iimage2DMS` `GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY`
`iimage2DMSArray` `GL_UNSIGNED_INT_IMAGE_1D` `uimage1D` `GL_UNSIGNED_INT_IMAGE_2D` `uimage2D`
`GL_UNSIGNED_INT_IMAGE_3D` `uimage3D` `GL_UNSIGNED_INT_IMAGE_2D_RECT` `uimage2DRect`
`GL_UNSIGNED_INT_IMAGE_CUBE` `uimageCube` `GL_UNSIGNED_INT_IMAGE_BUFFER` `uimageBuffer`
`GL_UNSIGNED_INT_IMAGE_1D_ARRAY` `uimage1DArray` `GL_UNSIGNED_INT_IMAGE_2D_ARRAY`
`uimage2DArray` `GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE` `uimage2DMS`
`GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY` `uimage2DMSArray` `GL_UNSIGNED_INT_ATOMIC_COUNTER`
`atomic_uint`

If one or more elements of an array are active, the name of the array is returned in `name`, the
type is returned in `type`, and the `size` parameter returns the highest array element index
used, plus one, as determined by the compiler and/or linker. Only one active uniform variable will
be reported for a uniform array.

Uniform variables that are declared as structures or arrays of structures will not be returned
directly by this function. Instead, each of these uniform variables will be reduced to its
fundamental components containing the \\\".\\\" and \\\"[]\\\" operators such that each of the names is valid as
an argument to glGetUniformLocation. Each of these reduced uniform variables is counted as one
active uniform variable and is assigned an index. A valid name cannot be a structure, an array of
structures, or a subcomponent of a vector or matrix.

The size of the uniform variable will be returned in `size`. Uniform variables other than arrays
will have a size of 1. Structures and arrays of structures will be reduced as described earlier,
such that each of the names returned will be a data type in the earlier list. If this reduction
results in an array, the size returned will be as described for uniform arrays; otherwise, the size
returned will be 1.

The list of active uniform variables may include both built-in uniform variables (which begin with
the prefix \\\"gl_\\\") as well as user-defined uniform variable names. This function will return as much
information as it can about the specified active uniform variable. If no information is available,
`length` will be 0, and `name` will be an empty string. This situation could occur if this
function is called after a link operation that failed. If an error occurs, the return values
`length`, `size`, `type`, and `name` will be unmodified.
---
### Notes
The double types, `GL_DOUBLE`, `GL_DOUBLE_VEC2`, `GL_DOUBLE_VEC3`, `GL_DOUBLE_VEC4`,
`GL_DOUBLE_MAT2`, `GL_DOUBLE_MAT3`, `GL_DOUBLE_MAT4`, `GL_DOUBLE_MAT2x3`, `GL_DOUBLE_MAT2x4`,
`GL_DOUBLE_MAT3x2`, `GL_DOUBLE_MAT3x4`, `GL_DOUBLE_MAT4x2`, and `GL_DOUBLE_MAT4x3` are
only available if the GL version is 4.1 or higher.

The image types, `GL_IMAGE_1D`, `GL_IMAGE_2D`, `GL_IMAGE_3D`, `GL_IMAGE_2D_RECT`,
`GL_IMAGE_CUBE`, `GL_IMAGE_BUFFER`, `GL_IMAGE_1D_ARRAY`, `GL_IMAGE_2D_ARRAY`,
`GL_IMAGE_2D_MULTISAMPLE`, `GL_IMAGE_2D_MULTISAMPLE_ARRAY`, `GL_INT_IMAGE_1D`,
`GL_INT_IMAGE_2D`, `GL_INT_IMAGE_3D`, `GL_INT_IMAGE_2D_RECT`, `GL_INT_IMAGE_CUBE`,
`GL_INT_IMAGE_BUFFER`, `GL_INT_IMAGE_1D_ARRAY`, `GL_INT_IMAGE_2D_ARRAY`,
`GL_INT_IMAGE_2D_MULTISAMPLE`, `GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY`, `GL_UNSIGNED_INT_IMAGE_1D`,
`GL_UNSIGNED_INT_IMAGE_2D`, `GL_UNSIGNED_INT_IMAGE_3D`, `GL_UNSIGNED_INT_IMAGE_2D_RECT`,
`GL_UNSIGNED_INT_IMAGE_CUBE`, `GL_UNSIGNED_INT_IMAGE_BUFFER`, `GL_UNSIGNED_INT_IMAGE_1D_ARRAY`,
`GL_UNSIGNED_INT_IMAGE_2D_ARRAY`, `GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE`,
`GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY`, and the atomic counter type,
`GL_UNSIGNED_INT_ATOMIC_COUNTER` are only available if the GL version is 4.2 or higher.
---
### Errors
`GL_INVALID_VALUE` is generated if `program` is not a value generated by OpenGL.

`GL_INVALID_OPERATION` is generated if `program` is not a program object.

`GL_INVALID_VALUE` is generated if `index` is greater than or equal to the number of active
uniform variables in `program`.

`GL_INVALID_VALUE` is generated if `bufSize` is less than 0.
---
### Associated Gets
glGet with argument `GL_MAX_VERTEX_UNIFORM_COMPONENTS`, `GL_MAX_GEOMETRY_UNIFORM_COMPONENTS`,
`GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS`, `GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS`,
`GL_MAX_FRAGMENT_UNIFORM_COMPONENTS`.

glGetProgram with argument `GL_ACTIVE_UNIFORMS` or `GL_ACTIVE_UNIFORM_MAX_LENGTH`.

glIsProgram
---
### Version Support
`glGetActiveUniform`
---
### See Also
glGetUniform, glGetUniformLocation, glLinkProgram, glUniform, glUseProgram
---
### Copyright
Copyright 2003-2005 3Dlabs Inc. Ltd. Copyright 2010-2014 Khronos Group This material may be
distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8
June 1999. https://opencontent.org/openpub/.
]],
  [[Query information about an active uniform block
---
### Parameters
`program` Specifies the name of a program containing the uniform block.
`uniformBlockIndex` Specifies the index of the uniform block within `program`.

`pname` Specifies the name of the parameter to query.
`params` Specifies the address of a variable to receive the result of the query.
---
### Description
`glGetActiveUniformBlockiv` retrieves information about an active uniform block within `program`.

`program` must be the name of a program object for which the command glLinkProgram must have
been called in the past, although it is not required that glLinkProgram must have succeeded. The
link could have failed because the number of active uniforms exceeded the limit.

`uniformBlockIndex` is an active uniform block index of `program`, and must be less than the
value of `GL_ACTIVE_UNIFORM_BLOCKS`.

Upon success, the uniform block parameter(s) specified by `pname` are returned in `params`. If
an error occurs, nothing will be written to `params`.

If `pname` is `GL_UNIFORM_BLOCK_BINDING`, then the index of the uniform buffer binding point
last selected by the uniform block specified by `uniformBlockIndex` for `program` is returned.

If no uniform block has been previously specified, zero is returned.

If `pname` is `GL_UNIFORM_BLOCK_DATA_SIZE`, then the implementation-dependent minimum total
buffer object size, in basic machine units, required to hold all active uniforms in the uniform
block identified by `uniformBlockIndex` is returned. It is neither guaranteed nor expected that a
given implementation will arrange uniform values as tightly packed in a buffer object. The exception
to this is the std140 uniform block layout, which guarantees specific packing behavior and does
not require the application to query for offsets and strides. In this case the minimum size may
still be queried, even though it is determined in advance based only on the uniform block
declaration.

If `pname` is `GL_UNIFORM_BLOCK_NAME_LENGTH`, then the total length (including the nul
terminator) of the name of the uniform block identified by `uniformBlockIndex` is returned.

If `pname` is `GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS`, then the number of active uniforms in the
uniform block identified by `uniformBlockIndex` is returned.

If `pname` is `GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES`, then a list of the active uniform
indices for the uniform block identified by `uniformBlockIndex` is returned. The number of
elements that will be written to `params` is the value of `GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS` for
`uniformBlockIndex`.

If `pname` is `GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER`,
`GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER`,
`GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER`,
`GL_UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER`, `GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER`,
or `GL_UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER` then a boolean value indicating whether the
uniform block identified by `uniformBlockIndex` is referenced by the vertex, tessellation control,
tessellation evaluation, geometry, fragment or compute programming stages of program, respectively,
is returned.
---
### Errors
`GL_INVALID_VALUE` is generated if `uniformBlockIndex` is greater than or equal to the value of
`GL_ACTIVE_UNIFORM_BLOCKS` or is not the index of an active uniform block in `program`.

`GL_INVALID_ENUM` is generated if `pname` is not one of the accepted tokens.

`GL_INVALID_OPERATION` is generated if `program` is not the name of a program object for which
glLinkProgram has been called in the past.
---
### Notes
`glGetActiveUniformBlockiv` is available only if the GL version is 3.1 or greater.

`GL_UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER` is accepted only if the GL version is 4.3 or
greater.
---
### Version Support
`glGetActiveUniformBlockiv`
---
### See Also
glGetActiveUniformBlockName, glGetUniformBlockIndex, glLinkProgram
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Retrieve the name of an active uniform block
---
### Parameters
`program` Specifies the name of a program containing the uniform block.
`uniformBlockIndex` Specifies the index of the uniform block within `program`.

`bufSize` Specifies the size of the buffer addressed by `uniformBlockName`.

`length` Specifies the address of a variable to receive the number of characters that were
written to `uniformBlockName`.

`uniformBlockName` Specifies the address an array of characters to receive the name of the
uniform block at `uniformBlockIndex`.

---
### Description
`glGetActiveUniformBlockName` retrieves the name of the active uniform block at
`uniformBlockIndex` within `program`.

`program` must be the name of a program object for which the command glLinkProgram must have
been called in the past, although it is not required that glLinkProgram must have succeeded. The
link could have failed because the number of active uniforms exceeded the limit.

`uniformBlockIndex` is an active uniform block index of `program`, and must be less than the
value of `GL_ACTIVE_UNIFORM_BLOCKS`.

Upon success, the name of the uniform block identified by `unifomBlockIndex` is returned into
`uniformBlockName`. The name is nul-terminated. The actual number of characters written into
`uniformBlockName`, excluding the nul terminator, is returned in `length`. If `length` is NULL,
no length is returned.

`bufSize` contains the maximum number of characters (including the nul terminator) that will be
written into `uniformBlockName`.

If an error occurs, nothing will be written to `uniformBlockName` or `length`.
---
### Errors
`GL_INVALID_OPERATION` is generated if `program` is not the name of a program object for which
glLinkProgram has been called in the past.

`GL_INVALID_VALUE` is generated if `uniformBlockIndex` is greater than or equal to the value of
`GL_ACTIVE_UNIFORM_BLOCKS` or is not the index of an active uniform block in `program`.
---
### Notes
`glGetActiveUniformBlockName` is available only if the GL version is 3.1 or greater.
---
### Version Support
`glGetActiveUniformBlockName`
---
### See Also
glGetActiveUniformBlock, glGetUniformBlockIndex
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Query the name of an active uniform
---
### Parameters
`program` Specifies the program containing the active uniform index `uniformIndex`.

`uniformIndex` Specifies the index of the active uniform whose name to query.
`bufSize` Specifies the size of the buffer, in units of GLchar, of the buffer whose address
is specified in `uniformName`.

`length` Specifies the address of a variable that will receive the number of characters that
were or would have been written to the buffer addressed by `uniformName`.

`uniformName` Specifies the address of a buffer into which the GL will place the name of the
active uniform at `uniformIndex` within `program`.

---
### Description
`glGetActiveUniformName` returns the name of the active uniform at `uniformIndex` within
`program`. If `uniformName` is not NULL, up to `bufSize` characters (including a
nul-terminator) will be written into the array whose address is specified by `uniformName`. If
`length` is not NULL, the number of characters that were (or would have been) written into
`uniformName` (not including the nul-terminator) will be placed in the variable whose address is
specified in `length`. If `length` is NULL, no length is returned. The length of the longest
uniform name in `program` is given by the value of `GL_ACTIVE_UNIFORM_MAX_LENGTH`, which can be
queried with glGetProgram.

If `glGetActiveUniformName` is not successful, nothing is written to `length` or
`uniformName`.

`program` must be the name of a program for which the command glLinkProgram has been issued in
the past. It is not necessary for `program` to have been linked successfully. The link could have
failed because the number of active uniforms exceeded the limit.

`uniformIndex` must be an active uniform index of the program `program`, in the range zero to
the value of `GL_ACTIVE_UNIFORMS` minus one. The value of `GL_ACTIVE_UNIFORMS` can be queried
with glGetProgram.
---
### Errors
`GL_INVALID_VALUE` is generated if `uniformIndex` is greater than or equal to the value of
`GL_ACTIVE_UNIFORMS`.

`GL_INVALID_VALUE` is generated if `bufSize` is negative.

`GL_INVALID_VALUE` is generated if `program` is not the name of a program object for which
glLinkProgram has been issued.
---
### Version Support
`glGetActiveUniformName`
---
### See Also
glGetActiveUniform, glGetUniformIndices, glGetProgram, glLinkProgram
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Returns information about several active uniform variables for the specified program object
---
### Parameters
`program` Specifies the program object to be queried.
`uniformCount` Specifies both the number of elements in the array of indices `uniformIndices`
and the number of parameters written to `params` upon successful return.

`uniformIndices` Specifies the address of an array of `uniformCount` integers containing the
indices of uniforms within `program` whose parameter `pname` should be queried.

`pname` Specifies the property of each uniform in `uniformIndices` that should be written into
the corresponding element of `params`.

`params` Specifies the address of an array of `uniformCount` integers which are to receive the
value of `pname` for each uniform in `uniformIndices`.

---
### Description
`glGetActiveUniformsiv` queries the value of the parameter named `pname` for each of the
uniforms within `program` whose indices are specified in the array of `uniformCount` unsigned
integers `uniformIndices`. Upon success, the value of the parameter for each uniform is written
into the corresponding entry in the array whose address is given in `params`. If an error is
generated, nothing is written into `params`.

If `pname` is `GL_UNIFORM_TYPE`, then an array identifying the types of uniforms specified by
the corresponding array of `uniformIndices` is returned. The returned types can be any of the
values from the following table: Returned Symbolic Contant Shader Uniform Type
`GL_FLOAT` `float` `GL_FLOAT_VEC2` `vec2` `GL_FLOAT_VEC3` `vec3` `GL_FLOAT_VEC4` `vec4`
`GL_DOUBLE` `double` `GL_DOUBLE_VEC2` `dvec2` `GL_DOUBLE_VEC3` `dvec3` `GL_DOUBLE_VEC4`
`dvec4` `GL_INT` `int` `GL_INT_VEC2` `ivec2` `GL_INT_VEC3` `ivec3` `GL_INT_VEC4` `ivec4`
`GL_UNSIGNED_INT` `unsigned int` `GL_UNSIGNED_INT_VEC2` `uvec2` `GL_UNSIGNED_INT_VEC3`
`uvec3` `GL_UNSIGNED_INT_VEC4` `uvec4` `GL_BOOL` `bool` `GL_BOOL_VEC2` `bvec2`
`GL_BOOL_VEC3` `bvec3` `GL_BOOL_VEC4` `bvec4` `GL_FLOAT_MAT2` `mat2` `GL_FLOAT_MAT3`
`mat3` `GL_FLOAT_MAT4` `mat4` `GL_FLOAT_MAT2x3` `mat2x3` `GL_FLOAT_MAT2x4` `mat2x4`
`GL_FLOAT_MAT3x2` `mat3x2` `GL_FLOAT_MAT3x4` `mat3x4` `GL_FLOAT_MAT4x2` `mat4x2`
`GL_FLOAT_MAT4x3` `mat4x3` `GL_DOUBLE_MAT2` `dmat2` `GL_DOUBLE_MAT3` `dmat3`
`GL_DOUBLE_MAT4` `dmat4` `GL_DOUBLE_MAT2x3` `dmat2x3` `GL_DOUBLE_MAT2x4` `dmat2x4`
`GL_DOUBLE_MAT3x2` `dmat3x2` `GL_DOUBLE_MAT3x4` `dmat3x4` `GL_DOUBLE_MAT4x2` `dmat4x2`
`GL_DOUBLE_MAT4x3` `dmat4x3` `GL_SAMPLER_1D` `sampler1D` `GL_SAMPLER_2D` `sampler2D`
`GL_SAMPLER_3D` `sampler3D` `GL_SAMPLER_CUBE` `samplerCube` `GL_SAMPLER_1D_SHADOW`
`sampler1DShadow` `GL_SAMPLER_2D_SHADOW` `sampler2DShadow` `GL_SAMPLER_1D_ARRAY`
`sampler1DArray` `GL_SAMPLER_2D_ARRAY` `sampler2DArray` `GL_SAMPLER_1D_ARRAY_SHADOW`
`sampler1DArrayShadow` `GL_SAMPLER_2D_ARRAY_SHADOW` `sampler2DArrayShadow`
`GL_SAMPLER_2D_MULTISAMPLE` `sampler2DMS` `GL_SAMPLER_2D_MULTISAMPLE_ARRAY` `sampler2DMSArray`
`GL_SAMPLER_CUBE_SHADOW` `samplerCubeShadow` `GL_SAMPLER_BUFFER` `samplerBuffer`
`GL_SAMPLER_2D_RECT` `sampler2DRect` `GL_SAMPLER_2D_RECT_SHADOW` `sampler2DRectShadow`
`GL_INT_SAMPLER_1D` `isampler1D` `GL_INT_SAMPLER_2D` `isampler2D` `GL_INT_SAMPLER_3D`
`isampler3D` `GL_INT_SAMPLER_CUBE` `isamplerCube` `GL_INT_SAMPLER_1D_ARRAY` `isampler1DArray`
`GL_INT_SAMPLER_2D_ARRAY` `isampler2DArray` `GL_INT_SAMPLER_2D_MULTISAMPLE` `isampler2DMS`
`GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY` `isampler2DMSArray` `GL_INT_SAMPLER_BUFFER`
`isamplerBuffer` `GL_INT_SAMPLER_2D_RECT` `isampler2DRect` `GL_UNSIGNED_INT_SAMPLER_1D`
`usampler1D` `GL_UNSIGNED_INT_SAMPLER_2D` `usampler2D` `GL_UNSIGNED_INT_SAMPLER_3D`
`usampler3D` `GL_UNSIGNED_INT_SAMPLER_CUBE` `usamplerCube` `GL_UNSIGNED_INT_SAMPLER_1D_ARRAY`
`usampler2DArray` `GL_UNSIGNED_INT_SAMPLER_2D_ARRAY` `usampler2DArray`
`GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE` `usampler2DMS`
`GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY` `usampler2DMSArray`
`GL_UNSIGNED_INT_SAMPLER_BUFFER` `usamplerBuffer` `GL_UNSIGNED_INT_SAMPLER_2D_RECT`
`usampler2DRect`

If `pname` is `GL_UNIFORM_SIZE`, then an array identifying the size of the uniforms specified
by the corresponding array of `uniformIndices` is returned. The sizes returned are in units of the
type returned by a query of `GL_UNIFORM_TYPE`. For active uniforms that are arrays, the size is
the number of active elements in the array; for all other uniforms, the size is one.

If `pname` is `GL_UNIFORM_NAME_LENGTH`, then an array identifying the length, including the
terminating null character, of the uniform name strings specified by the corresponding array of
`uniformIndices` is returned.

If `pname` is `GL_UNIFORM_BLOCK_INDEX`, then an array identifying the uniform block index of
each of the uniforms specified by the corresponding array of `uniformIndices` is returned. The
uniform block index of a uniform associated with the default uniform block is -1.

If `pname` is `GL_UNIFORM_OFFSET`, then an array of uniform buffer offsets is returned. For
uniforms in a named uniform block, the returned value will be its offset, in basic machine units,
relative to the beginning of the uniform block in the buffer object data store. For atomic counter
uniforms, the returned value will be its offset relative to the beginning of its active atomic
counter buffer. For all other uniforms, -1 will be returned.

If `pname` is `GL_UNIFORM_ARRAY_STRIDE`, then an array identifying the stride between elements
of each of the uniforms specified by the corresponding array of `uniformIndices` is returned. For
uniforms in named uniform blocks and for uniforms declared as atomic counters, the stride is the
difference, in basic machine units, of consecutive elements in an array, or zero for uniforms not
declared as an array. For all other uniforms, a stride of -1 will be returned.

If `pname` is `GL_UNIFORM_MATRIX_STRIDE`, then an array identifying the stride between columns
of a column-major matrix or rows of a row-major matrix, in basic machine units, of each of the
uniforms specified by the corresponding array of `uniformIndices` is returned. The matrix stride
of a uniform associated with the default uniform block is -1. Note that this information only makes
sense for uniforms that are matrices. For uniforms that are not matrices, but are declared in a
named uniform block, a matrix stride of zero is returned.

If `pname` is `GL_UNIFORM_IS_ROW_MAJOR`, then an array identifying whether each of the
uniforms specified by the corresponding array of `uniformIndices` is a row-major matrix or not is
returned. A value of one indicates a row-major matrix, and a value of zero indicates a column-major
matrix, a matrix in the default uniform block, or a non-matrix.

If `pname` is `GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX`, then an array identifying the active
atomic counter buffer index of each of the uniforms specified by the corresponding array of
`uniformIndices` is returned. For uniforms other than atomic counters, the returned buffer index is
-1. The returned indices may be passed to glGetActiveAtomicCounterBufferiv to query the
properties of the associated buffer, and not necessarily the binding point specified in the uniform
declaration.
---
### Notes
The double types, `GL_DOUBLE`, `GL_DOUBLE_VEC2`, `GL_DOUBLE_VEC3`, `GL_DOUBLE_VEC4`,
`GL_DOUBLE_MAT2`, `GL_DOUBLE_MAT3`, `GL_DOUBLE_MAT4`, `GL_DOUBLE_MAT2x3`, `GL_DOUBLE_MAT2x4`,
`GL_DOUBLE_MAT3x2`, `GL_DOUBLE_MAT3x4`, `GL_DOUBLE_MAT4x2`, and `GL_DOUBLE_MAT4x3` are
only available if the GL version is 4.1 or higher.

`GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX` is only accepted by `pname` if the GL version is 4.2
or higher.
---
### Errors
`GL_INVALID_VALUE` is generated if `program` is not a value generated by OpenGL.

`GL_INVALID_OPERATION` is generated if `program` is not a program object.

`GL_INVALID_VALUE` is generated if `uniformCount` is greater than or equal to the value of
`GL_ACTIVE_UNIFORMS` for `program`.

`GL_INVALID_ENUM` is generated if `pname` is not an accepted token.
---
### Associated Gets
glGet with argument `GL_MAX_VERTEX_UNIFORM_COMPONENTS`,
`GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS`, `GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS`,
`GL_MAX_GEOMETRY_UNIFORM_COMPONENTS`, `GL_MAX_FRAGMENT_UNIFORM_COMPONENTS`, or
`GL_MAX_COMBINED_UNIFORM_COMPONENTS`.

glGetProgram with argument `GL_ACTIVE_UNIFORMS` or `GL_ACTIVE_UNIFORM_MAX_LENGTH`.

glIsProgram
---
### Version Support
`glGetActiveUniformsiv`
---
### See Also
glGetUniform, glGetActiveUniform, glGetUniformLocation, glLinkProgram, glUniform,
glUseProgram
---
### Copyright
Copyright 2011-2014 Khronos Group This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Returns the handles of the shader objects attached to a program object
---
### Parameters
`program` Specifies the program object to be queried.
`maxCount` Specifies the size of the array for storing the returned object names.
`count` Returns the number of names actually returned in `shaders`.

`shaders` Specifies an array that is used to return the names of attached shader objects.
---
### Description
`glGetAttachedShaders` returns the names of the shader objects attached to `program`. The names
of shader objects that are attached to `program` will be returned in `shaders.` The actual
number of shader names written into `shaders` is returned in `count.` If no shader objects are
attached to `program`, `count` is set to 0. The maximum number of shader names that may be
returned in `shaders` is specified by `maxCount`.

If the number of names actually returned is not required (for instance, if it has just been
obtained by calling glGetProgram ), a value of `NULL` may be passed for count. If no shader
objects are attached to `program`, a value of 0 will be returned in `count`. The actual number
of attached shaders can be obtained by calling glGetProgram with the value `GL_ATTACHED_SHADERS`.
---
### Errors
`GL_INVALID_VALUE` is generated if `program` is not a value generated by OpenGL.

`GL_INVALID_OPERATION` is generated if `program` is not a program object.

`GL_INVALID_VALUE` is generated if `maxCount` is less than 0.
---
### Associated Gets
glGetProgram with argument `GL_ATTACHED_SHADERS`

glIsProgram
---
### Version Support
`glGetAttachedShaders`
---
### See Also
glAttachShader, glDetachShader.
---
### Copyright
Copyright 2003-2005 3Dlabs Inc. Ltd. Copyright 2010-2014 Khronos Group. This material may be
distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8
June 1999. https://opencontent.org/openpub/.
]],
  [[Returns the location of an attribute variable
---
### Parameters
`program` Specifies the program object to be queried.
`name` Points to a null terminated string containing the name of the attribute variable whose
location is to be queried.
---
### Description
`glGetAttribLocation` queries the previously linked program object specified by `program` for
the attribute variable specified by `name` and returns the index of the generic vertex attribute
that is bound to that attribute variable. If `name` is a matrix attribute variable, the index of
the first column of the matrix is returned. If the named attribute variable is not an active
attribute in the specified program object or if `name` starts with the reserved prefix "gl_", a
value of -1 is returned.

The association between an attribute variable name and a generic attribute index can be specified
at any time by calling glBindAttribLocation. Attribute bindings do not go into effect until
glLinkProgram is called. After a program object has been linked successfully, the index values for
attribute variables remain fixed until the next link command occurs. The attribute values can only
be queried after a link if the link was successful. `glGetAttribLocation` returns the binding that
actually went into effect the last time glLinkProgram was called for the specified program
object. Attribute bindings that have been specified since the last link operation are not returned
by `glGetAttribLocation`.
---
### Errors
`GL_INVALID_OPERATION` is generated if `program` is not a value generated by OpenGL.

`GL_INVALID_OPERATION` is generated if `program` is not a program object.

`GL_INVALID_OPERATION` is generated if `program` has not been successfully linked.
---
### Associated Gets
glGetActiveAttrib with argument `program` and the index of an active attribute

glIsProgram
---
### Version Support
`glGetAttribLocation`
---
### See Also
glBindAttribLocation, glLinkProgram, glVertexAttrib, glVertexAttribPointer
---
### Copyright
Copyright 2003-2005 3Dlabs Inc. Ltd. Copyright 2010-2014 Khronos Group. This material may be
distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8
June 1999. https://opencontent.org/openpub/.
]],
  [[GlGetBufferParameter Return parameters of a buffer object
---
### Parameters
`target` Specifies the target to which the buffer object is bound for
`glGetBufferParameteriv` and `glGetBufferParameteri64v`. Must be one of the buffer binding
targets in the following table:

`buffer` Specifies the name of the buffer object for `glGetNamedBufferParameteriv` and
`glGetNamedBufferParameteri64v`.

`value` Specifies the name of the buffer object parameter to query.
`data` Returns the requested parameter.
---
### Description
These functions return in `data` a selected parameter of the specified buffer object.

`pname` names a specific buffer object parameter, as follows:

`GL_BUFFER_ACCESS` `params` returns the access policy set while mapping the buffer object
(the value of the `access` parameter enum passed to `glMapBuffer` ). If the buffer was mapped
with `glMapBufferRange`, the access policy is determined by translating the bits in that `access`
parameter to one of the supported enums for `glMapBuffer` as described in the OpenGL
Specification.

`GL_BUFFER_ACCESS_FLAGS` `params` returns the access policy set while mapping the buffer
object (the value of the `access` parameter bitfield passed to `glMapBufferRange` ). If the
buffer was mapped with `glMapBuffer`, the access policy is determined by translating the enums in
that `access` parameter to the corresponding bits for `glMapBufferRange` as described in the
OpenGL Specification. The initial value is zero.

`GL_BUFFER_IMMUTABLE_STORAGE` `params` returns a boolean flag indicating whether the buffer
object is immutable. The initial value is `GL_FALSE`.

`GL_BUFFER_MAPPED` `params` returns a flag indicating whether the buffer object is currently
mapped. The initial value is `GL_FALSE`.

`GL_BUFFER_MAP_LENGTH` `params` returns the length of the mapping into the buffer object
established with `glMapBuffer*`. The `i64v` versions of these queries should be used for this
parameter. The initial value is zero.

`GL_BUFFER_MAP_OFFSET` `params` returns the offset of the mapping into the buffer object
established with `glMapBuffer*`. The `i64v` versions of these queries should be used for this
parameter. The initial value is zero.

`GL_BUFFER_SIZE` `params` returns the size of the buffer object, measured in bytes. The
initial value is 0.

`GL_BUFFER_STORAGE_FLAGS` `params` returns a bitfield indicating the storage flags for the
buffer object. If the buffer object is immutable, the value returned will be that specified when the
data store was established with `glBufferStorage`. If the data store was established with
`glBufferData`, the value will be `GL_MAP_READ_BIT` | `GL_MAP_WRITE_BIT` |
`GL_DYNAMIC_STORAGE_BIT` | `GL_MAP_WRITE_BIT`. The initial value is zero.

`GL_BUFFER_USAGE` `params` returns the buffer object's usage pattern. The initial value is
`GL_STATIC_DRAW`.

---
### Notes
If an error is generated, no change is made to the contents of `data`.

The `GL_ATOMIC_COUNTER_BUFFER` target is available only if the GL version is 4.2 or greater.

The `GL_DISPATCH_INDIRECT_BUFFER` and `GL_SHADER_STORAGE_BUFFER` targets are available only if
the GL version is 4.3 or greater.

The `GL_QUERY_BUFFER` target is available only if the GL version is 4.4 or greater.
---
### Errors
`GL_INVALID_ENUM` is generated by `glGetBufferParameter*` if `target` is not one of the
accepted buffer targets.

`GL_INVALID_OPERATION` is generated by `glGetBufferParameter*` if zero is bound to `target`.

`GL_INVALID_OPERATION` is generated by `glGetNamedBufferParameter*` if `buffer` is not the
name of an existing buffer object.

`GL_INVALID_ENUM` is generated if `pname` is not one of the buffer object parameter names
described above.
---
### Version Support
`glGetBufferParameteri64v` `glGetBufferParameteriv` `glGetNamedBufferParameteri64v`
`glGetNamedBufferParameteriv`
---
### See Also
glBindBuffer, glBufferData, glGetBufferPointerv, glMapBuffer, glUnmapBuffer
---
### Copyright
Copyright 2005 Addison-Wesley. Copyright 2010-2014 Khronos Group. This material may be
distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8
June 1999. https://opencontent.org/openpub/.
]],
  [[Return the pointer to a mapped buffer object's data store
---
### Parameters
`target` Specifies the target to which the buffer object is bound for `glGetBufferPointerv`,
which must be one of the buffer binding targets in the following table:

`buffer` Specifies the name of the buffer object for `glGetNamedBufferPointerv`.

`pname` Specifies the name of the pointer to be returned. Must be `GL_BUFFER_MAP_POINTER`.

`params` Returns the pointer value specified by `pname`.

---
### Description
`glGetBufferPointerv` and `glGetNamedBufferPointerv` return the buffer pointer `pname`, which
must be `GL_BUFFER_MAP_POINTER`. The single buffer map pointer is returned in `params`. A
`NULL` pointer is returned if the buffer object's data store is not currently mapped; or if the
requesting context did not map the buffer object's data store, and the implementation is unable to
support mappings on multiple clients.
---
### Notes
If an error is generated, no change is made to the contents of `params`.

The initial value for the pointer is `NULL`.

The `GL_ATOMIC_COUNTER_BUFFER` target is available only if the GL version is 4.2 or greater.

The `GL_DISPATCH_INDIRECT_BUFFER` and `GL_SHADER_STORAGE_BUFFER` targets are available only if
the GL version is 4.3 or greater.

The `GL_QUERY_BUFFER` target is available only if the GL version is 4.4 or greater.
---
### Errors
`GL_INVALID_ENUM` is generated if by `glGetBufferPointerv` if `target` is not one of the
accepted buffer targets, or if `pname` is not `GL_BUFFER_MAP_POINTER`.

`GL_INVALID_OPERATION` is generated by `glGetBufferPointerv` if zero is bound to `target`.

`GL_INVALID_OPERATION` is generated by `glGetNamedBufferPointerv` if `buffer` is not the name
of an existing buffer object.
---
### Version Support
`glGetBufferPointerv` `glGetNamedBufferPointerv`
---
### See Also
glBindBuffer, glMapBuffer
---
### Copyright
Copyright 2005 Addison-Wesley. Copyright 2011-2014 Khronos Group. This material may be
distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8
June 1999. https://opencontent.org/openpub/.
]],
  [[Returns a subset of a buffer object's data store
---
### Parameters
`target` Specifies the target to which the buffer object is bound for `glGetBufferSubData`,
which must be one of the buffer binding targets in the following table:

`buffer` Specifies the name of the buffer object for `glGetNamedBufferSubData`.

`offset` Specifies the offset into the buffer object's data store from which data will be
returned, measured in bytes.
`size` Specifies the size in bytes of the data store region being returned.
`data` Specifies a pointer to the location where buffer object data is returned.
---
### Description
`glGetBufferSubData` and `glGetNamedBufferSubData` return some or all of the data contents of
the data store of the specified buffer object. Data starting at byte offset `offset` and extending
for `size` bytes is copied from the buffer object's data store to the memory pointed to by `data`.
  An error is thrown if the buffer object is currently mapped, or if `offset` and `size`
together define a range beyond the bounds of the buffer object's data store.
---
### Notes
If an error is generated, no change is made to the contents of `data`.

The `GL_ATOMIC_COUNTER_BUFFER` target is available only if the GL version is 4.2 or greater.

The `GL_DISPATCH_INDIRECT_BUFFER` and `GL_SHADER_STORAGE_BUFFER` targets are available only if
the GL version is 4.3 or greater.

The `GL_QUERY_BUFFER` target is available only if the GL version is 4.4 or greater.
---
### Errors
`GL_INVALID_ENUM` is generated by `glGetBufferSubData` if `target` is not one of the generic
buffer binding targets.

`GL_INVALID_OPERATION` is generated by `glGetBufferSubData` if zero is bound to `target`.

`GL_INVALID_OPERATION` is generated by `glGetNamedBufferSubData` if `buffer` is not the name
of an existing buffer object.

`GL_INVALID_VALUE` is generated if `offset` or `size` is negative, or if $offset + size$ is
greater than the value of `GL_BUFFER_SIZE` for the buffer object.

`GL_INVALID_OPERATION` is generated if the buffer object is mapped with glMapBufferRange or
glMapBuffer, unless it was mapped with the `GL_MAP_PERSISTENT_BIT` bit set in the
`glMapBufferRange` `access` flags.
---
### Version Support
`glGetBufferSubData` `glGetNamedBufferSubData`
---
### See Also
glBindBuffer, glBufferData, glBufferSubData, glMapBuffer, glUnmapBuffer
---
### Copyright
Copyright 2005 Addison-Wesley. Copyright 2011-2014 Khronos Group. This material may be
distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8
June 1999. https://opencontent.org/openpub/.
]],
  [[Draw multiple instances of a set of elements with offset applied to instanced attributes
---
### Parameters
`mode` Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`,
`GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`,
`GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`,
`GL_TRIANGLES_ADJACENCY` and `GL_PATCHES` are accepted.

`count` Specifies the number of elements to be rendered.
`type` Specifies the type of the values in `indices`. Must be one of `GL_UNSIGNED_BYTE`,
`GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`.

`indices` Specifies a pointer to the location where the indices are stored.
`instancecount` Specifies the number of instances of the specified range of indices to be
rendered.
`baseinstance` Specifies the base instance for use in fetching instanced vertex attributes.
]],
  [[Render multiple instances of a set of primitives from array data with a per-element offset
---
### Parameters
`mode` Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`,
`GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`,
`GL_TRIANGLES`, `GL_LINES_ADJACENCY`, `GL_LINE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY`,
`GL_TRIANGLE_STRIP_ADJACENCY` and `GL_PATCHES` are accepted.

`count` Specifies the number of elements to be rendered.
`type` Specifies the type of the values in indices. Must be one of `GL_UNSIGNED_BYTE`,
`GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`.

`indices` Specifies a pointer to the location where the indices are stored.
`instancecount` Specifies the number of instances of the indexed geometry that should be drawn.

`basevertex` Specifies a constant that should be added to each element of `indices` when
chosing elements from the enabled vertex arrays.

---
### Description
`glDrawElementsInstancedBaseVertex` behaves identically to glDrawElementsInstanced except that
the i th element transferred by the corresponding draw call will be taken from element `indices`
[i] + `basevertex` of each enabled array. If the resulting value is larger than the maximum value
representable by `type`, it is as if the calculation were upconverted to 32-bit unsigned integers
(with wrapping on overflow conditions). The operation is undefined if the sum would be negative.
---
### Notes
`glDrawElementsInstancedBaseVertex` is only supported if the GL version is 3.2 or greater.
---
### Errors
`GL_INVALID_ENUM` is generated if `mode` is not an accepted value.

`GL_INVALID_VALUE` is generated if `count` or `instancecount` is negative.

`GL_INVALID_OPERATION` is generated if a geometry shader is active and `mode` is incompatible
with the input primitive type of the geometry shader in the currently installed program object.

`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array
or the element array and the buffer object's data store is currently mapped.
---
### Version Support
`glDrawElementsInstancedBaseVertex`
---
### See Also
glDrawElements, glDrawRangeElements, glDrawRangeElementsBaseVertex,
glDrawElementsInstanced, glDrawElementsInstancedBaseVertex
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Render multiple instances of a set of primitives from array data with a per-element offset
---
### Parameters
`mode` Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`,
`GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`,
`GL_TRIANGLES`, `GL_LINES_ADJACENCY`, `GL_LINE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY`,
`GL_TRIANGLE_STRIP_ADJACENCY` and `GL_PATCHES` are accepted.

`count` Specifies the number of elements to be rendered.
`type` Specifies the type of the values in indices. Must be one of `GL_UNSIGNED_BYTE`,
`GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`.

`indices` Specifies a pointer to the location where the indices are stored.
`instancecount` Specifies the number of instances of the indexed geometry that should be drawn.

`basevertex` Specifies a constant that should be added to each element of `indices` when
chosing elements from the enabled vertex arrays.

`baseinstance` Specifies the base instance for use in fetching instanced vertex attributes.
]],
  [[Render primitives from array data
---
### Parameters
`mode` Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`,
`GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`,
`GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`,
`GL_TRIANGLES_ADJACENCY` and `GL_PATCHES` are accepted.

`start` Specifies the minimum array index contained in `indices`.

`end` Specifies the maximum array index contained in `indices`.

`count` Specifies the number of elements to be rendered.
`type` Specifies the type of the values in `indices`. Must be one of `GL_UNSIGNED_BYTE`,
`GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`.

`indices` Specifies a pointer to the location where the indices are stored.
---
### Description
`glDrawRangeElements` is a restricted form of glDrawElements. `mode`, and `count` match
the corresponding arguments to glDrawElements, with the additional constraint that all values in
the arrays `count` must lie between `start` and `end`, inclusive.

Implementations denote recommended maximum amounts of vertex and index data, which may be queried
by calling glGet with argument `GL_MAX_ELEMENTS_VERTICES` and `GL_MAX_ELEMENTS_INDICES`. If
end - start + 1 is greater than the value of `GL_MAX_ELEMENTS_VERTICES`, or if `count` is
greater than the value of `GL_MAX_ELEMENTS_INDICES`, then the call may operate at reduced
performance. There is no requirement that all vertices in the range start end be referenced.

However, the implementation may partially process unused vertices, reducing performance from what
could be achieved with an optimal index set.

When `glDrawRangeElements` is called, it uses `count` sequential elements from an enabled
array, starting at `start` to construct a sequence of geometric primitives. `mode` specifies
what kind of primitives are constructed, and how the array elements construct these primitives. If
more than one array is enabled, each is used.

Vertex attributes that are modified by `glDrawRangeElements` have an unspecified value after
`glDrawRangeElements` returns. Attributes that aren't modified maintain their previous values.
---
### Notes
`GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP_ADJACENCY` and
`GL_TRIANGLES_ADJACENCY` are available only if the GL version is 3.2 or greater.
---
### Errors
It is an error for indices to lie outside the range start end, but implementations may not
check for this situation. Such indices cause implementation-dependent behavior.

`GL_INVALID_ENUM` is generated if `mode` is not an accepted value.

`GL_INVALID_VALUE` is generated if `count` is negative.

`GL_INVALID_VALUE` is generated if end < start.

`GL_INVALID_OPERATION` is generated if a geometry shader is active and `mode` is incompatible
with the input primitive type of the geometry shader in the currently installed program object.

`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array
or the element array and the buffer object's data store is currently mapped.
---
### Associated Gets
glGet with argument `GL_MAX_ELEMENTS_VERTICES`

glGet with argument `GL_MAX_ELEMENTS_INDICES`
---
### Version Support
`glDrawRangeElements`
---
### See Also
glDrawArrays, glDrawElements, glDrawElementsBaseVertex
---
### Copyright
Copyright 1991-2006 Silicon Graphics, Inc. Copyright 2010-2014 Khronos Group. This document
is licensed under the SGI Free Software B License. For details, see
https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.
]],
  [[Render primitives from array data with a per-element offset
---
### Parameters
`mode` Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`,
`GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`,
`GL_TRIANGLES`, `GL_LINES_ADJACENCY`, `GL_LINE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY`,
`GL_TRIANGLE_STRIP_ADJACENCY` and `GL_PATCHES` are accepted.

`start` Specifies the minimum array index contained in `indices`.

`end` Specifies the maximum array index contained in `indices`.

`count` Specifies the number of elements to be rendered.
`type` Specifies the type of the values in indices. Must be one of `GL_UNSIGNED_BYTE`,
`GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`.

`indices` Specifies a pointer to the location where the indices are stored.
`basevertex` Specifies a constant that should be added to each element of `indices` when
chosing elements from the enabled vertex arrays.

---
### Description
`glDrawRangeElementsBaseVertex` is a restricted form of glDrawElementsBaseVertex. `mode`,
`count` and `basevertex` match the corresponding arguments to glDrawElementsBaseVertex, with
the additional constraint that all values in the array `indices` must lie between `start` and
`end`, inclusive, prior to adding `basevertex`. Index values lying outside the range [ `start`,
`end` ] are treated in the same way as glDrawElementsBaseVertex. The i th element transferred by
the corresponding draw call will be taken from element `indices` [i] + `basevertex` of each
enabled array. If the resulting value is larger than the maximum value representable by `type`, it
is as if the calculation were upconverted to 32-bit unsigned integers (with wrapping on overflow
conditions). The operation is undefined if the sum would be negative.
---
### Errors
`GL_INVALID_ENUM` is generated if `mode` is not an accepted value.

`GL_INVALID_VALUE` is generated if `count` is negative.

`GL_INVALID_VALUE` is generated if `end` < `start`.

`GL_INVALID_OPERATION` is generated if a geometry shader is active and `mode` is incompatible
with the input primitive type of the geometry shader in the currently installed program object.

`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array
or the element array and the buffer object's data store is currently mapped.
---
### Version Support
`glDrawRangeElementsBaseVertex`
---
### See Also
glDrawElements, glDrawElementsBaseVertex, glDrawRangeElements, glDrawElementsInstanced,
glDrawElementsInstancedBaseVertex
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Render primitives using a count derived from a transform feedback object
---
### Parameters
`mode` Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`,
`GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`,
`GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`,
`GL_TRIANGLES_ADJACENCY`, and `GL_PATCHES` are accepted.

`id` Specifies the name of a transform feedback object from which to retrieve a primitive
count.
---
### Description
`glDrawTransformFeedback` draws primitives of a type specified by `mode` using a count
retrieved from the transform feedback specified by `id`. Calling `glDrawTransformFeedback` is
equivalent to calling glDrawArrays with `mode` as specified, `first` set to zero, and
`count` set to the number of vertices captured on vertex stream zero the last time transform
feedback was active on the transform feedback object named by `id`.
---
### Errors
`GL_INVALID_ENUM` is generated if `mode` is not an accepted value.

`GL_INVALID_VALUE` is generated if `id` is not the name of a transform feedback object.

`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array
and the buffer object's data store is currently mapped.

`GL_INVALID_OPERATION` is generated if a geometry shader is active and `mode` is incompatible
with the input primitive type of the geometry shader in the currently installed program object.

`GL_INVALID_OPERATION` is generated if `mode` is `GL_PATCHES` and no tessellation control
shader is active.

`GL_INVALID_OPERATION` is generated if `glEndTransformFeedback` has never been called while the
transform feedback object named by `id` was bound.
---
### Version Support
`glDrawTransformFeedback`
---
### See Also
glDrawArrays, glDrawArraysInstanced, glDrawElements, glDrawRangeElements,
glDrawTransformFeedbackStream
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Render multiple instances of primitives using a count derived from a transform feedback object
---
### Parameters
`mode` Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`,
`GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`,
`GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`,
`GL_TRIANGLES_ADJACENCY`, and `GL_PATCHES` are accepted.

`id` Specifies the name of a transform feedback object from which to retrieve a primitive
count.
`instancecount` Specifies the number of instances of the geometry to render.
---
### Description
`glDrawTransformFeedbackInstanced` draws multiple copies of a range of primitives of a type
specified by `mode` using a count retrieved from the transform feedback stream specified by
`stream` of the transform feedback object specified by `id`. Calling
`glDrawTransformFeedbackInstanced` is equivalent to calling glDrawArraysInstanced with `mode`
and `instancecount` as specified, `first` set to zero, and `count` set to the number of
vertices captured on vertex stream zero the last time transform feedback was active on the transform
feedback object named by `id`.

Calling `glDrawTransformFeedbackInstanced` is equivalent to calling
glDrawTransformFeedbackStreamInstanced with `stream` set to zero.
---
### Errors
`GL_INVALID_ENUM` is generated if `mode` is not an accepted value.

`GL_INVALID_VALUE` is generated if `id` is not the name of a transform feedback object.

`GL_INVALID_VALUE` is generated if `stream` is greater than or equal to the value of
`GL_MAX_VERTEX_STREAMS`.

`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array
and the buffer object's data store is currently mapped.

`GL_INVALID_OPERATION` is generated if a geometry shader is active and `mode` is incompatible
with the input primitive type of the geometry shader in the currently installed program object.

`GL_INVALID_OPERATION` is generated if `mode` is `GL_PATCHES` and no tessellation control
shader is active.

`GL_INVALID_OPERATION` is generated if `glEndTransformFeedback` has never been called while the
transform feedback object named by `id` was bound.
---
### Version Support
`glDrawTransformFeedbackInstanced`
---
### See Also
glDrawArrays, glDrawArraysInstanced, glDrawElements, glDrawRangeElements,
glDrawTransformFeedback, glDrawTransformFeedbackStreamInstanced.
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Render primitives using a count derived from a specifed stream of a transform feedback object
---
### Parameters
`mode` Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`,
`GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`,
`GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`,
`GL_TRIANGLES_ADJACENCY`, and `GL_PATCHES` are accepted.

`id` Specifies the name of a transform feedback object from which to retrieve a primitive
count.
`stream` Specifies the index of the transform feedback stream from which to retrieve a
primitive count.
---
### Description
`glDrawTransformFeedbackStream` draws primitives of a type specified by `mode` using a count
retrieved from the transform feedback stream specified by `stream` of the transform feedback
object specified by `id`. Calling `glDrawTransformFeedbackStream` is equivalent to calling
glDrawArrays with `mode` as specified, `first` set to zero, and `count` set to the number of
vertices captured on vertex stream `stream` the last time transform feedback was active on the
transform feedback object named by `id`.

Calling glDrawTransformFeedback is equivalent to calling `glDrawTransformFeedbackStream` with
`stream` set to zero.
---
### Errors
`GL_INVALID_ENUM` is generated if `mode` is not an accepted value.

`GL_INVALID_VALUE` is generated if `id` is not the name of a transform feedback object.

`GL_INVALID_VALUE` is generated if `stream` is greater than or equal to the value of
`GL_MAX_VERTEX_STREAMS`.

`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array
and the buffer object's data store is currently mapped.

`GL_INVALID_OPERATION` is generated if a geometry shader is active and `mode` is incompatible
with the input primitive type of the geometry shader in the currently installed program object.

`GL_INVALID_OPERATION` is generated if `mode` is `GL_PATCHES` and no tessellation control
shader is active.

`GL_INVALID_OPERATION` is generated if `glEndTransformFeedback` has never been called while the
transform feedback object named by `id` was bound.
---
### Version Support
`glDrawTransformFeedbackStream`
---
### See Also
glDrawArrays, glDrawArraysInstanced, glDrawElements, glDrawRangeElements,
glDrawTransformFeedback
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Render multiple instances of primitives using a count derived from a specifed stream of a transform
feedback object
---
### Parameters
`mode` Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`,
`GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`,
`GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`,
`GL_TRIANGLES_ADJACENCY`, and `GL_PATCHES` are accepted.

`id` Specifies the name of a transform feedback object from which to retrieve a primitive
count.
`stream` Specifies the index of the transform feedback stream from which to retrieve a
primitive count.
`instancecount` Specifies the number of instances of the geometry to render.
---
### Description
`glDrawTransformFeedbackStreamInstanced` draws multiple copies of a range of primitives of a type
specified by `mode` using a count retrieved from the transform feedback stream specified by
`stream` of the transform feedback object specified by `id`. Calling
`glDrawTransformFeedbackStreamInstanced` is equivalent to calling glDrawArraysInstanced with
`mode` and `instancecount` as specified, `first` set to zero, and `count` set to the number
of vertices captured on vertex stream `stream` the last time transform feedback was active on the
transform feedback object named by `id`.

Calling glDrawTransformFeedbackInstanced is equivalent to calling
`glDrawTransformFeedbackStreamInstanced` with `stream` set to zero.
---
### Errors
`GL_INVALID_ENUM` is generated if `mode` is not an accepted value.

`GL_INVALID_VALUE` is generated if `id` is not the name of a transform feedback object.

`GL_INVALID_VALUE` is generated if `stream` is greater than or equal to the value of
`GL_MAX_VERTEX_STREAMS`.

`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array
and the buffer object's data store is currently mapped.

`GL_INVALID_OPERATION` is generated if a geometry shader is active and `mode` is incompatible
with the input primitive type of the geometry shader in the currently installed program object.

`GL_INVALID_OPERATION` is generated if `mode` is `GL_PATCHES` and no tessellation control
shader is active.

`GL_INVALID_OPERATION` is generated if `glEndTransformFeedback` has never been called while the
transform feedback object named by `id` was bound.
---
### Version Support
`glDrawTransformFeedbackStreamInstanced`
---
### See Also
glDrawArrays, glDrawArraysInstanced, glDrawElements, glDrawRangeElements,
glDrawTransformFeedback, glDrawTransformFeedbackStream.
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Enable or disable server-side GL capabilities
---
### Parameters
`cap` Specifies a symbolic constant indicating a GL capability.
`index` Specifies the index of the switch to disable (for `glEnablei` and `glDisablei`
only).
]],
  [[Retrieve information about attachments of a framebuffer object
---
### Parameters
`target` Specifies the target to which the framebuffer object is bound for
`glGetFramebufferAttachmentParameteriv`.

`framebuffer` Specifies the name of the framebuffer object for
`glGetNamedFramebufferAttachmentParameteriv`.

`attachment` Specifies the attachment of the framebuffer object to query.
`pname` Specifies the parameter of `attachment` to query.

`params` Returns the value of parameter `pname` for `attachment`.

---
### Description
`glGetFramebufferAttachmentParameteriv` and `glGetNamedFramebufferAttachmentParameteriv` return
parameters of attachments of a specified framebuffer object.

For `glGetFramebufferAttachmentParameteriv`, the framebuffer object is that bound to `target`,
which must be one of `GL_DRAW_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER` or `GL_FRAMEBUFFER`.
`GL_FRAMEBUFFER` is equivalent to `GL_DRAW_FRAMEBUFFER`. Buffers of default framebuffers may also
be queried if bound to `target`.

For `glGetNamedFramebufferAttachmentParameteriv`, `framebuffer` is the name of the framebuffer
object. If `framebuffer` is zero, the default draw framebuffer is queried.

If the specified framebuffer is a framebuffer object, `attachment` must be one of
`GL_DEPTH_ATTACHMENT`, `GL_STENCIL_ATTACHMENT` `GL_DEPTH_STENCIL_ATTACHMENT`, or
`GL_COLOR_ATTACHMENT` i, where i is between zero and the value of `GL_MAX_COLOR_ATTACHMENTS`
minus one.

If the specified framebuffer is a default framebuffer, `target`, `attachment` must be one of
`GL_FRONT_LEFT`, `GL_FRONT_RIGHT`, `GL_BACK_LEFT`, `GL_BACK_RIGHT`, `GL_DEPTH` or
`GL_STENCIL`, identifying the corresponding buffer.

If `attachment` is `GL_DEPTH_STENCIL_ATTACHMENT`, the same object must be bound to both the
depth and stencil attachment points of the framebuffer object, and information about that object is
returned.

Upon successful return, if `pname` is `GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE`, then `params`
will contain one of `GL_NONE`, `GL_FRAMEBUFFER_DEFAULT`, `GL_TEXTURE`, or `GL_RENDERBUFFER`,
identifying the type of object which contains the attached image. Other values accepted for `pname`
depend on the type of object, as described below.

If the value of `GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE` is `GL_NONE`, then either no
framebuffer is bound to `target` ; or a default framebuffer is queried, `attachment` is
`GL_DEPTH` or `GL_STENCIL`, and the number of depth or stencil bits, respectively, is zero. In
this case querying `pname` `GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME` will return zero, and all other
queries will generate an error.

If the value of `GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE` is not `GL_NONE`, these queries apply
to all other framebuffer types:

If `pname` is `GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE`, `GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE`,
`GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE`, `GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE`,
`GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE` or `GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE`, then
`params` will contain the number of bits in the corresponding red, green, blue, alpha, depth, or
stencil component of the specified attachment. If the requested component is not present in the
attachment, or if no data storage or texture image has been specified for the attachment, then
`params` will contain zero.

If `pname` is `GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE`, then `params` will contain the
format of components of the specified attachment, one of `GL_FLOAT`, `GL_INT`,
`GL_UNSIGNED_INT`, `GL_SIGNED_NORMALIZED`, or `GL_UNSIGNED_NORMALIZED` for floating-point,
signed integer, unsigned integer, signed normalized fixed-point, or unsigned normalized fixed-point
components respectively. Only color buffers may have integer components. If no data storage or
texture image has been specified for the attachment, then `params` will contain `GL_NONE`. This
query cannot be performed for a combined depth+stencil attachment, since it does not have a single
format.

If `pname` is `GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING`, then `params` will contain the
encoding of components of the specified attachment, one of `GL_LINEAR` or `GL_SRGB` for linear
or sRGB-encoded components, respectively. Only color buffer components may be sRGB-encoded; such
components are treated as described in the OpenGL Specification. For a default framebuffer, color
encoding is determined by the implementation. For framebuffer objects, components are sRGB-encoded
if the internal format of a color attachment is one of the color-renderable SRGB formats. If the
attachment is not a color attachment, or if no data storage or texture image has been specified for
the attachment, then `params` will contain `GL_LINEAR`.

If the value of `GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE` is `GL_RENDERBUFFER`, then

If `pname` is `GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME`, `params` will contain the name of
the renderbuffer object which contains the attached image.

If the value of `GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE` is `GL_TEXTURE`, then

If `pname` is `GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME`, then `params` will contain the name
of the texture object which contains the attached image.

If `pname` is `GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL`, then `params` will contain the
mipmap level of the texture object which contains the attached image.

If `pname` is `GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE` and the value of
`GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME` is the name of a cube map texture object, then `params`
will contain the cube map face of the cubemap texture object which contains the attached image.

Otherwise `params` will contain zero.

If `pname` is `GL_FRAMEBUFFER_ATTACHMENT_LAYERED`, then `params` will contain `GL_TRUE`
if an entire level of a three-dimensional texture, cube map texture, or one-or two-dimensional array
texture is attached. Otherwise, `params` will contain `GL_FALSE`.

If `pname` is `GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER` ; the value of
`GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME` is the name of a three-dimensional, or a one- or
two-dimensional array texture; and the value of `GL_FRAMEBUFFER_ATTACHMENT_LAYERED` is `GL_FALSE`,
then `params` will contain the texture layer which contains the attached image. Otherwise
`params` will contain zero.
---
### Notes
The `GL_FRAMEBUFFER_ATTACHMENT_LAYERED` query is supported only if the GL version is 3.2 or
greater.
---
### Errors
`GL_INVALID_ENUM` is generated by `glGetFramebufferAttachmentParameteriv` if `target` is not
one of the accepted framebuffer targets.

`GL_INVALID_OPERATION` is generated by `glGetNamedFramebufferAttachmentParameteriv` if
`framebuffer` is not zero or the name of an existing framebuffer object.

`GL_INVALID_ENUM` is generated if `pname` is not valid for the value of
`GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE`, as described above.

`GL_INVALID_OPERATION` is generated if `attachment` is not one of the accepted framebuffer
attachment points, as described above.

`GL_INVALID_OPERATION` is generated if the value of `GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE` is
`GL_NONE` and `pname` is not `GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME` or
`GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE`.

`GL_INVALID_OPERATION` is generated if `attachment` is `GL_DEPTH_STENCIL_ATTACHMENT` and
different objects are bound to the depth and stencil attachment points of `target`.

`GL_INVALID_OPERATION` is generated if `attachment` is `GL_DEPTH_STENCIL_ATTACHMENT` and
`pname` is `GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE`.
---
### Version Support
`glGetFramebufferAttachmentParameteriv` `glGetNamedFramebufferAttachmentParameteriv`
---
### See Also
glGenFramebuffers, glBindFramebuffer glGetFramebufferParameter
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[GlEnableVertexAttribArray Enable or disable a generic vertex attribute array
---
### Parameters
`vaobj` Specifies the name of the vertex array object for `glDisableVertexArrayAttrib` and
`glEnableVertexArrayAttrib` functions.

`index` Specifies the index of the generic vertex attribute to be enabled or disabled.
---
### Description
`glEnableVertexAttribArray` and `glEnableVertexArrayAttrib` enable the generic vertex attribute
array specified by `index`. `glEnableVertexAttribArray` uses currently bound vertex array object
for the operation, whereas `glEnableVertexArrayAttrib` updates state of the vertex array object
with ID `vaobj`.

`glDisableVertexAttribArray` and `glDisableVertexArrayAttrib` disable the generic vertex
attribute array specified by `index`. `glDisableVertexAttribArray` uses currently bound vertex
array object for the operation, whereas `glDisableVertexArrayAttrib` updates state of the vertex
array object with ID `vaobj`.

By default, all client-side capabilities are disabled, including all generic vertex attribute
arrays. If enabled, the values in the generic vertex attribute array will be accessed and used for
rendering when calls are made to vertex array commands such as glDrawArrays, glDrawElements,
glDrawRangeElements, glMultiDrawElements, or glMultiDrawArrays.
---
### Errors
`GL_INVALID_OPERATION` is generated by `glEnableVertexAttribArray` and
`glDisableVertexAttribArray` if no vertex array object is bound.

`GL_INVALID_OPERATION` is generated by `glEnableVertexArrayAttrib` and
`glDisableVertexArrayAttrib` if `vaobj` is not the name of an existing vertex array object.

`GL_INVALID_VALUE` is generated if `index` is greater than or equal to `GL_MAX_VERTEX_ATTRIBS`.
---
### Associated Gets
glGet with argument `GL_MAX_VERTEX_ATTRIBS`

glGetVertexAttrib with arguments `index` and `GL_VERTEX_ATTRIB_ARRAY_ENABLED` ``

glGetVertexAttribPointerv with arguments `index` and `GL_VERTEX_ATTRIB_ARRAY_POINTER`
---
### Version Support
`glDisableVertexArrayAttrib` `glDisableVertexAttribArray` `glEnableVertexArrayAttrib`
`glEnableVertexAttribArray`
---
### See Also
glBindAttribLocation, glDrawArrays, glDrawElements, glDrawRangeElements,
glMultiDrawElements, glVertexAttrib, glVertexAttribPointer
---
### Copyright
Copyright 2003-2005 3Dlabs Inc. Ltd. Copyright 2010-2014 Khronos Group. This material may be
distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8
June 1999. https://opencontent.org/openpub/.
]],
  [[Create a new sync object and insert it into the GL command stream
---
### Parameters
`condition` Specifies the condition that must be met to set the sync object's state to
signaled. `condition` must be `GL_SYNC_GPU_COMMANDS_COMPLETE`.

`flags` Specifies a bitwise combination of flags controlling the behavior of the sync object.

No flags are presently defined for this operation and `flags` must be zero. `flags` is a
placeholder for anticipated future extensions of fence sync object capabilities.


---
### Description
`glFenceSync` creates a new fence sync object, inserts a fence command into the GL command stream
and associates it with that sync object, and returns a non-zero name corresponding to the sync
object.

When the specified `condition` of the sync object is satisfied by the fence command, the sync
object is signaled by the GL, causing any glWaitSync, glClientWaitSync commands blocking in
`sync` to unblock. No other state is affected by `glFenceSync` or by the execution of the
associated fence command.

`condition` must be `GL_SYNC_GPU_COMMANDS_COMPLETE`. This condition is satisfied by completion
of the fence command corresponding to the sync object and all preceding commands in the same command
stream. The sync object will not be signaled until all effects from these commands on GL client and
server state and the framebuffer are fully realized. Note that completion of the fence command
occurs once the state of the corresponding sync object has been changed, but commands waiting on
that sync object may not be unblocked until after the fence command completes.
---
### Notes
`glFenceSync` is only supported if the GL version is 3.2 or greater, or if the ARB_sync
extension is supported.
---
### Errors
`GL_INVALID_ENUM` is generated if `condition` is not `GL_SYNC_GPU_COMMANDS_COMPLETE`.

`GL_INVALID_VALUE` is generated if `flags` is not zero.

Additionally, if `glFenceSync` fails, it will return zero.
---
### Version Support
`glFenceSync`
---
### See Also
glDeleteSync, glGetSync, glWaitSync, glClientWaitSync
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Block until all GL execution is complete
---
### Description
`glFinish` does not return until the effects of all previously called GL commands are complete.

Such effects include all changes to GL state, all changes to connection state, and all changes to
the frame buffer contents.
---
### Notes
`glFinish` requires a round trip to the server.
---
### Version Support
`glFinish`
---
### See Also
glFlush
---
### Copyright
Copyright 1991-2006 Silicon Graphics, Inc. Copyright 2010-2014 Khronos Group. This document
is licensed under the SGI Free Software B License. For details, see
https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.
]],
  [[Force execution of GL commands in finite time
---
### Description
Different GL implementations buffer commands in several different locations, including network
buffers and the graphics accelerator itself. `glFlush` empties all of these buffers, causing all
issued commands to be executed as quickly as they are accepted by the actual rendering engine.

Though this execution may not be completed in any particular time period, it does complete in finite
time.

Because any GL program might be executed over a network, or on an accelerator that buffers
commands, all programs should call `glFlush` whenever they count on having all of their previously
issued commands completed. For example, call `glFlush` before waiting for user input that depends
on the generated image.
---
### Notes
`glFlush` can return at any time. It does not wait until the execution of all previously issued
GL commands is complete.
---
### Version Support
`glFlush`
---
### See Also
glFinish
---
### Copyright
Copyright 1991-2006 Silicon Graphics, Inc. Copyright 2010-2014 Khronos Group. This document
is licensed under the SGI Free Software B License. For details, see
https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.
]],
  [[Indicate modifications to a range of a mapped buffer
---
### Parameters
`target` Specifies the target to which the buffer object is bound for
`glFlushMappedBufferRange`, which must be one of the buffer binding targets in the following table:


`buffer` Specifies the name of the buffer object for `glFlushMappedNamedBufferRange`.

`offset` Specifies the start of the buffer subrange, in basic machine units.
`length` Specifies the length of the buffer subrange, in basic machine units.
---
### Description
`glFlushMappedBufferRange` indicates that modifications have been made to a range of a mapped
buffer object. The buffer object must previously have been mapped with the
`GL_MAP_FLUSH_EXPLICIT_BIT` flag.

`offset` and `length` indicate the modified subrange of the mapping, in basic machine units.

The specified subrange to flush is relative to the start of the currently mapped range of the
buffer. These commands may be called multiple times to indicate distinct subranges of the mapping
which require flushing.

If a buffer range is mapped with both `GL_MAP_PERSISTENT_BIT` and `GL_MAP_FLUSH_EXPLICIT_BIT`
set, then these commands may be called to ensure that data written by the client into the flushed
region becomes visible to the server. Data written to a coherent store will always become visible to
the server after an unspecified period of time.
---
### Notes
The `GL_DISPATCH_INDIRECT_BUFFER` and `GL_SHADER_STORAGE_BUFFER` targets are available only if
the GL version is 4.3 or greater.

The `GL_QUERY_BUFFER` target is available only if the GL version is 4.4 or greater.
---
### Errors
`GL_INVALID_ENUM` is generated by `glFlushMappedBufferRange` if `target` is not one of the
buffer binding targets listed above.

`GL_INVALID_OPERATION` is generated by `glFlushMappedBufferRange` if zero is bound to `target`.

`GL_INVALID_OPERATION` is generated by `glFlushMappedNamedBufferRange` if `buffer` is not the
name of an existing buffer object.

`GL_INVALID_VALUE` is generated if `offset` or `length` is negative, or if `offset` +
`length` exceeds the size of the mapping.

`GL_INVALID_OPERATION` is generated if the buffer object is not mapped, or is mapped without the
`GL_MAP_FLUSH_EXPLICIT_BIT` flag.
---
### Version Support
`glFlushMappedBufferRange` `glFlushMappedNamedBufferRange`
---
### See Also
glMapBufferRange, glMapBuffer, glUnmapBuffer
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Specifies the value of a generic vertex attribute
---
### Parameters
`index` Specifies the index of the generic vertex attribute to be modified.
`v0`, `v1`, `v2`, `v3` For the scalar commands, specifies the new values to be used for
the specified vertex attribute.
`v` For the vector commands ( `glVertexAttrib*v` ), specifies a pointer to an array of values
to be used for the generic vertex attribute.

`type` For the packed commands ( `glVertexAttribP*` ), specified the type of packing used on
the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to
specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify
floating point data.

`normalized` For the packed commands, if `GL_TRUE`, then the values are to be converted to
floating point values by normalizing. Otherwise, they are converted directly to floating-point
values. If `type` indicates a floating-pont format, then `normalized` value must be `GL_FALSE`.

`value` For the packed commands, specifies the new packed value to be used for the specified
vertex attribute.
---
### Description
The `glVertexAttrib` family of entry points allows an application to pass generic vertex
attributes in numbered locations.

Generic attributes are defined as four-component values that are organized into an array. The first
entry of this array is numbered 0, and the size of the array is specified by the
implementation-dependent constant `GL_MAX_VERTEX_ATTRIBS`. Individual elements of this array can
be modified with a `glVertexAttrib` call that specifies the index of the element to be modified
and a value for that element.

These commands can be used to specify one, two, three, or all four components of the generic vertex
attribute specified by `index`. A `1` in the name of the command indicates that only one value
is passed, and it will be used to modify the first component of the generic vertex attribute. The
second and third components will be set to 0, and the fourth component will be set to 1. Similarly,
a `2` in the name of the command indicates that values are provided for the first two components,
the third component will be set to 0, and the fourth component will be set to 1. A `3` in the name
of the command indicates that values are provided for the first three components and the fourth
component will be set to 1, whereas a `4` in the name indicates that values are provided for all
four components.

The letters `s`, `f`, `i`, `d`, `ub`, `us`, and `ui` indicate whether the arguments
are of type short, float, int, double, unsigned byte, unsigned short, or unsigned int. When `v` is
appended to the name, the commands can take a pointer to an array of such values.

Additional capitalized letters can indicate further alterations to the default behavior of the
glVertexAttrib function: The commands containing `N` indicate that the arguments will be passed
as fixed-point values that are scaled to a normalized range according to the component conversion
rules defined by the OpenGL specification. Signed values are understood to represent fixed-point
values in the range [-1,1], and unsigned values are understood to represent fixed-point values in
the range [0,1].

The commands containing `I` indicate that the arguments are extended to full signed or unsigned
integers.

The commands containing `P` indicate that the arguments are stored as packed components within a
larger natural type.

The commands containing `L` indicate that the arguments are full 64-bit quantities and should be
passed directly to shader inputs declared as 64-bit double precision types.

OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4.

Attributes of these types may be loaded using the `glVertexAttrib` entry points. Matrices must be
loaded into successive generic attribute slots in column major order, with one column of the matrix
in each generic attribute slot.

A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute
index by calling glBindAttribLocation. This allows an application to use more descriptive
variable names in a vertex shader. A subsequent change to the specified generic vertex attribute
will be immediately reflected as a change to the corresponding attribute variable in the vertex
shader.

The binding between a generic vertex attribute index and a user-defined attribute variable in a
vertex shader is part of the state of a program object, but the current value of the generic vertex
attribute is not. The value of each generic vertex attribute is part of current state, just like
standard vertex attributes, and it is maintained even if a different program object is used. An
application may freely modify generic vertex attributes that are not bound to a named vertex shader
attribute variable. These values are simply maintained as part of current state and will not be
accessed by the vertex shader. If a generic vertex attribute bound to an attribute variable in a
vertex shader is not updated while the vertex shader is executing, the vertex shader will repeatedly
use the current value for the generic vertex attribute.
---
### Notes
Generic vertex attributes can be updated at any time. It is possible for an application to bind
more than one attribute name to the same generic vertex attribute index. This is referred to as
aliasing, and it is allowed only if just one of the aliased attribute variables is active in the
vertex shader, or if no path through the vertex shader consumes more than one of the attributes
aliased to the same location. OpenGL implementations are not required to do error checking to detect
aliasing, they are allowed to assume that aliasing will not occur, and they are allowed to employ
optimizations that work only in the absence of aliasing. There is no provision for binding standard
vertex attributes; therefore, it is not possible to alias generic attributes with standard
attributes. `glVertexAttribL` versions are available only if the GL version is 4.1 or higher.

`GL_UNSIGNED_INT_10F_11F_11F_REV` is accepted for `type` by `glVertexAttribP*` only if the GL
version is 4.4 or higher.
---
### Errors
`GL_INVALID_VALUE` is generated if `index` is greater than or equal to `GL_MAX_VERTEX_ATTRIBS`.

`GL_INVALID_ENUM` is generated if `glVertexAttribP*` is used with a `type` other than
`GL_INT_2_10_10_10_REV`, `GL_UNSIGNED_INT_2_10_10_10_REV`, or `GL_UNSIGNED_INT_10F_11F_11F_REV`.

`GL_INVALID_ENUM` is generated if `glVertexAttribL` is used with a `type` other than
`GL_DOUBLE`.
---
### Associated Gets
glGet with the argument `GL_CURRENT_PROGRAM`

glGetActiveAttrib with argument `program` and the index of an active attribute variable

glGetAttribLocation with argument `program` and an attribute variable name

glGetVertexAttrib with arguments `GL_CURRENT_VERTEX_ATTRIB` and `index`
---
### Version Support
`glVertexAttrib1d` `glVertexAttrib1dv` `glVertexAttrib1f` `glVertexAttrib1fv`
`glVertexAttrib1s` `glVertexAttrib1sv` `glVertexAttrib2d` `glVertexAttrib2dv`
`glVertexAttrib2f` `glVertexAttrib2fv` `glVertexAttrib2s` `glVertexAttrib2sv`
`glVertexAttrib3d` `glVertexAttrib3dv` `glVertexAttrib3f` `glVertexAttrib3fv`
`glVertexAttrib3s` `glVertexAttrib3sv` `glVertexAttrib4Nbv` `glVertexAttrib4Niv`
`glVertexAttrib4Nsv` `glVertexAttrib4Nub` `glVertexAttrib4Nubv` `glVertexAttrib4Nuiv`
`glVertexAttrib4Nusv` `glVertexAttrib4bv` `glVertexAttrib4d` `glVertexAttrib4dv`
`glVertexAttrib4f` `glVertexAttrib4fv` `glVertexAttrib4iv` `glVertexAttrib4s`
`glVertexAttrib4sv` `glVertexAttrib4ubv` `glVertexAttrib4uiv` `glVertexAttrib4usv`
`glVertexAttribI1i` `glVertexAttribI1iv` `glVertexAttribI1ui` `glVertexAttribI1uiv`
`glVertexAttribI2i` `glVertexAttribI2iv` `glVertexAttribI2ui` `glVertexAttribI2uiv`
`glVertexAttribI3i` `glVertexAttribI3iv` `glVertexAttribI3ui` `glVertexAttribI3uiv`
`glVertexAttribI4bv` `glVertexAttribI4i` `glVertexAttribI4iv` `glVertexAttribI4sv`
`glVertexAttribI4ubv` `glVertexAttribI4ui` `glVertexAttribI4uiv` `glVertexAttribI4usv`
`glVertexAttribL1d` `glVertexAttribL1dv` `glVertexAttribL2d` `glVertexAttribL2dv`
`glVertexAttribL3d` `glVertexAttribL3dv` `glVertexAttribL4d` `glVertexAttribL4dv`
`glVertexAttribP1ui` `glVertexAttribP2ui` `glVertexAttribP3ui` `glVertexAttribP4ui`
---
### See Also
glBindAttribLocation, glVertexAttribPointer
---
### Copyright
Copyright 2003-2005 3Dlabs Inc. Ltd. Copyright 2010-2014 Khronos Group. This material may be
distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8
June 1999. https://opencontent.org/openpub/.
]],
  [[Associate a vertex attribute and a vertex buffer binding for a vertex array object
---
### Parameters
`vaobj` Specifies the name of the vertex array object for `glVertexArrayAttribBinding`.

`attribindex` The index of the attribute to associate with a vertex buffer binding.
`bindingindex` The index of the vertex buffer binding with which to associate the generic
vertex attribute.
---
### Description
`glVertexAttribBinding` and `glVertexArrayAttribBinding` establishes an association between the
generic vertex attribute of a vertex array object whose index is given by `attribindex`, and a
vertex buffer binding whose index is given by `bindingindex`. For `glVertexAttribBinding`, the
vertex array object affected is that currently bound. For `glVertexArrayAttribBinding`, `vaobj`
is the name of the vertex array object.

`attribindex` must be less than the value of `GL_MAX_VERTEX_ATTRIBS` and `bindingindex` must
be less than the value of `GL_MAX_VERTEX_ATTRIB_BINDINGS`.
---
### Errors
`GL_INVALID_OPERATION` is generated by `glVertexAttribBinding` if no vertex array object is
bound.

`GL_INVALID_OPERATION` is generated by `glVertexArrayAttribBinding` if `vaobj` is not the
name of an existing vertex array object.

`GL_INVALID_VALUE` is generated if `attribindex` is greater than or equal to the value of
`GL_MAX_VERTEX_ATTRIBS`.

`GL_INVALID_VALUE` is generated if `bindingindex` is greater than or equal to the value of
`GL_MAX_VERTEX_ATTRIB_BINDINGS`.
---
### Associated Gets
glGet with arguments `GL_MAX_VERTEX_ATTRIB_BINDINGS`, `GL_VERTEX_BINDING_DIVISOR`.
---
### Version Support
`glVertexArrayAttribBinding` `glVertexAttribBinding`
---
### See Also
glBindVertexBuffer, glVertexAttribFormat, glVertexBindingDivisor, glVertexAttribPointer.
---
### Copyright
Copyright 2013-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Modify the rate at which generic vertex attributes advance during instanced rendering
---
### Parameters
`index` Specify the index of the generic vertex attribute.
`divisor` Specify the number of instances that will pass between updates of the generic
attribute at slot `index`.

---
### Description
`glVertexAttribDivisor` modifies the rate at which generic vertex attributes advance when
rendering multiple instances of primitives in a single draw call. If `divisor` is zero, the
attribute at slot `index` advances once per vertex. If `divisor` is non-zero, the attribute
advances once per `divisor` instances of the set(s) of vertices being rendered. An attribute is
referred to as instanced if its `GL_VERTEX_ATTRIB_ARRAY_DIVISOR` value is non-zero.

`index` must be less than the value of `GL_MAX_VERTEX_ATTRIBS`.
---
### Notes
`glVertexAttribDivisor` is available only if the GL version is 3.3 or higher.
---
### Errors
`GL_INVALID_VALUE` is generated if `index` is greater than or equal to the value of
`GL_MAX_VERTEX_ATTRIBS`.
---
### Version Support
`glVertexAttribDivisor`
---
### See Also
glVertexAttribPointer, glEnableVertexAttribArray, `glDisableVertexAttribArray`
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Specify the organization of vertex arrays
---
### Parameters
`vaobj` Specifies the name of the vertex array object for `glVertexArrayAttrib{I, L}Format`
functions.

`attribindex` The generic vertex attribute array being described.
`size` The number of values per vertex that are stored in the array.
`type` The type of the data stored in the array.
`normalized` Specifies whether fixed-point data values should be normalized ( `GL_TRUE` ) or
converted directly as fixed-point values ( `GL_FALSE` ) when they are accessed. This parameter is
ignored if `type` is `GL_FIXED`.

`relativeoffset` The distance between elements within the buffer.
---
### Description
`glVertexAttribFormat`, `glVertexAttribIFormat` and `glVertexAttribLFormat`, as well as
`glVertexArrayAttribFormat`, `glVertexArrayAttribIFormat` and `glVertexArrayAttribLFormat`
specify the organization of data in vertex arrays. The first three calls operate on the bound vertex
array object, whereas the last three ones modify the state of a vertex array object with ID `vaobj`.
`attribindex` specifies the index of the generic vertex attribute array whose data layout is
being described, and must be less than the value of `GL_MAX_VERTEX_ATTRIBS`.

`size` determines the number of components per vertex are allocated to the specified attribute
and must be 1, 2, 3, 4, or GL_BGRA. `type` indicates the type of the data. If `type` is one of
`GL_BYTE`, `GL_SHORT`, `GL_INT`, `GL_FIXED`, `GL_FLOAT`, `GL_HALF_FLOAT`, and
`GL_DOUBLE` indicate types GLbyte, GLshort, GLint, GLfixed, GLfloat, GLhalf, and
GLdouble, respectively; the values `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT`, and
`GL_UNSIGNED_INT` indicate types GLubyte, GLushort, and GLuint, respectively; the values
`GL_INT_2_10_10_10_REV` and `GL_UNSIGNED_INT_2_10_10_10_REV` indicating respectively four signed
or unsigned elements packed into a single GLuint ; and the value `GL_UNSIGNED_INT_10F_11F_11F_REV`
indicating three floating point values packed into a single GLuint.

`glVertexAttribLFormat` and `glVertexArrayAttribLFormat` is used to specify layout for data
associated with a generic attribute variable declared as 64-bit double precision components. For
`glVertexAttribLFormat` and `glVertexArrayAttribLFormat`, `type` must be `GL_DOUBLE`. In
contrast to `glVertexAttribFormat` or `glVertexArrayAttribFormat`, which will cause data
declared as `GL_DOUBLE` to be converted to 32-bit representation, `glVertexAttribLFormat` and
`glVertexArrayAttribLFormat` cause such data to be left in its natural, 64-bit representation.

For `glVertexAttribFormat` and `glVertexArrayAttribFormat`, if `normalized` is `GL_TRUE`,
then integer data is normalized to the range [-1, 1] or [0, 1] if it is signed or unsigned,
respectively. If `normalized` is `GL_FALSE` then integer data is directly converted to floating
point.

`relativeoffset` is the offset, measured in basic machine units of the first element relative to
the start of the vertex buffer binding this attribute fetches from.

`glVertexAttribFormat` and `glVertexArrayAttribFormat` should be used to describe vertex
attribute layout for floating-point vertex attributes, `glVertexAttribIFormat` and
`glVertexArrayAttribIFormat` should be used to describe vertex attribute layout for integer vertex
attribute, and `glVertexAttribLFormat` and `glVertexArrayAttribLFormat` should be used to
describe the layout for 64-bit vertex attributes. Data for an array specified by
`glVertexAttribIFormat` and `glVertexArrayAttribIFormat` will always be left as integer values;
such data are referred to as pure integers.
---
### Notes
`GL_UNSIGNED_INT_10F_11F_11F_REV` is accepted for `type` only if the GL version is 4.4 or
higher.
---
### Errors
`GL_INVALID_VALUE` is generated if `attribindex` is greater than or equal to the value of
`GL_MAX_VERTEX_ATTRIBS`.

`GL_INVALID_VALUE` is generated if `size` is not one of the accepted values.

`GL_INVALID_VALUE` is generated if `relativeoffset` is greater than the value of
`GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET`.

`GL_INVALID_ENUM` is generated if `type` is not one of the accepted tokens.

`GL_INVALID_ENUM` is generated by `glVertexAttribIFormat`, `glVertexAttribLFormat`,
`glVertexArrayAttribIFormat` and `glVertexArrayAttribLFormat` if `type` is
`GL_UNSIGNED_INT_10F_11F_11F_REV`.

`GL_INVALID_OPERATION` is generated by `glVertexAttribFormat`, `glVertexAttribIFormat` and
`glVertexAttribLFormat` if no vertex array object is bound.

`GL_INVALID_OPERATION` is generated by `glVertexArrayAttribFormat`,
`glVertexArrayAttribIFormat` and `glVertexArrayAttribLFormat` if `vaobj` is not the name of an
existing vertex array object.

`GL_INVALID_OPERATION` is generated under any of the following conditions:

`size` is `GL_BGRA` and `type` is not `GL_UNSIGNED_BYTE`, `GL_INT_2_10_10_10_REV` or
`GL_UNSIGNED_INT_2_10_10_10_REV`.

`type` is `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, and `size` is
neither 4 nor `GL_BGRA`.

`type` is `GL_UNSIGNED_INT_10F_11F_11F_REV` and `size` is not 3.

`size` is `GL_BGRA` and `normalized` is `GL_FALSE`.

---
### Associated Gets
glGet with arguments `GL_MAX_VERTEX_ATTRIB_BINDINGS`, or
`GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET`.

glGetVertexAttrib with argument `GL_VERTEX_ATTRIB_RELATIVE_OFFSET`.
---
### Version Support
`glVertexArrayAttribFormat` `glVertexArrayAttribIFormat` `glVertexArrayAttribLFormat`
`glVertexAttribFormat` `glVertexAttribIFormat` `glVertexAttribLFormat`
---
### See Also
glBindVertexBuffer, glVertexAttribBinding, glVertexAttribPointer, glVertexBindingDivisor,
glVertexAttribPointer.
---
### Copyright
Copyright 2013-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Define an array of generic vertex attribute data
---
### Parameters
`index` Specifies the index of the generic vertex attribute to be modified.
`size` Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4.

Additionally, the symbolic constant `GL_BGRA` is accepted by `glVertexAttribPointer`. The
initial value is 4.

`type` Specifies the data type of each component in the array. The symbolic constants `GL_BYTE`,
`GL_UNSIGNED_BYTE`, `GL_SHORT`, `GL_UNSIGNED_SHORT`, `GL_INT`, and `GL_UNSIGNED_INT` are
accepted by `glVertexAttribPointer` and `glVertexAttribIPointer`. Additionally `GL_HALF_FLOAT`,
`GL_FLOAT`, `GL_DOUBLE`, `GL_FIXED`, `GL_INT_2_10_10_10_REV`,
`GL_UNSIGNED_INT_2_10_10_10_REV` and `GL_UNSIGNED_INT_10F_11F_11F_REV` are accepted by
`glVertexAttribPointer`. `GL_DOUBLE` is also accepted by `glVertexAttribLPointer` and is the
only token accepted by the `type` parameter for that function. The initial value is `GL_FLOAT`.

`normalized` For `glVertexAttribPointer`, specifies whether fixed-point data values should be
normalized ( `GL_TRUE` ) or converted directly as fixed-point values ( `GL_FALSE` ) when they are
accessed.

`stride` Specifies the byte offset between consecutive generic vertex attributes. If `stride`
is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial
value is 0.

`pointer` Specifies a offset of the first component of the first generic vertex attribute in the
array in the data store of the buffer currently bound to the `GL_ARRAY_BUFFER` target. The initial
value is 0.

---
### Description
`glVertexAttribPointer`, `glVertexAttribIPointer` and `glVertexAttribLPointer` specify the
location and data format of the array of generic vertex attributes at index `index` to use when
rendering. `size` specifies the number of components per attribute and must be 1, 2, 3, 4, or
`GL_BGRA`. `type` specifies the data type of each component, and `stride` specifies the byte
stride from one attribute to the next, allowing vertices and attributes to be packed into a single
array or stored in separate arrays.

For `glVertexAttribPointer`, if `normalized` is set to `GL_TRUE`, it indicates that values
stored in an integer format are to be mapped to the range [-1,1] (for signed values) or [0,1] (for
unsigned values) when they are accessed and converted to floating point. Otherwise, values will be
converted to floats directly without normalization.

For `glVertexAttribIPointer`, only the integer types `GL_BYTE`, `GL_UNSIGNED_BYTE`,
`GL_SHORT`, `GL_UNSIGNED_SHORT`, `GL_INT`, `GL_UNSIGNED_INT` are accepted. Values are always
left as integer values.

`glVertexAttribLPointer` specifies state for a generic vertex attribute array associated with a
shader attribute variable declared with 64-bit double precision components. `type` must be
`GL_DOUBLE`. `index`, `size`, and `stride` behave as described for `glVertexAttribPointer`
and `glVertexAttribIPointer`.

If `pointer` is not NULL, a non-zero named buffer object must be bound to the
`GL_ARRAY_BUFFER` target (see glBindBuffer ), otherwise an error is generated. `pointer` is
treated as a byte offset into the buffer object's data store. The buffer object binding (
`GL_ARRAY_BUFFER_BINDING` ) is saved as generic vertex attribute array state (
`GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING` ) for index `index`.

When a generic vertex attribute array is specified, `size`, `type`, `normalized`, `stride`,
and `pointer` are saved as vertex array state, in addition to the current vertex array buffer
object binding.

To enable and disable a generic vertex attribute array, call glEnableVertexAttribArray and
`glDisableVertexAttribArray` with `index`. If enabled, the generic vertex attribute array is used
when glDrawArrays, glMultiDrawArrays, glDrawElements, glMultiDrawElements, or
glDrawRangeElements is called.
---
### Notes
Each generic vertex attribute array is initially disabled and isn't accessed when glDrawElements,
glDrawRangeElements, glDrawArrays, glMultiDrawArrays, or glMultiDrawElements is
called.

`GL_UNSIGNED_INT_10F_11F_11F_REV` is accepted for `type` only if the GL version is 4.4 or
higher.
---
### Errors
`GL_INVALID_VALUE` is generated if `index` is greater than or equal to `GL_MAX_VERTEX_ATTRIBS`.

`GL_INVALID_VALUE` is generated if `size` is not 1, 2, 3, 4 or (for `glVertexAttribPointer` ),
`GL_BGRA`.

`GL_INVALID_ENUM` is generated if `type` is not an accepted value.

`GL_INVALID_VALUE` is generated if `stride` is negative.

`GL_INVALID_OPERATION` is generated if `size` is `GL_BGRA` and `type` is not
`GL_UNSIGNED_BYTE`, `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`.

`GL_INVALID_OPERATION` is generated if `type` is `GL_INT_2_10_10_10_REV` or
`GL_UNSIGNED_INT_2_10_10_10_REV` and `size` is not 4 or `GL_BGRA`.

`GL_INVALID_OPERATION` is generated if `type` is `GL_UNSIGNED_INT_10F_11F_11F_REV` and
`size` is not 3.

`GL_INVALID_OPERATION` is generated by `glVertexAttribPointer` if `size` is `GL_BGRA` and
`normalized` is `GL_FALSE`.

`GL_INVALID_OPERATION` is generated if zero is bound to the `GL_ARRAY_BUFFER` buffer object
binding point and the `pointer` argument is not `NULL`.
---
### Associated Gets
glGet with argument `GL_MAX_VERTEX_ATTRIBS`

glGetVertexAttrib with arguments `index` and `GL_VERTEX_ATTRIB_ARRAY_ENABLED`

glGetVertexAttrib with arguments `index` and `GL_VERTEX_ATTRIB_ARRAY_SIZE`

glGetVertexAttrib with arguments `index` and `GL_VERTEX_ATTRIB_ARRAY_TYPE`

glGetVertexAttrib with arguments `index` and `GL_VERTEX_ATTRIB_ARRAY_NORMALIZED`

glGetVertexAttrib with arguments `index` and `GL_VERTEX_ATTRIB_ARRAY_STRIDE`

glGetVertexAttrib with arguments `index` and `GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING`

glGet with argument `GL_ARRAY_BUFFER_BINDING`

glGetVertexAttribPointerv with arguments `index` and `GL_VERTEX_ATTRIB_ARRAY_POINTER`
---
### Version Support
`glVertexAttribIPointer` `glVertexAttribLPointer` `glVertexAttribPointer`
---
### See Also
glBindAttribLocation, glBindBuffer, `glDisableVertexAttribArray`, glDrawArrays,
glDrawElements, glDrawRangeElements, glEnableVertexAttribArray, glMultiDrawArrays,
glMultiDrawElements, glVertexAttrib
---
### Copyright
Copyright 2003-2005 3Dlabs Inc. Ltd. Copyright 2010-2014 Khronos Group. This material may be
distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8
June 1999. https://opencontent.org/openpub/.
]],
  [[Modify the rate at which generic vertex attributes advance
---
### Parameters
`vaobj` Specifies the name of the vertex array object for `glVertexArrayBindingDivisor`
function.

`bindingindex` The index of the binding whose divisor to modify.
`divisor` The new value for the instance step rate to apply.
---
### Description
`glVertexBindingDivisor` and `glVertexArrayBindingDivisor` modify the rate at which generic
vertex attributes advance when rendering multiple instances of primitives in a single draw command.

If `divisor` is zero, the attributes using the buffer bound to `bindingindex` advance once per
vertex. If `divisor` is non-zero, the attributes advance once per `divisor` instances of the
set(s) of vertices being rendered. An attribute is referred to as instanced if the corresponding
`divisor` value is non-zero.

`glVertexBindingDivisor` uses currently bound vertex array object, whereas
`glVertexArrayBindingDivisor` updates state of the vertex array object with ID `vaobj`.
---
### Errors
`GL_INVALID_VALUE` is generated if `bindingindex` is greater than or equal to the value of
`GL_MAX_VERTEX_ATTRIB_BINDINGS`.

`GL_INVALID_OPERATION` by `glVertexBindingDivisor` is generated if no vertex array object is
bound.

`GL_INVALID_OPERATION` is generated by `glVertexArrayBindingDivisor` if `vaobj` is not the
name of an existing vertex array object.
---
### Associated Gets
glGet with arguments `GL_MAX_VERTEX_ATTRIB_BINDINGS`, `GL_VERTEX_BINDING_DIVISOR`.
---
### Version Support
`glVertexArrayBindingDivisor` `glVertexBindingDivisor`
---
### See Also
glBindVertexBuffer, glVertexAttribBinding, glVertexAttribPointer, glVertexBindingDivisor,
glVertexAttribPointer.
---
### Copyright
Copyright 2013-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Set the viewport
---
### Parameters
`x` `y` Specify the lower left corner of the viewport rectangle, in pixels. The initial value
is (0,0).
`width` `height` Specify the width and height of the viewport. When a GL context is first
attached to a window, `width` and `height` are set to the dimensions of that window.
]],
  [[Set multiple viewports
---
### Parameters
`first` Specify the first viewport to set.
`count` Specify the number of viewports to set.
`v` Specify the address of an array containing the viewport parameters.
]],
  [[Set a specified viewport
---
### Parameters
`index` Specify the first viewport to set.
`x` `y` For `glViewportIndexedf`, specifies the lower left corner of the viewport rectangle,
in pixels. The initial value is (0,0).

`w` `h` For `glViewportIndexedf`, specifies the width and height of the viewport. When a GL
context is first attached to a window, `w` and `h` are set to the dimensions of that window.

`v` For `glViewportIndexedfv`, specifies the address of an array containing the viewport
parameters.
]],
  [[Instruct the GL server to block until the specified sync object becomes signaled
---
### Parameters
`sync` Specifies the sync object whose status to wait on.
`flags` A bitfield controlling the command flushing behavior. `flags` may be zero.

`timeout` Specifies the timeout that the server should wait before continuing. `timeout` must
be `GL_TIMEOUT_IGNORED`.

---
### Description
`glWaitSync` causes the GL server to block and wait until `sync` becomes signaled. `sync` is
the name of an existing sync object upon which to wait. `flags` and `timeout` are currently not
used and must be set to zero and the special value `GL_TIMEOUT_IGNORED`, respectively `flags`
and `timeout` are placeholders for anticipated future extensions of sync object capabilities. They
must have these reserved values in order that existing code calling `glWaitSync` operate properly
in the presence of such extensions. `glWaitSync` will always wait no longer than an implementation-dependent timeout. The duration
of this timeout in nanoseconds may be queried by calling glGet with the parameter
`GL_MAX_SERVER_WAIT_TIMEOUT`. There is currently no way to determine whether `glWaitSync`
unblocked because the timeout expired or because the sync object being waited on was signaled.

If an error occurs, `glWaitSync` does not cause the GL server to block.
---
### Notes
`glWaitSync` is available only if the GL version is 3.2 or higher.
---
### Errors
`GL_INVALID_VALUE` is generated if `sync` is not the name of a sync object.

`GL_INVALID_VALUE` is generated if `flags` is not zero.

`GL_INVALID_VALUE` is generated if `timeout` is not `GL_TIMEOUT_IGNORED`.
---
### Version Support
`glWaitSync`
---
### See Also
glFenceSync, glClientWaitSync
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Start conditional rendering
---
### Parameters for
`glBeginConditionalRender` `id` Specifies the name of an occlusion query object whose results
are used to determine if the rendering commands are discarded.
`mode` Specifies how `glBeginConditionalRender` interprets the results of the occlusion
query.

---
### Description
Conditional rendering is started using `glBeginConditionalRender` and ended using
`glEndConditionalRender`. During conditional rendering, all vertex array commands, as well as
glClear and glClearBuffer have no effect if the ( `GL_SAMPLES_PASSED` ) result of the query
object `id` is zero, or if the ( `GL_ANY_SAMPLES_PASSED` ) result is `GL_FALSE`. The results of
commands setting the current vertex state, such as glVertexAttrib are undefined. If the (
`GL_SAMPLES_PASSED` ) result is non-zero or if the ( `GL_ANY_SAMPLES_PASSED` ) result is `GL_TRUE`,
such commands are not discarded. The `id` parameter to `glBeginConditionalRender` must be the
name of a query object previously returned from a call to glGenQueries. `mode` specifies how
the results of the query object are to be interpreted. If `mode` is `GL_QUERY_WAIT`, the GL
waits for the results of the query to be available and then uses the results to determine if
subsequent rendering commands are discarded. If `mode` is `GL_QUERY_NO_WAIT`, the GL may choose
to unconditionally execute the subsequent rendering commands without waiting for the query to
complete.

If `mode` is `GL_QUERY_BY_REGION_WAIT`, the GL will also wait for occlusion query results and
discard rendering commands if the result of the occlusion query is zero. If the query result is
non-zero, subsequent rendering commands are executed, but the GL may discard the results of the
commands for any region of the framebuffer that did not contribute to the sample count in the
specified occlusion query. Any such discarding is done in an implementation-dependent manner, but
the rendering command results may not be discarded for any samples that contributed to the occlusion
query sample count. If `mode` is `GL_QUERY_BY_REGION_NO_WAIT`, the GL operates as in
`GL_QUERY_BY_REGION_WAIT`, but may choose to unconditionally execute the subsequent rendering
commands without waiting for the query to complete.
---
### Notes
`glBeginConditionalRender` and `glEndConditionalRender` are available only if the GL version is
3.0 or greater.

The `GL_ANY_SAMPLES_PASSED` query result is available only if the GL version is 3.3 or greater.

---
### Errors
`GL_INVALID_VALUE` is generated if `id` is not the name of an existing query object.

`GL_INVALID_ENUM` is generated if `mode` is not one of the accepted tokens.

`GL_INVALID_OPERATION` is generated if `glBeginConditionalRender` is called while conditional
rendering is active, or if `glEndConditionalRender` is called while conditional rendering is
inactive.

`GL_INVALID_OPERATION` is generated if `id` is the name of a query object with a target other
than `GL_SAMPLES_PASSED` or `GL_ANY_SAMPLES_PASSED`.

`GL_INVALID_OPERATION` is generated if `id` is the name of a query currently in progress.
---
### Version Support
`glBeginConditionalRender` `glEndConditionalRender`
---
### See Also
glGenQueries, glDeleteQueries, glBeginQuery
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Delimit the boundaries of a query object
---
### Parameters for
`glBeginQuery` `target` Specifies the target type of query object established between
`glBeginQuery` and the subsequent `glEndQuery`. The symbolic constant must be one of
`GL_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED_CONSERVATIVE`,
`GL_PRIMITIVES_GENERATED`, `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`, or `GL_TIME_ELAPSED`.

`id` Specifies the name of a query object.
---
### Parameters for
`glEndQuery` `target` Specifies the target type of query object to be concluded. The symbolic
constant must be one of `GL_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED`,
`GL_ANY_SAMPLES_PASSED_CONSERVATIVE`, `GL_PRIMITIVES_GENERATED`,
`GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`, or `GL_TIME_ELAPSED`.

---
### Description
`glBeginQuery` and `glEndQuery` delimit the boundaries of a query object. `query` must be a
name previously returned from a call to glGenQueries. If a query object with name `id` does not
yet exist it is created with the type determined by `target`. `target` must be one of
`GL_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED`, `GL_PRIMITIVES_GENERATED`,
`GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`, or `GL_TIME_ELAPSED`. The behavior of the query
object depends on its type and is as follows.

If `target` is `GL_SAMPLES_PASSED`, `id` must be an unused name, or the name of an existing
occlusion query object. When `glBeginQuery` is executed, the query object's samples-passed counter
is reset to 0. Subsequent rendering will increment the counter for every sample that passes the
depth test. If the value of `GL_SAMPLE_BUFFERS` is 0, then the samples-passed count is incremented
by 1 for each fragment. If the value of `GL_SAMPLE_BUFFERS` is 1, then the samples-passed count is
incremented by the number of samples whose coverage bit is set. However, implementations, at their
discression may instead increase the samples-passed count by the value of `GL_SAMPLES` if any
sample in the fragment is covered. When `glEndQuery` is executed, the samples-passed counter is
assigned to the query object's result value. This value can be queried by calling glGetQueryObject
with `pname` `GL_QUERY_RESULT`.

If `target` is `GL_ANY_SAMPLES_PASSED` or `GL_ANY_SAMPLES_PASSED_CONSERVATIVE`, `id` must
be an unused name, or the name of an existing boolean occlusion query object. When `glBeginQuery`
is executed, the query object's samples-passed flag is reset to `GL_FALSE`. Subsequent rendering
causes the flag to be set to `GL_TRUE` if any sample passes the depth test in the case of
`GL_ANY_SAMPLES_PASSED`, or if the implementation determines that any sample might pass the depth
test in the case of `GL_ANY_SAMPLES_PASSED_CONSERVATIVE`. The implementation may be able to
provide a more efficient test in the case of `GL_ANY_SAMPLES_PASSED_CONSERVATIVE` if some false
positives are acceptable to the application. When `glEndQuery` is executed, the samples-passed
flag is assigned to the query object's result value. This value can be queried by calling
glGetQueryObject with `pname` `GL_QUERY_RESULT`.

If `target` is `GL_PRIMITIVES_GENERATED`, `id` must be an unused name, or the name of an
existing primitive query object previously bound to the `GL_PRIMITIVES_GENERATED` query binding.

When `glBeginQuery` is executed, the query object's primitives-generated counter is reset to 0.

Subsequent rendering will increment the counter once for every vertex that is emitted from the
geometry shader, or from the vertex shader if no geometry shader is present. When `glEndQuery` is
executed, the primitives-generated counter is assigned to the query object's result value. This
value can be queried by calling glGetQueryObject with `pname` `GL_QUERY_RESULT`.

If `target` is `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`, `id` must be an unused name, or
the name of an existing primitive query object previously bound to the
`GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN` query binding. When `glBeginQuery` is executed, the
query object's primitives-written counter is reset to 0. Subsequent rendering will increment the
counter once for every vertex that is written into the bound transform feedback buffer(s). If
transform feedback mode is not activated between the call to `glBeginQuery` and `glEndQuery`,
the counter will not be incremented. When `glEndQuery` is executed, the primitives-written counter
is assigned to the query object's result value. This value can be queried by calling
glGetQueryObject with `pname` `GL_QUERY_RESULT`.

If `target` is `GL_TIME_ELAPSED`, `id` must be an unused name, or the name of an existing
timer query object previously bound to the `GL_TIME_ELAPSED` query binding. When `glBeginQuery`
is executed, the query object's time counter is reset to 0. When `glEndQuery` is executed, the
elapsed server time that has passed since the call to `glBeginQuery` is written into the query
object's time counter. This value can be queried by calling glGetQueryObject with `pname`
`GL_QUERY_RESULT`.

Querying the `GL_QUERY_RESULT` implicitly flushes the GL pipeline until the rendering delimited
by the query object has completed and the result is available. `GL_QUERY_RESULT_AVAILABLE` can be
queried to determine if the result is immediately available or if the rendering is not yet complete.

---
### Notes
If the query target's count exceeds the maximum value representable in the number of available
bits, as reported by glGetQueryiv with `target` set to the appropriate query target and
`pname` `GL_QUERY_COUNTER_BITS`, the count becomes undefined.

An implementation may support 0 bits in its counter, in which case query results are always
undefined and essentially useless. When `GL_SAMPLE_BUFFERS` is 0, the samples-passed counter of
an occlusion query will increment once for each fragment that passes the depth test. When
`GL_SAMPLE_BUFFERS` is 1, an implementation may either increment the samples-passed counter
individually for each sample of a fragment that passes the depth test, or it may choose to increment
the counter for all samples of a fragment if any one of them passes the depth test.

The query targets `GL_ANY_SAMPLES_PASSED`, and `GL_TIME_ELAPSED` are availale only if the GL
version is 3.3 or higher.

The query target `GL_ANY_SAMPLES_PASSED_CONSERVATIVE` is available only of the GL version is 4.3
or higher.
---
### Errors
`GL_INVALID_ENUM` is generated if `target` is not one of the accepted tokens.

`GL_INVALID_OPERATION` is generated if `glBeginQuery` is executed while a query object of the
same `target` is already active.

`GL_INVALID_OPERATION` is generated if `glEndQuery` is executed when a query object of the same
`target` is not active.

`GL_INVALID_OPERATION` is generated if `id` is 0.

`GL_INVALID_OPERATION` is generated if `id` is the name of an already active query object.

`GL_INVALID_OPERATION` is generated if `id` refers to an existing query object whose type does
not does not match `target`.
---
### Version Support
`glBeginQuery` `glEndQuery`
---
### See Also
glBeginQueryIndexed, glDeleteQueries, `glEndQuery`, glGenQueries, glGetQueryObject,
glGetQueryiv, glIsQuery
---
### Copyright
Copyright 2005 Addison-Wesley. Copyright 2010-2014 Khronos Group. This material may be
distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8
June 1999. https://opencontent.org/openpub/.
]],
  [[Delimit the boundaries of a query object on an indexed target
---
### Parameters for
`glBeginQueryIndexed` `target` Specifies the target type of query object established between
`glBeginQueryIndexed` and the subsequent `glEndQueryIndexed`. The symbolic constant must be one
of `GL_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED`, `GL_PRIMITIVES_GENERATED`,
`GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`, or `GL_TIME_ELAPSED`.

`index` Specifies the index of the query target upon which to begin the query.
`id` Specifies the name of a query object.
---
### Parameters for
`glEndQueryIndexed` `target` Specifies the target type of query object to be concluded. The
symbolic constant must be one of `GL_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED`,
`GL_PRIMITIVES_GENERATED`, `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`, or `GL_TIME_ELAPSED`.

`index` Specifies the index of the query target upon which to end the query.
---
### Description
`glBeginQueryIndexed` and `glEndQueryIndexed` delimit the boundaries of a query object.
`query` must be a name previously returned from a call to glGenQueries. If a query object with
name `id` does not yet exist it is created with the type determined by `target`. `target` must
be one of `GL_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED`, `GL_PRIMITIVES_GENERATED`,
`GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`, or `GL_TIME_ELAPSED`. The behavior of the query
object depends on its type and is as follows.

`index` specifies the index of the query target and must be between a `target` -specific
maximum.

If `target` is `GL_SAMPLES_PASSED`, `id` must be an unused name, or the name of an existing
occlusion query object. When `glBeginQueryIndexed` is executed, the query object's samples-passed
counter is reset to 0. Subsequent rendering will increment the counter for every sample that passes
the depth test. If the value of `GL_SAMPLE_BUFFERS` is 0, then the samples-passed count is
incremented by 1 for each fragment. If the value of `GL_SAMPLE_BUFFERS` is 1, then the
samples-passed count is incremented by the number of samples whose coverage bit is set. However,
implementations, at their discression may instead increase the samples-passed count by the value of
`GL_SAMPLES` if any sample in the fragment is covered. When `glEndQueryIndexed` is executed, the
samples-passed counter is assigned to the query object's result value. This value can be queried by
calling glGetQueryObject with `pname` `GL_QUERY_RESULT`. When `target` is
`GL_SAMPLES_PASSED`, `index` must be zero.

If `target` is `GL_ANY_SAMPLES_PASSED`, `id` must be an unused name, or the name of an
existing boolean occlusion query object. When `glBeginQueryIndexed` is executed, the query
object's samples-passed flag is reset to `GL_FALSE`. Subsequent rendering causes the flag to be
set to `GL_TRUE` if any sample passes the depth test. When `glEndQueryIndexed` is executed, the
samples-passed flag is assigned to the query object's result value. This value can be queried by
calling glGetQueryObject with `pname` `GL_QUERY_RESULT`. When `target` is
`GL_ANY_SAMPLES_PASSED`, `index` must be zero.

If `target` is `GL_PRIMITIVES_GENERATED`, `id` must be an unused name, or the name of an
existing primitive query object previously bound to the `GL_PRIMITIVES_GENERATED` query binding.

When `glBeginQueryIndexed` is executed, the query object's primitives-generated counter is reset
to 0. Subsequent rendering will increment the counter once for every vertex that is emitted from the
geometry shader to the stream given by `index`, or from the vertex shader if `index` is zero and
no geometry shader is present. When `glEndQueryIndexed` is executed, the primitives-generated
counter for stream `index` is assigned to the query object's result value. This value can be
queried by calling glGetQueryObject with `pname` `GL_QUERY_RESULT`. When `target` is
`GL_PRIMITIVES_GENERATED`, `index` must be less than the value of `GL_MAX_VERTEX_STREAMS`.

If `target` is `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`, `id` must be an unused name, or
the name of an existing primitive query object previously bound to the
`GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN` query binding. When `glBeginQueryIndexed` is executed,
the query object's primitives-written counter for the stream specified by `index` is reset to 0.

Subsequent rendering will increment the counter once for every vertex that is written into the bound
transform feedback buffer(s) for stream `index`. If transform feedback mode is not activated
between the call to `glBeginQueryIndexed` and `glEndQueryIndexed`, the counter will not be
incremented. When `glEndQueryIndexed` is executed, the primitives-written counter for stream
`index` is assigned to the query object's result value. This value can be queried by calling
glGetQueryObject with `pname` `GL_QUERY_RESULT`. When `target` is
`GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`, `index` must be less than the value of
`GL_MAX_VERTEX_STREAMS`.

If `target` is `GL_TIME_ELAPSED`, `id` must be an unused name, or the name of an existing
timer query object previously bound to the `GL_TIME_ELAPSED` query binding. When
`glBeginQueryIndexed` is executed, the query object's time counter is reset to 0. When
`glEndQueryIndexed` is executed, the elapsed server time that has passed since the call to
`glBeginQueryIndexed` is written into the query object's time counter. This value can be queried by
calling glGetQueryObject with `pname` `GL_QUERY_RESULT`. When `target` is `GL_TIME_ELAPSED`,
`index` must be zero.

Querying the `GL_QUERY_RESULT` implicitly flushes the GL pipeline until the rendering delimited
by the query object has completed and the result is available. `GL_QUERY_RESULT_AVAILABLE` can be
queried to determine if the result is immediately available or if the rendering is not yet complete.

---
### Notes
If the query target's count exceeds the maximum value representable in the number of available
bits, as reported by glGetQueryiv with `target` set to the appropriate query target and
`pname` `GL_QUERY_COUNTER_BITS`, the count becomes undefined.

An implementation may support 0 bits in its counter, in which case query results are always
undefined and essentially useless. When `GL_SAMPLE_BUFFERS` is 0, the samples-passed counter of
an occlusion query will increment once for each fragment that passes the depth test. When
`GL_SAMPLE_BUFFERS` is 1, an implementation may either increment the samples-passed counter
individually for each sample of a fragment that passes the depth test, or it may choose to increment
the counter for all samples of a fragment if any one of them passes the depth test.

Calling glBeginQuery or `glEndQuery` is equivalent to calling glBeginQueryIndexed or
`glEndQueryIndexed` with `index` set to zero, respectively.
---
### Errors
`GL_INVALID_ENUM` is generated if `target` is not one of the accepted tokens.

`GL_INVALID_VALUE` is generated if `index` is greater than the query target-specific maximum.

`GL_INVALID_OPERATION` is generated if `glBeginQueryIndexed` is executed while a query object
of the same `target` is already active.

`GL_INVALID_OPERATION` is generated if `glEndQueryIndexed` is executed when a query object of
the same `target` is not active.

`GL_INVALID_OPERATION` is generated if `id` is 0.

`GL_INVALID_OPERATION` is generated if `id` is the name of an already active query object.

`GL_INVALID_OPERATION` is generated if `id` refers to an existing query object whose type does
not does not match `target`.
---
### Version Support
`glBeginQueryIndexed` `glEndQueryIndexed`
---
### See Also
glBeginQuery, glDeleteQueries, `glEndQuery`, glGenQueries, glGetQueryObject,
glGetQueryiv, glIsQuery
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Start transform feedback operation
---
### Parameters for
`glBeginTransformFeedback` `primitiveMode` Specify the output type of the primitives that will
be recorded into the buffer objects that are bound for transform feedback.
---
### Description
Transform feedback mode captures the values of varying variables written by the vertex shader (or,
if active, the geometry shader). Transform feedback is said to be active after a call to
`glBeginTransformFeedback` until a subsequent call to `glEndTransformFeedback`. Transform
feedback commands must be paired.

If no geometry shader is present, while transform feedback is active the `mode` parameter to
glDrawArrays must match those specified in the following table:

Transform Feedback `primitiveMode` Allowed Render Primitive `modes` `GL_POINTS`
`GL_POINTS` `GL_LINES` `GL_LINES`, `GL_LINE_LOOP`, `GL_LINE_STRIP`, `GL_LINES_ADJACENCY`,
`GL_LINE_STRIP_ADJACENCY` `GL_TRIANGLES` `GL_TRIANGLES`, `GL_TRIANGLE_STRIP`,
`GL_TRIANGLE_FAN`, `GL_TRIANGLES_ADJACENCY`, `GL_TRIANGLE_STRIP_ADJACENCY` If a geometry shader
is present, the output primitive type from the geometry shader must match those provided in the
following table: Transform Feedback `primitiveMode` Allowed Geometry Shader Output
Primitive Type `GL_POINTS` `points` `GL_LINES` `line_strip` `GL_TRIANGLES`
`triangle_strip`
---
### Notes
Geometry shaders, and the `GL_TRIANGLES_ADJACENCY`, `GL_TRIANGLE_STRIP_ADJACENCY`,
`GL_LINES_ADJACENCY` and `GL_LINE_STRIP_ADJACENCY` primtive modes are available only if the GL
version is 3.2 or greater.
---
### Errors
`GL_INVALID_OPERATION` is generated if `glBeginTransformFeedback` is executed while transform
feedback is active.

`GL_INVALID_OPERATION` is generated if `glEndTransformFeedback` is executed while transform
feedback is not active.

`GL_INVALID_OPERATION` is generated by glDrawArrays if no geometry shader is present,
transform feedback is active and `mode` is not one of the allowed modes.

`GL_INVALID_OPERATION` is generated by glDrawArrays if a geometry shader is present, transform
feedback is active and the output primitive type of the geometry shader does not match the transform
feedback `primitiveMode`.

`GL_INVALID_OPERATION` is generated by `glBeginTransformFeedback` if any binding point used in
transform feedback mode does not have a buffer object bound.

`GL_INVALID_OPERATION` is generated by `glBeginTransformFeedback` if no binding points would be
used, either because no program object is active of because the active program object has specified
no varying variables to record.
---
### Version Support
`glBeginTransformFeedback` `glEndTransformFeedback`
---
### See Also
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Associates a generic vertex attribute index with a named attribute variable
---
### Parameters
`program` Specifies the handle of the program object in which the association is to be made.
`index` Specifies the index of the generic vertex attribute to be bound.
`name` Specifies a null terminated string containing the name of the vertex shader attribute
variable to which `index` is to be bound.

---
### Description
`glBindAttribLocation` is used to associate a user-defined attribute variable in the program
object specified by `program` with a generic vertex attribute index. The name of the user-defined
attribute variable is passed as a null terminated string in `name`. The generic vertex attribute
index to be bound to this variable is specified by `index`. When `program` is made part of
current state, values provided via the generic vertex attribute `index` will modify the value of
the user-defined attribute variable specified by `name`.

If `name` refers to a matrix attribute variable, `index` refers to the first column of the
matrix. Other matrix columns are then automatically bound to locations `index+1` for a matrix of
type `mat2` ; `index+1` and `index+2` for a matrix of type `mat3` ; and `index+1`,
`index+2`, and `index+3` for a matrix of type `mat4`.

This command makes it possible for vertex shaders to use descriptive names for attribute variables
rather than generic variables that are numbered from zero to the value of `GL_MAX_VERTEX_ATTRIBS`
minus one. The values sent to each generic attribute index are part of current state. If a different
program object is made current by calling glUseProgram, the generic vertex attributes are tracked
in such a way that the same values will be observed by attributes in the new program object that are
also bound to `index`.

Attribute variable name-to-generic attribute index bindings for a program object can be explicitly
assigned at any time by calling `glBindAttribLocation`. Attribute bindings do not go into effect
until glLinkProgram is called. After a program object has been linked successfully, the index
values for generic attributes remain fixed (and their values can be queried) until the next link
command occurs.

Any attribute binding that occurs after the program object has been linked will not take effect
until the next time the program object is linked.
---
### Notes
`glBindAttribLocation` can be called before any vertex shader objects are bound to the specified
program object. It is also permissible to bind a generic attribute index to an attribute variable
name that is never used in a vertex shader.

If `name` was bound previously, that information is lost. Thus you cannot bind one user-defined
attribute variable to multiple indices, but you can bind multiple user-defined attribute variables
to the same index.

Applications are allowed to bind more than one user-defined attribute variable to the same generic
vertex attribute index. This is called aliasing, and it is allowed only if just one of the aliased
attributes is active in the executable program, or if no path through the shader consumes more than
one attribute of a set of attributes aliased to the same location. The compiler and linker are
allowed to assume that no aliasing is done and are free to employ optimizations that work only in
the absence of aliasing. OpenGL implementations are not required to do error checking to detect
aliasing.

Active attributes that are not explicitly bound will be bound by the linker when glLinkProgram
is called. The locations assigned can be queried by calling glGetAttribLocation.

OpenGL copies the `name` string when `glBindAttribLocation` is called, so an application may
free its copy of the `name` string immediately after the function returns.

Generic attribute locations may be specified in the shader source text using a `location` layout
qualifier. In this case, the location of the attribute specified in the shader's source takes
precedence and may be queried by calling glGetAttribLocation.
---
### Errors
`GL_INVALID_VALUE` is generated if `index` is greater than or equal to `GL_MAX_VERTEX_ATTRIBS`.

`GL_INVALID_OPERATION` is generated if `name` starts with the reserved prefix \\\"gl_\\\".

`GL_INVALID_VALUE` is generated if `program` is not a value generated by OpenGL.

`GL_INVALID_OPERATION` is generated if `program` is not a program object.
---
### Associated Gets
glGet with argument `GL_MAX_VERTEX_ATTRIBS`

glGetActiveAttrib with argument `program`

glGetAttribLocation with arguments `program` and `name`

glIsProgram
---
### Version Support
`glBindAttribLocation`
---
### See Also
`glDisableVertexAttribArray`, glEnableVertexAttribArray, glUseProgram, glVertexAttrib,
glVertexAttribPointer
---
### Copyright
Copyright 2003-2005 3Dlabs Inc. Ltd. Copyright 2010-2014 Khronos Group. This material may be
distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8
June 1999. https://opencontent.org/openpub/.
]],
  [[Bind a named buffer object
---
### Parameters
`target` Specifies the target to which the buffer object is bound, which must be one of the
buffer binding targets in the following table:
`buffer` Specifies the name of a buffer object.
---
### Description
`glBindBuffer` binds a buffer object to the specified buffer binding point. Calling
`glBindBuffer` with `target` set to one of the accepted symbolic constants and `buffer` set to
the name of a buffer object binds that buffer object name to the target. If no buffer object with
name `buffer` exists, one is created with that name. When a buffer object is bound to a target,
the previous binding for that target is automatically broken.

Buffer object names are unsigned integers. The value zero is reserved, but there is no default
buffer object for each buffer object target. Instead, `buffer` set to zero effectively unbinds any
buffer object previously bound, and restores client memory usage for that buffer object target (if
supported for that target). Buffer object names and the corresponding buffer object contents are
local to the shared object space of the current GL rendering context; two rendering contexts share
buffer object names only if they explicitly enable sharing between contexts through the appropriate
GL windows interfaces functions.

glGenBuffers must be used to generate a set of unused buffer object names.

The state of a buffer object immediately after it is first bound is an unmapped zero-sized memory
buffer with `GL_READ_WRITE` access and `GL_STATIC_DRAW` usage.

While a non-zero buffer object name is bound, GL operations on the target to which it is bound
affect the bound buffer object, and queries of the target to which it is bound return state from the
bound buffer object. While buffer object name zero is bound, as in the initial state, attempts to
modify or query state on the target to which it is bound generates an `GL_INVALID_OPERATION`
error.

When a non-zero buffer object is bound to the `GL_ARRAY_BUFFER` target, the vertex array pointer
parameter is interpreted as an offset within the buffer object measured in basic machine units.

When a non-zero buffer object is bound to the `GL_DRAW_INDIRECT_BUFFER` target, parameters for
draws issued through glDrawArraysIndirect and glDrawElementsIndirect are sourced from the
specified offset in that buffer object's data store.

When a non-zero buffer object is bound to the `GL_DISPATCH_INDIRECT_BUFFER` target, the
parameters for compute dispatches issued through glDispatchComputeIndirect are sourced from the
specified offset in that buffer object's data store.

While a non-zero buffer object is bound to the `GL_ELEMENT_ARRAY_BUFFER` target, the indices
parameter of glDrawElements, glDrawElementsInstanced, glDrawElementsBaseVertex,
glDrawRangeElements, glDrawRangeElementsBaseVertex, glMultiDrawElements, or
glMultiDrawElementsBaseVertex is interpreted as an offset within the buffer object measured in
basic machine units.

While a non-zero buffer object is bound to the `GL_PIXEL_PACK_BUFFER` target, the following
commands are affected: glGetCompressedTexImage, glGetTexImage, and glReadPixels. The
pointer parameter is interpreted as an offset within the buffer object measured in basic machine
units.

While a non-zero buffer object is bound to the `GL_PIXEL_UNPACK_BUFFER` target, the following
commands are affected: glCompressedTexImage1D, glCompressedTexImage2D,
glCompressedTexImage3D, glCompressedTexSubImage1D, glCompressedTexSubImage2D,
glCompressedTexSubImage3D, glTexImage1D, glTexImage2D, glTexImage3D, glTexSubImage1D,
glTexSubImage2D, and glTexSubImage3D. The pointer parameter is interpreted as an offset within
the buffer object measured in basic machine units.

The buffer targets `GL_COPY_READ_BUFFER` and `GL_COPY_WRITE_BUFFER` are provided to allow
glCopyBufferSubData to be used without disturbing the state of other bindings. However,
glCopyBufferSubData may be used with any pair of buffer binding points.

The `GL_TRANSFORM_FEEDBACK_BUFFER` buffer binding point may be passed to `glBindBuffer`, but
will not directly affect transform feedback state. Instead, the indexed
`GL_TRANSFORM_FEEDBACK_BUFFER` bindings must be used through a call to glBindBufferBase or
glBindBufferRange. This will affect the generic `GL_TRANSFORM_FEEDBACK_BUFFER` binding.

Likewise, the `GL_UNIFORM_BUFFER`, `GL_ATOMIC_COUNTER_BUFFER` and `GL_SHADER_STORAGE_BUFFER`
buffer binding points may be used, but do not directly affect uniform buffer, atomic counter buffer
or shader storage buffer state, respectively. glBindBufferBase or glBindBufferRange must be
used to bind a buffer to an indexed uniform buffer, atomic counter buffer or shader storage buffer
binding point.

The `GL_QUERY_BUFFER` binding point is used to specify a buffer object that is to receive the
results of query objects through calls to the glGetQueryObject family of commands.

A buffer object binding created with `glBindBuffer` remains active until a different buffer
object name is bound to the same target, or until the bound buffer object is deleted with
glDeleteBuffers.

Once created, a named buffer object may be re-bound to any target as often as needed. However, the
GL implementation may make choices about how to optimize the storage of a buffer object based on its
initial binding target.
---
### Notes
The `GL_COPY_READ_BUFFER`, `GL_UNIFORM_BUFFER` and `GL_TEXTURE_BUFFER` targets are available
only if the GL version is 3.1 or greater.

The `GL_ATOMIC_COUNTER_BUFFER` target is available only if the GL version is 4.2 or greater.

The `GL_DISPATCH_INDIRECT_BUFFER` and `GL_SHADER_STORAGE_BUFFER` targets are available only if
the GL version is 4.3 or greater.

The `GL_QUERY_BUFFER` target is available only if the GL version is 4.4 or greater.
---
### Errors
`GL_INVALID_ENUM` is generated if `target` is not one of the allowable values.

`GL_INVALID_VALUE` is generated if `buffer` is not a name previously returned from a call to
glGenBuffers.
---
### Associated Gets
glGet with argument `GL_ARRAY_BUFFER_BINDING`

glGet with argument `GL_ATOMIC_COUNTER_BUFFER_BINDING`

glGet with argument `GL_COPY_READ_BUFFER_BINDING`

glGet with argument `GL_COPY_WRITE_BUFFER_BINDING`

glGet with argument `GL_DRAW_INDIRECT_BUFFER_BINDING`

glGet with argument `GL_DISPATCH_INDIRECT_BUFFER_BINDING`

glGet with argument `GL_ELEMENT_ARRAY_BUFFER_BINDING`

glGet with argument `GL_PIXEL_PACK_BUFFER_BINDING`

glGet with argument `GL_PIXEL_UNPACK_BUFFER_BINDING`

glGet with argument `GL_SHADER_STORAGE_BUFFER_BINDING`

glGet with argument `GL_TRANSFORM_FEEDBACK_BUFFER_BINDING`

glGet with argument `GL_UNIFORM_BUFFER_BINDING`
---
### Version Support
`glBindBuffer`
---
### See Also
glGenBuffers, glBindBufferBase, glBindBufferRange, glMapBuffer, glUnmapBuffer,
glDeleteBuffers, glGet, glIsBuffer
---
### Copyright
Copyright 2005 Addison-Wesley. Copyright 2010-2014 Khronos Group. This material may be
distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8
June 1999. https://opencontent.org/openpub/.
]],
  [[Bind a buffer object to an indexed buffer target
---
### Parameters
`target` Specify the target of the bind operation. `target` must be one of
`GL_ATOMIC_COUNTER_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, `GL_UNIFORM_BUFFER` or
`GL_SHADER_STORAGE_BUFFER`.

`index` Specify the index of the binding point within the array specified by `target`.

`buffer` The name of a buffer object to bind to the specified binding point.
---
### Description
`glBindBufferBase` binds the buffer object `buffer` to the binding point at index `index` of
the array of targets specified by `target`. Each `target` represents an indexed array of buffer
binding points, as well as a single general binding point that can be used by other buffer
manipulation functions such as glBindBuffer or glMapBuffer. In addition to binding `buffer`
to the indexed buffer binding target, `glBindBufferBase` also binds `buffer` to the generic
buffer binding point specified by `target`.
---
### Notes
Calling `glBindBufferBase` is equivalent to calling glBindBufferRange with `offset` zero
and `size` equal to the size of the buffer.

The `GL_ATOMIC_COUNTER_BUFFER` target is available only if the GL version is 4.2 or greater.

The `GL_SHADER_STORAGE_BUFFER` target is available only if the GL version is 4.3 or greater.
---
### Errors
`GL_INVALID_ENUM` is generated if `target` is not `GL_ATOMIC_COUNTER_BUFFER`,
`GL_TRANSFORM_FEEDBACK_BUFFER`, `GL_UNIFORM_BUFFER` or `GL_SHADER_STORAGE_BUFFER`.

`GL_INVALID_VALUE` is generated if `index` is greater than or equal to the number of `target`
-specific indexed binding points.

`GL_INVALID_VALUE` is generated if `buffer` does not have an associated data store, or if the
size of that store is zero.
---
### Version Support
`glBindBufferBase`
---
### See Also
glGenBuffers, glDeleteBuffers, glBindBuffer, glBindBufferRange, glMapBuffer,
glUnmapBuffer,
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Bind a range within a buffer object to an indexed buffer target
---
### Parameters
`target` Specify the target of the bind operation. `target` must be one of
`GL_ATOMIC_COUNTER_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, `GL_UNIFORM_BUFFER`, or
`GL_SHADER_STORAGE_BUFFER`.

`index` Specify the index of the binding point within the array specified by `target`.

`buffer` The name of a buffer object to bind to the specified binding point.
`offset` The starting offset in basic machine units into the buffer object `buffer`.

`size` The amount of data in machine units that can be read from the buffer object while used
as an indexed target.
---
### Description
`glBindBufferRange` binds a range the buffer object `buffer` represented by `offset` and
`size` to the binding point at index `index` of the array of targets specified by `target`.

Each `target` represents an indexed array of buffer binding points, as well as a single general
binding point that can be used by other buffer manipulation functions such as glBindBuffer or
glMapBuffer. In addition to binding a range of `buffer` to the indexed buffer binding target,
`glBindBufferRange` also binds the range to the generic buffer binding point specified by `target`.

`offset` specifies the offset in basic machine units into the buffer object `buffer` and
`size` specifies the amount of data that can be read from the buffer object while used as an
indexed target.
---
### Notes
The `GL_ATOMIC_COUNTER_BUFFER` target is available only if the GL version is 4.2 or greater.

The `GL_SHADER_STORAGE_BUFFER` target is available only if the GL version is 4.3 or greater.
---
### Errors
`GL_INVALID_ENUM` is generated if `target` is not one of `GL_ATOMIC_COUNTER_BUFFER`,
`GL_TRANSFORM_FEEDBACK_BUFFER`, `GL_UNIFORM_BUFFER` or `GL_SHADER_STORAGE_BUFFER`.

`GL_INVALID_VALUE` is generated if `index` is greater than or equal to the number of `target`
-specific indexed binding points.

`GL_INVALID_VALUE` is generated if `size` is less than or equal to zero, or if `offset` +
`size` is greater than the value of `GL_BUFFER_SIZE`.

Additional errors may be generated if `offset` violates any `target` -specific alignmemt
restrictions.
---
### Version Support
`glBindBufferRange`
---
### See Also
glGenBuffers, glDeleteBuffers, glBindBuffer, glBindBufferBase, glMapBuffer,
glUnmapBuffer,
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Bind one or more buffer objects to a sequence of indexed buffer targets
---
### Parameters
`target` Specify the target of the bind operation. `target` must be one of
`GL_ATOMIC_COUNTER_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, `GL_UNIFORM_BUFFER` or
`GL_SHADER_STORAGE_BUFFER`.

`first` Specify the index of the first binding point within the array specified by `target`.


`count` Specify the number of contiguous binding points to which to bind buffers.
`buffers` A pointer to an array of names of buffer objects to bind to the targets on the
specified binding point, or `NULL`.

---
### Description
`glBindBuffersBase` binds a set of `count` buffer objects whose names are given in the array
`buffers` to the `count` consecutive binding points starting from index `first` of the array of
targets specified by `target`. If `buffers` is `NULL` then `glBindBuffersBase` unbinds any
buffers that are currently bound to the referenced binding points. Assuming no errors are generated,
it is equivalent to the following pseudo-code, which calls glBindBufferBase, with the exception
that the non-indexed `target` is not changed by `glBindBuffersBase` :

for (i = 0; i < count; i++) { if (buffers != NULL) { glBindBufferBase(target, first + i,
buffers[i]); } else { glBindBufferBase(target, first + i, 0); } } Each entry in `buffers` will be
checked individually and if found to be invalid, the state for that buffer binding index will not be
changed and an error will be generated. However, the state for other buffer binding indices
referenced by the command will still be updated.
---
### Notes
`glBindBuffersBase` is available only if the GL version is 4.4 or higher.
---
### Errors
`GL_INVALID_ENUM` is generated if `target` is not `GL_ATOMIC_COUNTER_BUFFER`,
`GL_TRANSFORM_FEEDBACK_BUFFER`, `GL_UNIFORM_BUFFER` or `GL_SHADER_STORAGE_BUFFER`.

`GL_INVALID_OPERATION` is generated if `first` + `count` is greater than the number of
target-specific indexed binding points.

`GL_INVALID_OPERATION` is generated if any value in `buffers` is not zero or the name of an
existing buffer object.
---
### Version Support
`glBindBuffersBase`
---
### See Also
glGenBuffers, glDeleteBuffers, glBindBuffer, glBindBufferBase, glBindBufferRange,
glBindBuffersRange, glMapBuffer, glUnmapBuffer
---
### Copyright
Copyright 2013-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Bind ranges of one or more buffer objects to a sequence of indexed buffer targets
---
### Parameters
`target` Specify the target of the bind operation. `target` must be one of
`GL_ATOMIC_COUNTER_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, `GL_UNIFORM_BUFFER` or
`GL_SHADER_STORAGE_BUFFER`.

`first` Specify the index of the first binding point within the array specified by `target`.


`count` Specify the number of contiguous binding points to which to bind buffers.
`buffers` A pointer to an array of names of buffer objects to bind to the targets on the
specified binding point, or `NULL`.

`offsets` A pointer to an array of offsets into the corresponding buffer in `buffers` to
bind, or `NULL` if `buffers` is `NULL`.

`sizes` A pointer to an array of sizes of the corresponding buffer in `buffers` to bind, or
`NULL` if `buffers` is `NULL`.

---
### Description
`glBindBuffersRange` binds a set of `count` ranges from buffer objects whose names are given in
the array `buffers` to the `count` consecutive binding points starting from index `first` of
the array of targets specified by `target`. `offsets` specifies the address of an array
containing `count` starting offsets within the buffers, and `sizes` specifies the address of an
array of `count` sizes of the ranges. If `buffers` is `NULL` then `offsets` and `sizes`
are ignored and `glBindBuffersRange` unbinds any buffers that are currently bound to the
referenced binding points. Assuming no errors are generated, it is equivalent to the following
pseudo-code, which calls glBindBufferRange, with the exception that the non-indexed `target` is
not changed by `glBindBuffersRange` :

for (i = 0; i < count; i++) { if (buffers != NULL) { glBindBufferRange(target, first + i,
buffers[i], offsets[i], sizes[i]); } else { glBindBufferRange(target, first + i, 0); } } Each entry
in `buffers`, `offsets`, and `sizes` will be checked individually and if found to be invalid,
the state for that buffer binding index will not be changed and an error will be generated. However,
the state for other buffer binding indices referenced by the command will still be updated.
---
### Notes
`glBindBuffersBase` is available only if the GL version is 4.4 or higher.
---
### Errors
`GL_INVALID_ENUM` is generated if `target` is not `GL_ATOMIC_COUNTER_BUFFER`,
`GL_TRANSFORM_FEEDBACK_BUFFER`, `GL_UNIFORM_BUFFER` or `GL_SHADER_STORAGE_BUFFER`.

`GL_INVALID_OPERATION` is generated if `first` + `count` is greater than the number of
target-specific indexed binding points.

`GL_INVALID_OPERATION` is generated if any value in `buffers` is not zero or the name of an
existing buffer object.

`GL_INVALID_VALUE` is generated by if any value in `offsets` is less than zero or if any value
in `sizes` is less than zero.

`GL_INVALID_VALUE` is generated if any pair of values in `offsets` and `sizes` does not
respectively satisfy the constraints described for those parameters for the specified target.
---
### Version Support
`glBindBuffersRange`
---
### See Also
glGenBuffers, glDeleteBuffers, glBindBuffer, glBindBufferBase, glBindBufferRange,
glBindBuffersRange, glMapBuffer, glUnmapBuffer
---
### Copyright
Copyright 2013-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Bind a user-defined varying out variable to a fragment shader color number
---
### Parameters
`program` The name of the program containing varying out variable whose binding to modify
`colorNumber` The color number to bind the user-defined varying out variable to
`name` The name of the user-defined varying out variable whose binding to modify
---
### Description
`glBindFragDataLocation` explicitly specifies the binding of the user-defined varying out
variable `name` to fragment shader color number `colorNumber` for program `program`. If
`name` was bound previously, its assigned binding is replaced with `colorNumber`. `name` must
be a null-terminated string. `colorNumber` must be less than `GL_MAX_DRAW_BUFFERS`.

The bindings specified by `glBindFragDataLocation` have no effect until `program` is next
linked. Bindings may be specified at any time after `program` has been created. Specifically, they
may be specified before shader objects are attached to the program. Therefore, any name may be
specified in `name`, including a name that is never used as a varying out variable in any fragment
shader object. Names beginning with `gl_` are reserved by the GL.

In addition to the errors generated by `glBindFragDataLocation`, the program `program` will
fail to link if: The number of active outputs is greater than the value `GL_MAX_DRAW_BUFFERS`.

More than one varying out variable is bound to the same color number.
---
### Notes
Varying out varyings may have indexed locations assigned explicitly in the shader text using a
location layout qualifier. If a shader statically assigns a location to a varying out variable in
the shader text, that location is used and any location assigned with `glBindFragDataLocation` is
ignored.
---
### Errors
`GL_INVALID_VALUE` is generated if `colorNumber` is greater than or equal to
`GL_MAX_DRAW_BUFFERS`.

`GL_INVALID_OPERATION` is generated if `name` starts with the reserved `gl_` prefix.

`GL_INVALID_OPERATION` is generated if `program` is not the name of a program object.
---
### Associated Gets
glGetFragDataLocation with a valid program object and the name of a user-defined varying out
variable
---
### Version Support
`glBindFragDataLocation`
---
### See Also
glCreateProgram, glGetFragDataLocation
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Bind a user-defined varying out variable to a fragment shader color number and index
---
### Parameters
`program` The name of the program containing varying out variable whose binding to modify
`colorNumber` The color number to bind the user-defined varying out variable to
`index` The index of the color input to bind the user-defined varying out variable to
`name` The name of the user-defined varying out variable whose binding to modify
---
### Description
`glBindFragDataLocationIndexed` specifies that the varying out variable `name` in `program`
should be bound to fragment color `colorNumber` when the program is next linked. `index` may be
zero or one to specify that the color be used as either the first or second color input to the blend
equation, respectively.

The bindings specified by `glBindFragDataLocationIndexed` have no effect until `program` is
next linked. Bindings may be specified at any time after `program` has been created. Specifically,
they may be specified before shader objects are attached to the program. Therefore, any name may be
specified in `name`, including a name that is never used as a varying out variable in any fragment
shader object. Names beginning with `gl_` are reserved by the GL.

If `name` was bound previously, its assigned binding is replaced with `colorNumber` and
`index`. `name` must be a null-terminated string. `index` must be less than or equal to one,
and `colorNumber` must be less than the value of `GL_MAX_DRAW_BUFFERS` if `index` is zero, and
less than the value of `GL_MAX_DUAL_SOURCE_DRAW_BUFFERS` if index is greater than or equal to one.

In addition to the errors generated by `glBindFragDataLocationIndexed`, the program `program`
will fail to link if: The number of active outputs is greater than the value
`GL_MAX_DRAW_BUFFERS`.

More than one varying out variable is bound to the same color number.
---
### Notes
Varying out varyings may have locations assigned explicitly in the shader text using a location
layout qualifier. If a shader statically assigns a location to a varying out variable in the shader
text, that location is used and any location assigned with `glBindFragDataLocation` is ignored.
---
### Errors
`GL_INVALID_VALUE` is generated if `colorNumber` is greater than or equal to
`GL_MAX_DRAW_BUFFERS`.

`GL_INVALID_VALUE` is generated if `colorNumber` is greater than or equal to
`GL_MAX_DUAL_SOURCE_DRAW_BUFFERS` and `index` is greater than or equal to one.

`GL_INVALID_VALUE` is generated if `index` is greater than one.

`GL_INVALID_OPERATION` is generated if `name` starts with the reserved `gl_` prefix.

`GL_INVALID_OPERATION` is generated if `program` is not the name of a program object.
---
### Associated Gets
glGetFragDataLocation with a valid program object and the name of a user-defined varying out
variable

glGetFragDataIndex with a valid program object and the name of a user-defined varying out
variable
---
### Version Support
`glBindFragDataLocationIndexed`
---
### See Also
glCreateProgram, glLinkProgram glGetFragDataLocation, glGetFragDataIndex
glBindFragDataLocation
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Bind a framebuffer to a framebuffer target
---
### Parameters
`target` Specifies the framebuffer target of the binding operation.
`framebuffer` Specifies the name of the framebuffer object to bind.
---
### Description
`glBindFramebuffer` binds the framebuffer object with name `framebuffer` to the framebuffer
target specified by `target`. `target` must be either `GL_DRAW_FRAMEBUFFER`,
`GL_READ_FRAMEBUFFER` or `GL_FRAMEBUFFER`. If a framebuffer object is bound to
`GL_DRAW_FRAMEBUFFER` or `GL_READ_FRAMEBUFFER`, it becomes the target for rendering or readback
operations, respectively, until it is deleted or another framebuffer is bound to the corresponding
bind point. Calling `glBindFramebuffer` with `target` set to `GL_FRAMEBUFFER` binds
`framebuffer` to both the read and draw framebuffer targets. `framebuffer` is the name of a
framebuffer object previously returned from a call to glGenFramebuffers, or zero to break the
existing binding of a framebuffer object to `target`.
---
### Errors
`GL_INVALID_ENUM` is generated if `target` is not `GL_DRAW_FRAMEBUFFER`,
`GL_READ_FRAMEBUFFER` or `GL_FRAMEBUFFER`.

`GL_INVALID_OPERATION` is generated if `framebuffer` is not zero or the name of a framebuffer
previously returned from a call to glGenFramebuffers.
---
### Version Support
`glBindFramebuffer`
---
### See Also
glGenFramebuffers, glFramebufferRenderbuffer, glFramebufferTexture,
`glFramebufferTexture1D`, `glFramebufferTexture2D`, `glFramebufferTexture3D`,
glFramebufferTextureLayer, glDeleteFramebuffers, glIsFramebuffer
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Bind a level of a texture to an image unit
---
### Parameters
`unit` Specifies the index of the image unit to which to bind the texture
`texture` Specifies the name of the texture to bind to the image unit.
`level` Specifies the level of the texture that is to be bound.
`layered` Specifies whether a layered texture binding is to be established.
`layer` If `layered` is `GL_FALSE`, specifies the layer of `texture` to be bound to the
image unit. Ignored otherwise.

`access` Specifies a token indicating the type of access that will be performed on the image.
`format` Specifies the format that the elements of the image will be treated as for the
purposes of formatted stores.
---
### Description
`glBindImageTexture` binds a single level of a texture to an image unit for the purpose of
reading and writing it from shaders. `unit` specifies the zero-based index of the image unit to
which to bind the texture level. `texture` specifies the name of an existing texture object to
bind to the image unit. If `texture` is zero, then any existing binding to the image unit is
broken. `level` specifies the level of the texture to bind to the image unit.

If `texture` is the name of a one-, two-, or three-dimensional array texture, a cube map or cube
map array texture, or a two-dimensional multisample array texture, then it is possible to bind
either the entire array, or only a single layer of the array to the image unit. In such cases, if
`layered` is `GL_TRUE`, the entire array is attached to the image unit and `layer` is ignored.

However, if `layered` is `GL_FALSE` then `layer` specifies the layer of the array to attach to
the image unit.

`access` specifies the access types to be performed by shaders and may be set to `GL_READ_ONLY`,
`GL_WRITE_ONLY`, or `GL_READ_WRITE` to indicate read-only, write-only or read-write access,
respectively. Violation of the access type specified in `access` (for example, if a shader writes
to an image bound with `access` set to `GL_READ_ONLY` ) will lead to undefined results, possibly
including program termination.

`format` specifies the format that is to be used when performing formatted stores into the image
from shaders. `format` must be compatible with the texture's internal format and must be one of
the formats listed in the following table.

### Internal Image Formats
Image Unit Format Format Qualifier `GL_RGBA32F` rgba32f `GL_RGBA16F` rgba16f
`GL_RG32F` rg32f `GL_RG16F` rg16f `GL_R11F_G11F_B10F` r11f_g11f_b10f `GL_R32F` r32f
`GL_R16F` r16f `GL_RGBA32UI` rgba32ui `GL_RGBA16UI` rgba16ui `GL_RGB10_A2UI` rgb10_a2ui
`GL_RGBA8UI` rgba8ui `GL_RG32UI` rg32ui `GL_RG16UI` rg16ui `GL_RG8UI` rg8ui `GL_R32UI`
r32ui `GL_R16UI` r16ui `GL_R8UI` r8ui `GL_RGBA32I` rgba32i `GL_RGBA16I` rgba16i
`GL_RGBA8I` rgba8i `GL_RG32I` rg32i `GL_RG16I` rg16i `GL_RG8I` rg8i `GL_R32I` r32i
`GL_R16I` r16i `GL_R8I` r8i `GL_RGBA16` rgba16 `GL_RGB10_A2` rgb10_a2 `GL_RGBA8` rgba8
`GL_RG16` rg16 `GL_RG8` rg8 `GL_R16` r16 `GL_R8` r8 `GL_RGBA16_SNORM` rgba16_snorm
`GL_RGBA8_SNORM` rgba8_snorm `GL_RG16_SNORM` rg16_snorm `GL_RG8_SNORM` rg8_snorm
`GL_R16_SNORM` r16_snorm `GL_R8_SNORM` r8_snorm

When a texture is bound to an image unit, the `format` parameter for the image unit need not
exactly match the texture internal format as long as the formats are considered compatible as
defined in the OpenGL Specification. The matching criterion used for a given texture may be
determined by calling glGetTexParameter with `value` set to
`GL_IMAGE_FORMAT_COMPATIBILITY_TYPE`, with return values of
`GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE` and `GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS`, specifying
matches by size and class, respectively.
---
### Notes
The `glBindImageTexture` is available only if the GL version is 4.2 or greater.
---
### Errors
`GL_INVALID_VALUE` is generated if `unit` greater than or equal to the value of
`GL_MAX_IMAGE_UNITS`.

`GL_INVALID_VALUE` is generated if `texture` is not the name of an existing texture object.

`GL_INVALID_VALUE` is generated if `level` or `layer` is less than zero.

`GL_INVALID_ENUM` is generated if `access` or `format` is not one of the supported tokens.
---
### Associated Gets
glGet with argument `GL_IMAGE_BINDING_NAME`.

glGet with argument `GL_IMAGE_BINDING_LEVEL`.

glGet with argument `GL_IMAGE_BINDING_LAYERED`.

glGet with argument `GL_IMAGE_BINDING_LAYER`.

glGet with argument `GL_IMAGE_BINDING_ACCESS`.

glGet with argument `GL_IMAGE_BINDING_FORMAT`.
---
### Version Support
`glBindImageTexture`
---
### See Also
glGenTextures, glTexImage1D, glTexImage2D, glTexImage3D, glTexStorage1D,
glTexStorage2D, glTexStorage3D, glBindTexture
---
### Copyright
Copyright 2011-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Bind one or more named texture images to a sequence of consecutive image units
---
### Parameters
`first` Specifies the first image unit to which a texture is to be bound.
`count` Specifies the number of textures to bind.
`textures` Specifies the address of an array of names of existing texture objects.
---
### Description
`glBindImageTextures` binds images from an array of existing texture objects to a specified
number of consecutive image units. `count` specifies the number of texture objects whose names are
stored in the array `textures`. That number of texture names are read from the array and bound to
the `count` consecutive texture units starting from `first`. If the name zero appears in the
`textures` array, any existing binding to the image unit is reset. Any non-zero entry in
`textures` must be the name of an existing texture object. When a non-zero entry in `textures` is
present, the image at level zero is bound, the binding is considered layered, with the first layer
set to zero, and the image is bound for read-write access. The image unit format parameter is taken
from the internal format of the image at level zero of the texture object. For cube map textures,
the internal format of the positive X image of level zero is used. If `textures` is `NULL` then
it is as if an appropriately sized array containing only zeros had been specified.

`glBindImageTextures` is equivalent to the following pseudo code:

for (i = 0; i < count; i++) { if (textures == NULL || textures[i] = 0) { glBindImageTexture(first
+ i, 0, 0, GL_FALSE, 0, GL_READ_ONLY, GL_R8); } else { glBindImageTexture(first + i, textures[i], 0,
GL_TRUE, 0, GL_READ_WRITE, lookupInternalFormat(textures[i])); } } Each entry in `textures` will
be checked individually and if found to be invalid, the state for that image unit will not be
changed and an error will be generated. However, the state for other texture image units referenced
by the command will still be updated.
---
### Notes
`glBindImageTextures` is available only if the GL version is 4.4 or higher.

Note that because `glBindImageTextures` cannot create new textures (even if a name passed has
been previously generated by call to glGenTextures ), names passed to `glBindImageTextures` must
have been bound at least once previously via a call to glBindTexture.
---
### Errors
`GL_INVALID_OPERATION` is generated if `first` + `count` is greater than the number of image
units supported by the implementation.

`GL_INVALID_OPERATION` is generated if any value in `textures` is not zero or the name of an
existing texture object.

`GL_INVALID_OPERATION` error is generated if the internal format of the level zero texture image
of any texture in textures is not supported.

`GL_INVALID_OPERATION` error is generated if the width, height, or depth of the level zero
texture image of any texture in textures is zero.
---
### Associated Gets
glGet with argument `GL_TEXTURE_BINDING_1D`, `GL_TEXTURE_BINDING_2D`,
`GL_TEXTURE_BINDING_3D`, `GL_TEXTURE_BINDING_1D_ARRAY`, `GL_TEXTURE_BINDING_2D_ARRAY`,
`GL_TEXTURE_BINDING_RECTANGLE`, `GL_TEXTURE_BINDING_BUFFER`, `GL_TEXTURE_BINDING_CUBE_MAP`,
`GL_TEXTURE_BINDING_CUBE_MAP`, `GL_TEXTURE_BINDING_CUBE_MAP_ARRAY`,
`GL_TEXTURE_BINDING_2D_MULTISAMPLE`, or `GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY`.
---
### Version Support
`glBindImageTextures`
---
### See Also
glBindTexture, glBindTextures, glDeleteTextures, glGenTextures, glGet,
glGetTexParameter, glIsTexture, glTexStorage1D, glTexStorage2D,
glTexStorage2DMultisample, glTexStorage3D, glTexStorage3DMultisample, glTexBuffer,
glTexParameter
---
### Copyright
Copyright 2013-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Bind a program pipeline to the current context
---
### Parameters
`pipeline` Specifies the name of the pipeline object to bind to the context.
---
### Description
`glBindProgramPipeline` binds a program pipeline object to the current context. `pipeline` must
be a name previously returned from a call to glGenProgramPipelines. If no program pipeline exists
with name `pipeline` then a new pipeline object is created with that name and initialized to the
default state vector.

When a program pipeline object is bound using `glBindProgramPipeline`, any previous binding is
broken and is replaced with a binding to the specified pipeline object. If `pipeline` is zero, the
previous binding is broken and is not replaced, leaving no pipeline object bound. If no current
program object has been established by glUseProgram, the program objects used for each stage and
for uniform updates are taken from the bound program pipeline object, if any. If there is a current
program object established by glUseProgram, the bound program pipeline object has no effect on
rendering or uniform updates. When a bound program pipeline object is used for rendering, individual
shader executables are taken from its program objects.
---
### Errors
`GL_INVALID_OPERATION` is generated if `pipeline` is not zero or a name previously returned
from a call to glGenProgramPipelines or if such a name has been deleted by a call to
glDeleteProgramPipelines.
---
### Version Support
`glBindProgramPipeline`
---
### See Also
glCreateShader, glCreateProgram, glCompileShader, glLinkProgram,
glGenProgramPipelines, glDeleteProgramPipelines, glIsProgramPipeline
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Bind a renderbuffer to a renderbuffer target
---
### Parameters
`target` Specifies the renderbuffer target of the binding operation. `target` must be
`GL_RENDERBUFFER`.

`renderbuffer` Specifies the name of the renderbuffer object to bind.
---
### Description
`glBindRenderbuffer` binds the renderbuffer object with name `renderbuffer` to the renderbuffer
target specified by `target`. `target` must be `GL_RENDERBUFFER`. `renderbuffer` is the name
of a renderbuffer object previously returned from a call to glGenRenderbuffers, or zero to break
the existing binding of a renderbuffer object to `target`.
---
### Errors
`GL_INVALID_ENUM` is generated if `target` is not `GL_RENDERBUFFER`.

`GL_INVALID_OPERATION` is generated if `renderbuffer` is not zero or the name of a renderbuffer
previously returned from a call to glGenRenderbuffers.
---
### Version Support
`glBindRenderbuffer`
---
### See Also
glDeleteRenderbuffers, glGenRenderbuffers, glIsRenderbuffer, glRenderbufferStorage,
glRenderbufferStorageMultisample
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Bind a named sampler to a texturing target
---
### Parameters
`unit` Specifies the index of the texture unit to which the sampler is bound.
`sampler` Specifies the name of a sampler.
---
### Description
`glBindSampler` binds `sampler` to the texture unit at index `unit`. `sampler` must be zero
or the name of a sampler object previously returned from a call to glGenSamplers. `unit` must
be less than the value of `GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS`.

When a sampler object is bound to a texture unit, its state supersedes that of the texture object
bound to that texture unit. If the sampler name zero is bound to a texture unit, the currently bound
texture's sampler state becomes active. A single sampler object may be bound to multiple texture
units simultaneously.
---
### Notes
`glBindSampler` is available only if the GL version is 3.3 or higher.
---
### Errors
`GL_INVALID_VALUE` is generated if `unit` is greater than or equal to the value of
`GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS`.

`GL_INVALID_OPERATION` is generated if `sampler` is not zero or a name previously returned from
a call to glGenSamplers, or if such a name has been deleted by a call to glDeleteSamplers.
---
### Associated Gets
glGet with argument `GL_SAMPLER_BINDING`
---
### Version Support
`glBindSampler`
---
### See Also
glGenSamplers, glDeleteSamplers, glGet, glSamplerParameter, glGetSamplerParameter,
glGenTextures, glBindTexture, glDeleteTextures
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Bind one or more named sampler objects to a sequence of consecutive sampler units
---
### Parameters
`first` Specifies the first sampler unit to which a sampler object is to be bound.
`count` Specifies the number of samplers to bind.
`samplers` Specifies the address of an array of names of existing sampler objects.
---
### Description
`glBindSamplers` binds samplers from an array of existing sampler objects to a specified number
of consecutive sampler units. `count` specifies the number of sampler objects whose names are
stored in the array `samplers`. That number of sampler names is read from the array and bound to
the `count` consecutive sampler units starting from `first`.

If the name zero appears in the `samplers` array, any existing binding to the sampler unit is
reset. Any non-zero entry in `samplers` must be the name of an existing sampler object. When a
non-zero entry in `samplers` is present, that sampler object is bound to the corresponding sampler
unit. If `samplers` is `NULL` then it is as if an appropriately sized array containing only
zeros had been specified.

`glBindSamplers` is equivalent to the following pseudo code:

for (i = 0; i < count; i++) { if (samplers == NULL) { glBindSampler(first + i, 0); } else {
glBindSampler(first + i, samplers[i]); } } Each entry in `samplers` will be checked individually
and if found to be invalid, the state for that sampler unit will not be changed and an error will be
generated. However, the state for other sampler units referenced by the command will still be
updated.
---
### Notes
`glBindSamplers` is available only if the GL version is 4.4 or higher.
---
### Errors
`GL_INVALID_OPERATION` is generated if `first` + `count` is greater than the number of
sampler units supported by the implementation.

`GL_INVALID_OPERATION` is generated if any value in `samplers` is not zero or the name of an
existing sampler object.
---
### Associated Gets
glGet with argument `GL_SAMPLER_BINDING`
---
### Version Support
`glBindSamplers`
---
### See Also
glGenSamplers, glBindSampler, glDeleteSamplers, glGet, glSamplerParameter,
glGetSamplerParameter, glGenTextures, glBindTexture, glDeleteTextures
---
### Copyright
Copyright 2013-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Bind a named texture to a texturing target
---
### Parameters
`target` Specifies the target to which the texture is bound. Must be one of `GL_TEXTURE_1D`,
`GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D_ARRAY`,
`GL_TEXTURE_RECTANGLE`, `GL_TEXTURE_CUBE_MAP`, `GL_TEXTURE_CUBE_MAP_ARRAY`,
`GL_TEXTURE_BUFFER`, `GL_TEXTURE_2D_MULTISAMPLE` or `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`.

`texture` Specifies the name of a texture.
---
### Description
`glBindTexture` lets you create or use a named texture. Calling `glBindTexture` with `target`
set to `GL_TEXTURE_1D`, `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_1D_ARRAY`,
`GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_RECTANGLE`, `GL_TEXTURE_CUBE_MAP`,
`GL_TEXTURE_CUBE_MAP_ARRAY`, `GL_TEXTURE_BUFFER`, `GL_TEXTURE_2D_MULTISAMPLE` or
`GL_TEXTURE_2D_MULTISAMPLE_ARRAY` and `texture` set to the name of the new texture binds the
texture name to the target. When a texture is bound to a target, the previous binding for that
target is automatically broken.

Texture names are unsigned integers. The value zero is reserved to represent the default texture
for each texture target. Texture names and the corresponding texture contents are local to the
shared object space of the current GL rendering context; two rendering contexts share texture names
only if they explicitly enable sharing between contexts through the appropriate GL windows
interfaces functions. You must use glGenTextures to generate a set of new texture names.

When a texture is first bound, it assumes the specified target: A texture first bound to
`GL_TEXTURE_1D` becomes one-dimensional texture, a texture first bound to `GL_TEXTURE_2D` becomes
two-dimensional texture, a texture first bound to `GL_TEXTURE_3D` becomes three-dimensional
texture, a texture first bound to `GL_TEXTURE_1D_ARRAY` becomes one-dimensional array texture, a
texture first bound to `GL_TEXTURE_2D_ARRAY` becomes two-dimensional array texture, a texture
first bound to `GL_TEXTURE_RECTANGLE` becomes rectangle texture, a texture first bound to
`GL_TEXTURE_CUBE_MAP` becomes a cube-mapped texture, a texture first bound to
`GL_TEXTURE_CUBE_MAP_ARRAY` becomes a cube-mapped array texture, a texture first bound to
`GL_TEXTURE_BUFFER` becomes a buffer texture, a texture first bound to `GL_TEXTURE_2D_MULTISAMPLE`
becomes a two-dimensional multisampled texture, and a texture first bound to
`GL_TEXTURE_2D_MULTISAMPLE_ARRAY` becomes a two-dimensional multisampled array texture. The state
of a one-dimensional texture immediately after it is first bound is equivalent to the state of the
default `GL_TEXTURE_1D` at GL initialization, and similarly for the other texture types.

While a texture is bound, GL operations on the target to which it is bound affect the bound
texture, and queries of the target to which it is bound return state from the bound texture. In
effect, the texture targets become aliases for the textures currently bound to them, and the texture
name zero refers to the default textures that were bound to them at initialization. A texture
binding created with `glBindTexture` remains active until a different texture is bound to the same
target, or until the bound texture is deleted with glDeleteTextures.

Once created, a named texture may be re-bound to its same original target as often as needed. It
is usually much faster to use `glBindTexture` to bind an existing named texture to one of the
texture targets than it is to reload the texture image using glTexImage1D, glTexImage2D,
glTexImage3D or another similar function.
---
### Notes
The `GL_TEXTURE_2D_MULTISAMPLE` and `GL_TEXTURE_2D_MULTISAMPLE_ARRAY` targets are available
only if the GL version is 3.2 or higher.
---
### Errors
`GL_INVALID_ENUM` is generated if `target` is not one of the allowable values.

`GL_INVALID_VALUE` is generated if `texture` is not a name returned from a previous call to
glGenTextures.

`GL_INVALID_OPERATION` is generated if `texture` was previously created with a target that
doesn't match that of `target`.
---
### Associated Gets
glGet with argument `GL_TEXTURE_BINDING_1D`, `GL_TEXTURE_BINDING_2D`,
`GL_TEXTURE_BINDING_3D`, `GL_TEXTURE_BINDING_1D_ARRAY`, `GL_TEXTURE_BINDING_2D_ARRAY`,
`GL_TEXTURE_BINDING_RECTANGLE`, `GL_TEXTURE_BINDING_BUFFER`, `GL_TEXTURE_BINDING_CUBE_MAP`,
`GL_TEXTURE_BINDING_CUBE_MAP_ARRAY`, `GL_TEXTURE_BINDING_2D_MULTISAMPLE`, or
`GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY`.
---
### Version Support
`glBindTexture`
---
### See Also
glDeleteTextures, glGenTextures, glGet, glGetTexParameter, glIsTexture,
glTexImage1D, glTexImage2D, glTexImage2DMultisample, glTexImage3D,
glTexImage3DMultisample, glTexBuffer, glTexParameter
---
### Copyright
Copyright 1991-2006 Silicon Graphics, Inc. Copyright 2010-2014 Khronos Group. This document
is licensed under the SGI Free Software B License. For details, see
https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.
]],
  [[Bind an existing texture object to the specified texture unit
---
### Parameters
`unit` Specifies the texture unit, to which the texture object should be bound to.
`texture` Specifies the name of a texture.
---
### Description
`glBindTextureUnit` binds an existing texture object to the texture unit numbered `unit`.

`texture` must be zero or the name of an existing texture object. When `texture` is the name of
an existing texture object, that object is bound to the target, in the corresponding texture unit,
that was specified when the object was created. When `texture` is zero, each of the targets
enumerated at the beginning of this section is reset to its default texture for the corresponding
texture image unit.
---
### Associated Gets
glGet with argument `GL_TEXTURE_BINDING_1D`, `GL_TEXTURE_BINDING_2D`,
`GL_TEXTURE_BINDING_3D`, `GL_TEXTURE_BINDING_1D_ARRAY`, `GL_TEXTURE_BINDING_2D_ARRAY`,
`GL_TEXTURE_BINDING_RECTANGLE`, `GL_TEXTURE_BINDING_BUFFER`, `GL_TEXTURE_BINDING_CUBE_MAP`,
`GL_TEXTURE_BINDING_CUBE_MAP_ARRAY`, `GL_TEXTURE_BINDING_2D_MULTISAMPLE` or
`GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY`.
---
### Errors
`GL_INVALID_OPERATION` error is generated if `texture` is not zero or the name of an existing
texture object.
---
### Version Support
`glBindTextureUnit`
---
### See Also
glDeleteTextures, glGenTextures, glGet, glGetTexParameter, glIsTexture,
glTexImage1D, glTexImage2D, glTexImage2DMultisample, glTexImage3D,
glTexImage3DMultisample, glTexBuffer, glTexParameter
---
### Copyright
Copyright 2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Bind one or more named textures to a sequence of consecutive texture units
---
### Parameters
`first` Specifies the first texture unit to which a texture is to be bound.
`count` Specifies the number of textures to bind.
`textures` Specifies the address of an array of names of existing texture objects.
---
### Description
`glBindTextures` binds an array of existing texture objects to a specified number of consecutive
texture units. `count` specifies the number of texture objects whose names are stored in the array
`textures`. That number of texture names are read from the array and bound to the `count`
consecutive texture units starting from `first`. The target, or type of texture is deduced from
the texture object and each texture is bound to the corresponding target of the texture unit. If the
name zero appears in the `textures` array, any existing binding to any target of the texture unit
is reset and the default texture for that target is bound in its place. Any non-zero entry in
`textures` must be the name of an existing texture object. If `textures` is `NULL` then it is
as if an appropriately sized array containing only zeros had been specified.

With the exception that the active texture selector maintains its current value, `glBindTextures`
is equivalent to the following pseudo code:

for (i = 0; i < count; i++) { GLuint texture; if (textures == NULL) { texture = 0; } else {
texture = textures[i]; } glActiveTexture(GL_TEXTURE0 + first + i); if (texture != 0) { GLenum target
= /* target of textures[i] */; glBindTexture(target, textures[i]); } else { for (target in all
supported targets) { glBindTexture(target, 0); } } } Each entry in `textures` will be checked
individually and if found to be invalid, the state for that texture unit will not be changed and an
error will be generated. However, the state for other texture units referenced by the command will
still be updated.
---
### Notes
`glBindTextures` is available only if the GL version is 4.4 or higher.

Note that because `glBindTextures` cannot create new textures (even if a name passed has been
previously generated by call to glGenTextures ), names passed to `glBindTextures` must have been
bound at least once previously via a call to glBindTexture.
---
### Errors
`GL_INVALID_OPERATION` is generated if `first` + `count` is greater than the number of
texture image units supported by the implementation.

`GL_INVALID_OPERATION` is generated if any value in textures is not zero or the name of an
existing texture object.
---
### Associated Gets
glGet with argument `GL_TEXTURE_BINDING_1D`, `GL_TEXTURE_BINDING_2D`,
`GL_TEXTURE_BINDING_3D`, `GL_TEXTURE_BINDING_1D_ARRAY`, `GL_TEXTURE_BINDING_2D_ARRAY`,
`GL_TEXTURE_BINDING_RECTANGLE`, `GL_TEXTURE_BINDING_BUFFER`, `GL_TEXTURE_BINDING_CUBE_MAP`,
`GL_TEXTURE_BINDING_CUBE_MAP`, `GL_TEXTURE_BINDING_CUBE_MAP_ARRAY`,
`GL_TEXTURE_BINDING_2D_MULTISAMPLE`, or `GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY`.
---
### Version Support
`glBindTextures`
---
### See Also
glBindTexture, glDeleteTextures, glGenTextures, glGet, glGetTexParameter,
glIsTexture, glTexImage1D, glTexImage2D, glTexImage2DMultisample, glTexImage3D,
glTexImage3DMultisample, glTexBuffer, glTexParameter
---
### Copyright
Copyright 2013-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Bind a transform feedback object
---
### Parameters
`target` Specifies the target to which to bind the transform feedback object `id`. `target`
must be `GL_TRANSFORM_FEEDBACK`.

`id` Specifies the name of a transform feedback object reserved by glGenTransformFeedbacks.

---
### Description
`glBindTransformFeedback` binds the transform feedback object with name `id` to the current GL
state. `id` must be a name previously returned from a call to glGenTransformFeedbacks. If `id`
has not previously been bound, a new transform feedback object with name `id` and initialized
with the default transform state vector is created.

In the initial state, a default transform feedback object is bound and treated as a transform
feedback object with a name of zero. If the name zero is subsequently bound, the default transform
feedback object is again bound to the GL state. While a transform feedback buffer object is bound,
GL operations on the target to which it is bound affect the bound transform feedback object, and
queries of the target to which a transform feedback object is bound return state from the bound
object. When buffer objects are bound for transform feedback, they are attached to the currently
bound transform feedback object. Buffer objects are used for trans- form feedback only if they are
attached to the currently bound transform feedback object.
---
### Errors
`GL_INVALID_ENUM` is generated if `target` is not `GL_TRANSFORM_FEEDBACK`.

`GL_INVALID_OPERATION` is generated if the transform feedback operation is active on the
currently bound transform feedback object, and that operation is not paused.

`GL_INVALID_OPERATION` is generated if `id` is not zero or the name of a transform feedback
object returned from a previous call to glGenTransformFeedbacks, or if such a name has been
deleted by glDeleteTransformFeedbacks.
---
### Associated Gets
glGet with argument `GL_TRANSFORM_FEEDBACK_BINDING`
---
### Version Support
`glBindTransformFeedback`
---
### See Also
glGenTransformFeedbacks, glDeleteTransformFeedbacks, glIsTransformFeedback,
glBeginTransformFeedback, glPauseTransformFeedback, glResumeTransformFeedback,
`glEndTransformFeedback`
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Bind a vertex array object
---
### Parameters
`array` Specifies the name of the vertex array to bind.
---
### Description
`glBindVertexArray` binds the vertex array object with name `array`. `array` is the name of a
vertex array object previously returned from a call to glGenVertexArrays, or zero to break the
existing vertex array object binding.

If no vertex array object with name `array` exists, one is created when `array` is first
bound. If the bind is successful no change is made to the state of the vertex array object, and any
previous vertex array object binding is broken.
---
### Errors
`GL_INVALID_OPERATION` is generated if `array` is not zero or the name of a vertex array object
previously returned from a call to glGenVertexArrays.
---
### Version Support
`glBindVertexArray`
---
### See Also
glDeleteVertexArrays, glEnableVertexAttribArray, glGenVertexArrays, glIsVertexArray,
glVertexAttribPointer
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Bind a buffer to a vertex buffer bind point
---
### Parameters
`vaobj` Specifies the name of the vertex array object to be used by
`glVertexArrayVertexBuffer` function.

`bindingindex` The index of the vertex buffer binding point to which to bind the buffer.
`buffer` The name of a buffer to bind to the vertex buffer binding point.
`offset` The offset of the first element of the buffer.
`stride` The distance between elements within the buffer.
---
### Description
`glBindVertexBuffer` and `glVertexArrayVertexBuffer` bind the buffer named `buffer` to the
vertex buffer binding point whose index is given by `bindingindex`. `glBindVertexBuffer`
modifies the binding of the currently bound vertex array object, whereas
`glVertexArrayVertexBuffer` allows the caller to specify ID of the vertex array object with an
argument named `vaobj`, for which the binding should be modified. `offset` and `stride`
specify the offset of the first element within the buffer and the distance between elements within
the buffer, respectively, and are both measured in basic machine units. `bindingindex` must be
less than the value of `GL_MAX_VERTEX_ATTRIB_BINDINGS`. `offset` and `stride` must be greater
than or equal to zero. If `buffer` is zero, then any buffer currently bound to the specified
binding point is unbound.

If `buffer` is not the name of an existing buffer object, the GL first creates a new state
vector, initialized with a zero-sized memory buffer and comprising all the state and with the same
initial values as in case of `glBindBuffer`. `buffer` is then attached to the specified
`bindingindex` of the vertex array object.
---
### Errors
`GL_INVALID_OPERATION` is generated by `glBindVertexBuffer` if no vertex array object is bound.

`GL_INVALID_OPERATION` is generated by `glVertexArrayVertexBuffer` if `vaobj` is not the name
of an existing vertex array object.

`GL_INVALID_VALUE` is generated if `bindingindex` is greater than or equal to the value of
`GL_MAX_VERTEX_ATTRIB_BINDINGS`.

`GL_INVALID_VALUE` is generated if `offset` or `stride` is less than zero, or if stride is
greater than the value of `GL_MAX_VERTEX_ATTRIB_STRIDE`.

`GL_INVALID_VALUE` is generated if `buffer` is not zero or the name of an existing buffer
object (as returned by `glGenBuffers` or `glCreateBuffers` ).
---
### Associated Gets
glGet with argument `GL_MAX_VERTEX_ATTRIB_BINDINGS`.
---
### Version Support
`glBindVertexBuffer` `glVertexArrayVertexBuffer`
---
### See Also
glVertexAttribBinding, glVertexAttribFormat, glVertexAttribPointer,
glVertexBindingDivisor.
---
### Copyright
Copyright 2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Attach multiple buffer objects to a vertex array object
---
### Parameters
`vaobj` Specifies the name of the vertex array object for `glVertexArrayVertexBuffers`.

`first` Specifies the first vertex buffer binding point to which a buffer object is to be
bound.
`count` Specifies the number of buffers to bind.
`buffers` Specifies the address of an array of names of existing buffer objects.
`offsets` Specifies the address of an array of offsets to associate with the binding points.
`strides` Specifies the address of an array of strides to associate with the binding points.
---
### Description
`glBindVertexBuffers` and `glVertexArrayVertexBuffers` bind storage from an array of existing
buffer objects to a specified number of consecutive vertex buffer binding points units in a vertex
array object. For `glBindVertexBuffers`, the vertex array object is the currently bound vertex
array object. For `glVertexArrayVertexBuffers`, `vaobj` is the name of the vertex array object.

`count` existing buffer objects are bound to vertex buffer binding points numbered $first$
through $first + count - 1$. If `buffers` is not NULL, it specifies an array of `count` values,
each of which must be zero or the name of an existing buffer object. `offsets` and `strides`
specify arrays of `count` values indicating the offset of the first element and stride between
elements in each buffer, respectively. If `buffers` is NULL, each affected vertex buffer binding
point from $first$ through $first + count - 1$ will be reset to have no bound buffer object. In this
case, the offsets and strides associated with the binding points are set to default values, ignoring
`offsets` and `strides`.

`glBindVertexBuffers` is equivalent (assuming no errors are generated) to: for (i = 0; i <
count; i++) { if (buffers == NULL) { glBindVertexBuffer(first + i, 0, 0, 16); } else {
glBindVertexBuffer(first + i, buffers[i], offsets[i], strides[i]); } } except that buffers will not
be created if they do not exist.

`glVertexArrayVertexBuffers` is equivalent to the pseudocode above, but replacing
`glBindVertexBuffers` (args) with `glVertexArrayVertexBuffers` (vaobj, args).

The values specified in `buffers`, `offsets`, and `strides` will be checked separately for
each vertex buffer binding point. When a value for a specific vertex buffer binding point is
invalid, the state for that binding point will be unchanged and an error will be generated. However,
state for other vertex buffer binding points will still be changed if their corresponding values are
valid.
---
### Errors
`GL_INVALID_OPERATION` is generated by `glBindVertexBuffers` if no vertex array object is
bound.

`GL_INVALID_OPERATION` is generated by `glVertexArrayVertexBuffers` if `vaobj` is not the
name of the vertex array object.

`GL_INVALID_OPERATION` is generated if $first + count$ is greater than the value of
`GL_MAX_VERTEX_ATTRIB_BINDINGS`.

`GL_INVALID_OPERATION` is generated if any value in `buffers` is not zero or the name of an
existing buffer object.

`GL_INVALID_VALUE` is generated if any value in `offsets` or `strides` is negative, or if a
value is `stride` is greater than the value of `GL_MAX_VERTEX_ATTRIB_STRIDE`.
---
### Version Support
`glBindVertexBuffers` `glVertexArrayVertexBuffers`
---
### See Also
glGenBuffers, glBindBuffer, glDeleteBuffers glDeleteTextures
---
### Copyright
Copyright 2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Set the blend color
---
### Parameters
`red` `green` `blue` `alpha` specify the components of `GL_BLEND_COLOR`

---
### Description
The `GL_BLEND_COLOR` may be used to calculate the source and destination blending factors. The
color components are clamped to the range 0 1 before being stored. See glBlendFunc for a
complete description of the blending operations. Initially the `GL_BLEND_COLOR` is set to (0, 0,
0, 0).
---
### Notes
The type of the `red`, `green`, `blue`, and `alpha` parameters was changed from GLclampf
to GLfloat. This change is transparent to user code and is described in detail on the removedTypes
page.
---
### Associated Gets
glGet with an argument of `GL_BLEND_COLOR`
---
### Version Support
`glBlendColor`
---
### See Also
glBlendEquation, glBlendFunc, glGetString, removedTypes
---
### Copyright
Copyright 1991-2006 Silicon Graphics, Inc. Copyright 2010-2014 Khronos Group. This document
is licensed under the SGI Free Software B License. For details, see
https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.
]],
  [[Specify the equation used for both the RGB blend equation and the Alpha blend equation
---
### Parameters
`buf` for `glBlendEquationi`, specifies the index of the draw buffer for which to set the
blend equation.

`mode` specifies how source and destination colors are combined. It must be `GL_FUNC_ADD`,
`GL_FUNC_SUBTRACT`, `GL_FUNC_REVERSE_SUBTRACT`, `GL_MIN`, `GL_MAX`.
---
### Description
The blend equations determine how a new pixel (the "source" color) is combined with a pixel already in the framebuffer (the "destination" color). This function sets both the RGB blend equation and the alpha blend equation to a single equation. glBlendEquationi specifies the blend equation for a single draw buffer whereas glBlendEquation sets the blend equation for all draw buffers.

These equations use the source and destination blend factors specified by either glBlendFunc or glBlendFuncSeparate. See glBlendFunc or glBlendFuncSeparate for a description of the various blend factors.

In the equations that follow, source and destination color components are referred to as (Rˢ,Gˢ,Bˢ,Aˢ)
and (Rᵈ,Gᵈ,Bᵈ,Aᵈ), respectively. The result color is referred to as (Rᴿ,Gᴿ,Bᴿ,Aᴿ).

The source and destination blend factors are denoted (sᴿ,sᴳ,sᴮ,sᴬ) and (dᴿ,dᴳ,dᴮ,dᴬ), respectively.
For these equations all color components are understood to have values in the range [0,1]

┌───────────────────────────┬──────────────────────────────────────────┬────────────────┐
│Mode                       │RGB Components                            │Alpha Component │
├───────────────────────────┼──────────────────────────────────────────┼────────────────┤
│GL_FUNC_ADD                │Rᴿ=Rˢsᴿ+Rᵈdᴿ Gᴿ=Gˢsᴳ+Gᵈdᴳ Bᴿ=Bˢsᴮ+Bᵈdᴮ    │Aᴿ=Aˢsᴬ+Aᵈdᴬ    │
├───────────────────────────┼──────────────────────────────────────────┼────────────────┤
│GL_FUNC_SUBTRACT           │Rᴿ=Rˢsᴿ-Rᵈdᴿ Gᴿ=Gˢsᴳ-Gᵈdᴳ Bᴿ=Bˢsᴮ-Bᵈdᴮ    │Aᴿ=Aˢsᴬ-Aᵈdᴬ    │
├───────────────────────────┼──────────────────────────────────────────┼────────────────┤
│GL_FUNC_REVERSE_SUBTRACT   │Rᴿ=Rᵈdᴿ−Rˢsᴿ Gᴿ=Gᵈdᴳ−Gˢsᴳ Bᴿ=Bᵈdᴮ−Bˢsᴮ    │Aᴿ=Aᵈdᴬ−Aˢsᴬ    │
├───────────────────────────┼──────────────────────────────────────────┼────────────────┤
│GL_MIN                     │Rᴿ=min(Rˢ,Rᵈ) Gᴿ=min(Gˢ,Gᵈ) Bᴿ=min(Bˢ,Bᵈ) │Aᴿ=min(Aˢ,Aᵈ)   │
├───────────────────────────┼──────────────────────────────────────────┼────────────────┤
│GL_MAX                     │Rᴿ=max(Rˢ,Rᵈ) Gᴿ=max(Gˢ,Gᵈ) Bᴿ=max(Bˢ,Bᵈ) │Aᴿ=max(Aˢ,Aᵈ)   │
└───────────────────────────┴──────────────────────────────────────────┴────────────────┘

The results of these equations are clamped to the range [0,1].

The `GL_MIN` and `GL_MAX` equations are useful for applications that analyze image data (image thresholding against a constant color, for example). The GL_FUNC_ADD equation is useful for antialiasing and transparency, among other things.

Initially, both the RGB blend equation and the alpha blend equation are set to GL_FUNC_ADD.
---
### Notes
The `GL_MIN`, and `GL_MAX` equations do not use the source or destination factors, only the source and destination colors.
---
### Errors
`GL_INVALID_ENUM` is generated if mode is not one of `GL_FUNC_ADD`, `GL_FUNC_SUBTRACT`, `GL_FUNC_REVERSE_SUBTRACT`, `GL_MAX`, or `GL_MIN`.

`GL_INVALID_VALUE` is generated by `glBlendEquationi` if buf is greater than or equal to the value of GL_MAX_DRAW_BUFFERS.
]],
  [[Set the RGB blend equation and the alpha blend equation separately
---
### Parameters
`buf` for `glBlendEquationSeparatei`, specifies the index of the draw buffer for which to
set the blend equations.

`modeRGB` specifies the RGB blend equation, how the red, green, and blue components of the
source and destination colors are combined. It must be `GL_FUNC_ADD`, `GL_FUNC_SUBTRACT`,
`GL_FUNC_REVERSE_SUBTRACT`, `GL_MIN`, `GL_MAX`.

`modeAlpha` specifies the alpha blend equation, how the alpha component of the source and
destination colors are combined. It must be `GL_FUNC_ADD`, `GL_FUNC_SUBTRACT`,
`GL_FUNC_REVERSE_SUBTRACT`, `GL_MIN`, `GL_MAX`.
---
### Description
The blend equations determine how a new pixel (the "source" color) is combined with a pixel already in the framebuffer (the "destination" color). This function sets both the RGB blend equation and the alpha blend equation to a single equation. glBlendEquationi specifies the blend equation for a single draw buffer whereas glBlendEquation sets the blend equation for all draw buffers.

These equations use the source and destination blend factors specified by either glBlendFunc or glBlendFuncSeparate. See glBlendFunc or glBlendFuncSeparate for a description of the various blend factors.

In the equations that follow, source and destination color components are referred to as (Rˢ,Gˢ,Bˢ,Aˢ)
and (Rᵈ,Gᵈ,Bᵈ,Aᵈ), respectively. The result color is referred to as (Rᴿ,Gᴿ,Bᴿ,Aᴿ).

The source and destination blend factors are denoted (sᴿ,sᴳ,sᴮ,sᴬ) and (dᴿ,dᴳ,dᴮ,dᴬ), respectively.
For these equations all color components are understood to have values in the range [0,1]

┌───────────────────────────┬──────────────────────────────────────────┬────────────────┐
│Mode                       │RGB Components                            │Alpha Component │
├───────────────────────────┼──────────────────────────────────────────┼────────────────┤
│GL_FUNC_ADD                │Rᴿ=Rˢsᴿ+Rᵈdᴿ Gᴿ=Gˢsᴳ+Gᵈdᴳ Bᴿ=Bˢsᴮ+Bᵈdᴮ    │Aᴿ=Aˢsᴬ+Aᵈdᴬ    │
├───────────────────────────┼──────────────────────────────────────────┼────────────────┤
│GL_FUNC_SUBTRACT           │Rᴿ=Rˢsᴿ-Rᵈdᴿ Gᴿ=Gˢsᴳ-Gᵈdᴳ Bᴿ=Bˢsᴮ-Bᵈdᴮ    │Aᴿ=Aˢsᴬ-Aᵈdᴬ    │
├───────────────────────────┼──────────────────────────────────────────┼────────────────┤
│GL_FUNC_REVERSE_SUBTRACT   │Rᴿ=Rᵈdᴿ−Rˢsᴿ Gᴿ=Gᵈdᴳ−Gˢsᴳ Bᴿ=Bᵈdᴮ−Bˢsᴮ    │Aᴿ=Aᵈdᴬ−Aˢsᴬ    │
├───────────────────────────┼──────────────────────────────────────────┼────────────────┤
│GL_MIN                     │Rᴿ=min(Rˢ,Rᵈ) Gᴿ=min(Gˢ,Gᵈ) Bᴿ=min(Bˢ,Bᵈ) │Aᴿ=min(Aˢ,Aᵈ)   │
├───────────────────────────┼──────────────────────────────────────────┼────────────────┤
│GL_MAX                     │Rᴿ=max(Rˢ,Rᵈ) Gᴿ=max(Gˢ,Gᵈ) Bᴿ=max(Bˢ,Bᵈ) │Aᴿ=max(Aˢ,Aᵈ)   │
└───────────────────────────┴──────────────────────────────────────────┴────────────────┘

The results of these equations are clamped to the range [0,1].

The `GL_MIN` and `GL_MAX` equations are useful for applications that analyze image data (image thresholding against a constant color, for example). The GL_FUNC_ADD equation is useful for antialiasing and transparency, among other things.

Initially, both the RGB blend equation and the alpha blend equation are set to GL_FUNC_ADD.
---
### Notes
The `GL_MIN`, and `GL_MAX` equations do not use the source or destination factors, only the source and destination colors.
---
### Errors
`GL_INVALID_ENUM` is generated if mode is not one of `GL_FUNC_ADD`, `GL_FUNC_SUBTRACT`, `GL_FUNC_REVERSE_SUBTRACT`, `GL_MAX`, or `GL_MIN`.

`GL_INVALID_VALUE` is generated by `glBlendEquationi` if buf is greater than or equal to the value of GL_MAX_DRAW_BUFFERS.
]],
  [[Set the RGB blend equation and the alpha blend equation separately
---
### Parameters
`buf` for `glBlendEquationSeparatei`, specifies the index of the draw buffer for which to
set the blend equations.

`modeRGB` specifies the RGB blend equation, how the red, green, and blue components of the
source and destination colors are combined. It must be `GL_FUNC_ADD`, `GL_FUNC_SUBTRACT`,
`GL_FUNC_REVERSE_SUBTRACT`, `GL_MIN`, `GL_MAX`.

`modeAlpha` specifies the alpha blend equation, how the alpha component of the source and
destination colors are combined. It must be `GL_FUNC_ADD`, `GL_FUNC_SUBTRACT`,
`GL_FUNC_REVERSE_SUBTRACT`, `GL_MIN`, `GL_MAX`.
]],
  [[Specify pixel arithmetic
---
### Parameters
`buf` For `glBlendFunci`, specifies the index of the draw buffer for which to set the blend
function.

`sfactor` Specifies how the red, green, blue, and alpha source blending factors are computed.

The initial value is `GL_ONE`.

`dfactor` Specifies how the red, green, blue, and alpha destination blending factors are
computed. The following symbolic constants are accepted: `GL_ZERO`, `GL_ONE`, `GL_SRC_COLOR`,
`GL_ONE_MINUS_SRC_COLOR`, `GL_DST_COLOR`, `GL_ONE_MINUS_DST_COLOR`, `GL_SRC_ALPHA`,
`GL_ONE_MINUS_SRC_ALPHA`, `GL_DST_ALPHA`, `GL_ONE_MINUS_DST_ALPHA`. `GL_CONSTANT_COLOR`,
`GL_ONE_MINUS_CONSTANT_COLOR`, `GL_CONSTANT_ALPHA`, and `GL_ONE_MINUS_CONSTANT_ALPHA`. The
initial value is `GL_ZERO`.
]],
  [[Specify pixel arithmetic for RGB and alpha components separately
---
### Parameters
`buf` For `glBlendFuncSeparatei`, specifies the index of the draw buffer for which to set
the blend functions.

`srcRGB` Specifies how the red, green, and blue blending factors are computed. The initial
value is `GL_ONE`.

`dstRGB` Specifies how the red, green, and blue destination blending factors are computed. The
initial value is `GL_ZERO`.

`srcAlpha` Specified how the alpha source blending factor is computed. The initial value is
`GL_ONE`.

`dstAlpha` Specified how the alpha destination blending factor is computed. The initial value
is `GL_ZERO`.

Pixels can be drawn using a function that blends the incoming (source) RGBA values with the
RGBA values that are already in the frame buffer (the destination values). Blending is initially
disabled. Use `glEnable` and `glDisable` with argument `GL_BLEND` to enable and disable blending.

`glBlendFuncSeparate` defines the operation of blending for all draw buffers when it is enabled.
`glBlendFuncSeparatei` defines the operation of blending for a single draw buffer specified by buf
when enabled for that draw buffer. srcRGB specifies which method is used to scale the source
RGB-color components. dstRGB specifies which method is used to scale the destination RGB-color
components. Likewise, srcAlpha specifies which method is used to scale the source alpha color
component, and dstAlpha specifies which method is used to scale the destination alpha component.
The possible methods are described in the following table. Each method defines four scale factors,
one each for red, green, blue, and alpha.

In the table and in subsequent equations, first source, second source and destination color
components are referred to as `(Rs⁰,Gs⁰,Bs⁰,As⁰)`, `(Rs¹,Gs¹,Bs¹,As¹)`, and `(Rᵈ,Gᵈ,Bᵈ,Aᵈ)`, respectively.
The color specified by glBlendColor is referred to as `(Rᶜ,Gᶜ,Bᶜ,Aᶜ)`.
They are understood to have integer values between 0 and `(kᴿ,kᴳ,kᴮ,kᴬ)`,
where `kᶜ=2ᵐᶜ−1` and `(mᴿ,mᴳ,mᴮ,mᴬ)` is the number of red, green, blue, and alpha bitplanes.

Source and destination scale factors are referred to as `(sᴿ,sᴳ,sᴮ,sᴬ)` and `(dᴿ,dᴳ,dᴮ,dᴬ)`.
All scale factors have range [0,1].

┌───────────────────────────┬────────────────────────────────┬────────────┐
│Parameter                  │RGB Factor                      │Alpha Factor│
├───────────────────────────┼────────────────────────────────┼────────────┤
│GL_ZERO                    │(0,0,0)                         │0           │
├───────────────────────────┼────────────────────────────────┼────────────┤
│GL_ONE                     │(1,1,1)                         │1           │
├───────────────────────────┼────────────────────────────────┼────────────┤
│GL_SRC_COLOR               │(Rs⁰/kᴿ,Gs⁰/kᴳ,Bs⁰/kᴮ)          │As⁰/kᴬ      │
├───────────────────────────┼────────────────────────────────┼────────────┤
│GL_ONE_MINUS_SRC_COLOR     │(1,1,1)−(Rs⁰/kᴿ,Gs⁰/kᴳ,Bs⁰/kᴮ)  │1−(As⁰/kᴬ)  │
├───────────────────────────┼────────────────────────────────┼────────────┤
│GL_DST_COLOR               │(Rᵈ/kᴿ,Gᵈ/kᴳ,Bᵈ/kᴮ)             │Aᵈ/kᴬ       │
├───────────────────────────┼────────────────────────────────┼────────────┤
│GL_ONE_MINUS_DST_COLOR     │(1,1,1)−(Rᵈ/kᴿ,Gᵈ/kᴳ,Bᵈ/kᴮ)     │1−(Aᵈ/kᴬ)   │
├───────────────────────────┼────────────────────────────────┼────────────┤
│GL_SRC_ALPHA               │(As⁰/kᴬ,As⁰/kᴬ,As⁰/kᴬ)          │As⁰/kᴬ      │
├───────────────────────────┼────────────────────────────────┼────────────┤
│GL_ONE_MINUS_SRC_ALPHA     │(1,1,1)−(As⁰/kᴬ,As⁰/kᴬ,As⁰/kᴬ)  │1−(As⁰/kᴬ)  │
├───────────────────────────┼────────────────────────────────┼────────────┤
│GL_DST_ALPHA               │(Aᵈ/kᴬ,Aᵈ/kᴬ,Aᵈ/kᴬ)             │Aᵈ/kᴬ       │
├───────────────────────────┼────────────────────────────────┼────────────┤
│GL_ONE_MINUS_DST_ALPHA     │(1,1,1)−(Aᵈ/kᴬ,Aᵈ/kᴬ,Aᵈ/kᴬ)     │1−(Aᵈ/kᴬ)   │
├───────────────────────────┼────────────────────────────────┼────────────┤
│GL_CONSTANT_COLOR          │(Rᶜ,Gᶜ,Bᶜ)                      │Aᶜ          │
├───────────────────────────┼────────────────────────────────┼────────────┤
│GL_ONE_MINUS_CONSTANT_COLOR│(1,1,1)−(Rᶜ,Gᶜ,Bᶜ)              │1−Aᶜ        │
├───────────────────────────┼────────────────────────────────┼────────────┤
│GL_CONSTANT_ALPHA          │(Aᶜ,Aᶜ,Aᶜ)                      │Aᶜ          │
├───────────────────────────┼────────────────────────────────┼────────────┤
│GL_ONE_MINUS_CONSTANT_ALPHA│(1,1,1)−(Aᶜ,Aᶜ,Aᶜ)              │1−Aᶜ        │
├───────────────────────────┼────────────────────────────────┼────────────┤
│GL_SRC_ALPHA_SATURATE      │(i,i,i)                         │1           │
├───────────────────────────┼────────────────────────────────┼────────────┤
│GL_SRC1_COLOR              │(Rs¹/kᴿ,Gs¹/kᴳ,Bs¹/kᴮ)          │As¹/kᴬ      │
├───────────────────────────┼────────────────────────────────┼────────────┤
│GL_ONE_MINUS_SRC1_COLOR    │(1,1,1,1)−(Rs¹/kᴿ,Gs¹/kᴳ,Bs¹/kᴮ)│1−(As¹/kᴬ)  │
├───────────────────────────┼────────────────────────────────┼────────────┤
│GL_SRC1_ALPHA              │(As¹/kᴬ,As¹/kᴬ,As¹/kᴬ)          │As¹/kᴬ      │
├───────────────────────────┼────────────────────────────────┼────────────┤
│GL_ONE_MINUS_SRC1_ALPHA    │(1,1,1)−(As¹/kᴬ,As¹/kᴬ,As¹/kᴬ)  │1−(As¹/kᴬ)  │
└───────────────────────────┴────────────────────────────────┴────────────┘
In the table, `i=min(Aˢ,1−Aᵈ)`.

To determine the blended RGBA values of a pixel, the system uses the following equations:
`Rᵈ=min(kᴿ,Rˢsᴿ+Rᵈdᴿ)`
`Gᵈ=min(kᴳ,Gˢsᴳ+Gᵈdᴳ)`
`Bᵈ=min(kᴮ,Bˢsᴮ+Bᵈdᴮ)`
`Aᵈ=min(kᴬ,Aˢsᴬ+Aᵈdᴬ)`

Despite the apparent precision of the above equations, blending arithmetic is not exactly
specified, because blending operates with imprecise integer color values. However, a blend factor
that should be equal to `1` is guaranteed not to modify its multiplicand, and a blend factor equal
to 0 reduces its multiplicand to 0. For example, when srcRGB is `GL_SRC_ALPHA`, dstRGB is `GL_ONE_MINUS_SRC_ALPHA`,
and `Aˢ` is equal to `kᴬ`, the equations reduce to simple replacement:

`Rᵈ=Rˢ`
`Gᵈ=Gˢ`
`Bᵈ=Bˢ`
`Aᵈ=Aˢ`
---
### Notes

Incoming (source) alpha is correctly thought of as a material opacity, ranging from 1.0 (Kᴬ),
representing complete opacity, to 0.0 (0), representing complete transparency.

When more than one color buffer is enabled for drawing, the GL performs blending separately for
each enabled buffer, using the contents of that buffer for destination color. (See glDrawBuffer.)

When dual source blending is enabled (i.e., one of the blend factors requiring the second color
input is used), the maximum number of enabled draw buffers is given by `GL_MAX_DUAL_SOURCE_DRAW_BUFFERS`,
which may be lower than GL_MAX_DRAW_BUFFERS.
---
### Errors

`GL_INVALID_ENUM` is generated if either srcRGB or dstRGB is not an accepted value.

`GL_INVALID_VALUE` is generated by glBlendFuncSeparatei if buf is greater than or equal to the value of GL_MAX_DRAW_BUFFERS.
---
### Associated Gets

glGet with argument `GL_BLEND_SRC_RGB`

glGet with argument `GL_BLEND_SRC_ALPHA`

glGet with argument `GL_BLEND_DST_RGB`

glGet with argument `GL_BLEND_DST_ALPHA`

glIsEnabled with argument `GL_BLEND`

]],
  [[Specify pixel arithmetic for RGB and alpha components separately
---
### Parameters
`buf` For `glBlendFuncSeparatei`, specifies the index of the draw buffer for which to set
the blend functions.

`srcRGB` Specifies how the red, green, and blue blending factors are computed. The initial
value is `GL_ONE`.

`dstRGB` Specifies how the red, green, and blue destination blending factors are computed. The
initial value is `GL_ZERO`.

`srcAlpha` Specified how the alpha source blending factor is computed. The initial value is
`GL_ONE`.

`dstAlpha` Specified how the alpha destination blending factor is computed. The initial value
is `GL_ZERO`.
]],
  [[Copy a block of pixels from one framebuffer object to another
---
### Parameters
`readFramebuffer` Specifies the name of the source framebuffer object for
`glBlitNamedFramebuffer`.

`drawFramebuffer` Specifies the name of the destination framebuffer object for
`glBlitNamedFramebuffer`.

`srcX0` `srcY0` `srcX1` `srcY1` Specify the bounds of the source rectangle within the read
buffer of the read framebuffer.
`dstX0` `dstY0` `dstX1` `dstY1` Specify the bounds of the destination rectangle within the
write buffer of the write framebuffer.
`mask` The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags
are `GL_COLOR_BUFFER_BIT`, `GL_DEPTH_BUFFER_BIT` and `GL_STENCIL_BUFFER_BIT`.

`filter` Specifies the interpolation to be applied if the image is stretched. Must be
`GL_NEAREST` or `GL_LINEAR`.

---
### Description
`glBlitFramebuffer` and `glBlitNamedFramebuffer` transfer a rectangle of pixel values from one
region of a read framebuffer to another region of a draw framebuffer.

For `glBlitFramebuffer`, the read and draw framebuffers are those bound to the
`GL_READ_FRAMEBUFFER` and `GL_DRAW_FRAMEBUFFER` targets respectively.

For `glBlitNamedFramebuffer`, `readFramebuffer` and `drawFramebuffer` are the names of the
read and draw framebuffer objects respectively. If `readFramebuffer` or `drawFramebuffer` is
zero, then the default read or draw framebuffer respectively is used.

`mask` is the bitwise OR of a number of values indicating which buffers are to be copied. The
values are `GL_COLOR_BUFFER_BIT`, `GL_DEPTH_BUFFER_BIT`, and `GL_STENCIL_BUFFER_BIT`. The
pixels corresponding to these buffers are copied from the source rectangle bounded by the locations
( `srcX0`, `srcY0` ) and ( `srcX1`, `srcY1` ) to the destination rectangle bounded by the
locations ( `dstX0`, `dstY0` ) and ( `dstX1`, `dstY1` ). The lower bounds of the rectangle are
inclusive, while the upper bounds are exclusive.

The actual region taken from the read framebuffer is limited to the intersection of the source
buffers being transferred, which may include the color buffer selected by the read buffer, the depth
buffer, and/or the stencil buffer depending on mask. The actual region written to the draw
framebuffer is limited to the intersection of the destination buffers being written, which may
include multiple draw buffers, the depth buffer, and/or the stencil buffer depending on mask.

Whether or not the source or destination regions are altered due to these limits, the scaling and
offset applied to pixels being transferred is performed as though no such limits were present. If
the sizes of the source and destination rectangles are not equal, `filter` specifies the
interpolation method that will be applied to resize the source image, and must be `GL_NEAREST` or
`GL_LINEAR`. `GL_LINEAR` is only a valid interpolation method for the color buffer. If `filter`
is not `GL_NEAREST` and `mask` includes `GL_DEPTH_BUFFER_BIT` or `GL_STENCIL_BUFFER_BIT`,
no data is transferred and a `GL_INVALID_OPERATION` error is generated.

If `filter` is `GL_LINEAR` and the source rectangle would require sampling outside the bounds
of the source framebuffer, values are read as if the `GL_CLAMP_TO_EDGE` texture wrapping mode were
applied.

When the color buffer is transferred, values are taken from the read buffer of the specified read
framebuffer and written to each of the draw buffers of the specified draw framebuffer. If the
source and destination rectangles overlap or are the same, and the read and draw buffers are the
same, the result of the operation is undefined.
---
### Errors
`GL_INVALID_OPERATION` is generated by `BlitNamedFramebuffer` if `readFramebuffer` or
`drawFramebuffer` is not zero or the name of an existing framebuffer object.

`GL_INVALID_OPERATION` is generated if `mask` contains any of the `GL_DEPTH_BUFFER_BIT` or
`GL_STENCIL_BUFFER_BIT` and `filter` is not `GL_NEAREST`.

`GL_INVALID_OPERATION` is generated if `mask` contains `GL_COLOR_BUFFER_BIT` and any of the
following conditions hold: The read buffer contains fixed-point or floating-point values and any
draw buffer contains neither fixed-point nor floating-point values. The read buffer contains
unsigned integer values and any draw buffer does not contain unsigned integer values. The read
buffer contains signed integer values and any draw buffer does not contain signed integer values.

`GL_INVALID_OPERATION` is generated if `mask` contains `GL_DEPTH_BUFFER_BIT` or
`GL_STENCIL_BUFFER_BIT` and the source and destination depth and stencil formats do not match.

`GL_INVALID_OPERATION` is generated if `filter` is `GL_LINEAR` and the read buffer contains
integer data.

`GL_INVALID_OPERATION` is generated if both the read and draw framebuffers are multisampled, and
their effective values of `GL_SAMPLES` are not identical.

`GL_INVALID_OPERATION` is generated if the value of `GL_SAMPLE_BUFFERS` for either read or draw
buffers is greater than zero and the dimensions of the source and destination rectangles is not
identical.

`GL_INVALID_FRAMEBUFFER_OPERATION` is generated if the specified read and draw framebuffers are
not framebuffer complete.
---
### Version Support
`glBlitFramebuffer` `glBlitNamedFramebuffer`
---
### See Also
glReadPixels glCheckFramebufferStatus, glGenFramebuffers glBindFramebuffer
glDeleteFramebuffers
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Creates and initializes a buffer object's data store
---
### Parameters
`target` Specifies the target to which the buffer object is bound for `glBufferData`, which
must be one of the buffer binding targets in the following table:

`buffer` Specifies the name of the buffer object for `glNamedBufferData` function.

`size` Specifies the size in bytes of the buffer object's new data store.
`data` Specifies a pointer to data that will be copied into the data store for initialization,
or `NULL` if no data is to be copied.

`usage` Specifies the expected usage pattern of the data store. The symbolic constant must be
`GL_STREAM_DRAW`, `GL_STREAM_READ`, `GL_STREAM_COPY`, `GL_STATIC_DRAW`, `GL_STATIC_READ`,
`GL_STATIC_COPY`, `GL_DYNAMIC_DRAW`, `GL_DYNAMIC_READ`, or `GL_DYNAMIC_COPY`.

---
### Description
`glBufferData` and `glNamedBufferData` create a new data store for a buffer object. In case of
`glBufferData`, the buffer object currently bound to `target` is used. For `glNamedBufferData`,
a buffer object associated with ID specified by the caller in `buffer` will be used instead.

While creating the new storage, any pre-existing data store is deleted. The new data store is
created with the specified `size` in bytes and `usage`. If `data` is not `NULL`, the data
store is initialized with data from this pointer. In its initial state, the new data store is not
mapped, it has a `NULL` mapped pointer, and its mapped access is `GL_READ_WRITE`.

`usage` is a hint to the GL implementation as to how a buffer object's data store will be
accessed. This enables the GL implementation to make more intelligent decisions that may
significantly impact buffer object performance. It does not, however, constrain the actual usage of
the data store. `usage` can be broken down into two parts: first, the frequency of access
(modification and usage), and second, the nature of that access. The frequency of access may be one
of these:

STREAM The data store contents will be modified once and used at most a few times.

STATIC The data store contents will be modified once and used many times.

DYNAMIC The data store contents will be modified repeatedly and used many times.

The nature of access may be one of these: DRAW The data store contents are modified by the
application, and used as the source for GL drawing and image specification commands.

READ The data store contents are modified by reading data from the GL, and used to return that
data when queried by the application.

COPY The data store contents are modified by reading data from the GL, and used as the source for
GL drawing and image specification commands.
---
### Notes
If `data` is `NULL`, a data store of the specified size is still created, but its contents
remain uninitialized and thus undefined.

Clients must align data elements consistently with the requirements of the client platform, with
an additional base-level requirement that an offset within a buffer to a datum comprising N
bytes be a multiple of N.

The `GL_ATOMIC_COUNTER_BUFFER` target is available only if the GL version is 4.2 or greater.

The `GL_DISPATCH_INDIRECT_BUFFER` and `GL_SHADER_STORAGE_BUFFER` targets are available only if
the GL version is 4.3 or greater.

The `GL_QUERY_BUFFER` target is available only if the GL version is 4.4 or greater.
---
### Errors
`GL_INVALID_ENUM` is generated by `glBufferData` if `target` is not one of the accepted
buffer targets.

`GL_INVALID_ENUM` is generated if `usage` is not `GL_STREAM_DRAW`, `GL_STREAM_READ`,
`GL_STREAM_COPY`, `GL_STATIC_DRAW`, `GL_STATIC_READ`, `GL_STATIC_COPY`, `GL_DYNAMIC_DRAW`,
`GL_DYNAMIC_READ`, or `GL_DYNAMIC_COPY`.

`GL_INVALID_VALUE` is generated if `size` is negative.

`GL_INVALID_OPERATION` is generated by `glBufferData` if the reserved buffer object name 0 is
bound to `target`.

`GL_INVALID_OPERATION` is generated by `glNamedBufferData` if buffer is not the name of an
existing buffer object.

`GL_INVALID_OPERATION` is generated if the `GL_BUFFER_IMMUTABLE_STORAGE` flag of the buffer
object is `GL_TRUE`.

`GL_OUT_OF_MEMORY` is generated if the GL is unable to create a data store with the specified
`size`.
---
### Associated Gets
glGetBufferSubData

glGetBufferParameter with argument `GL_BUFFER_SIZE` or `GL_BUFFER_USAGE`
---
### Version Support
`glBufferData` `glNamedBufferData`
---
### See Also
glBindBuffer, glBufferSubData, glMapBuffer, glUnmapBuffer
---
### Copyright
Copyright 2005 Addison-Wesley. Copyright 2010-2014 Khronos Group. This material may be
distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8
June 1999. https://opencontent.org/openpub/.
]],
  [[Return the address of the specified generic vertex attribute pointer
---
### Parameters
`index` Specifies the generic vertex attribute parameter to be returned.
`pname` Specifies the symbolic name of the generic vertex attribute parameter to be returned.

Must be `GL_VERTEX_ATTRIB_ARRAY_POINTER`.

`pointer` Returns the pointer value.
---
### Description
`glGetVertexAttribPointerv` returns pointer information. `index` is the generic vertex
attribute to be queried, `pname` is a symbolic constant indicating the pointer to be returned, and
`params` is a pointer to a location in which to place the returned data.

The `pointer` returned is a byte offset into the data store of the buffer object that was bound
to the `GL_ARRAY_BUFFER` target (see glBindBuffer ) when the desired pointer was previously
specified.
---
### Notes
The state returned is retrieved from the currently bound vertex array object. The initial value for
each pointer is 0.
---
### Errors
`GL_INVALID_OPERATION` is generated if no vertex array object is currently bound.

`GL_INVALID_VALUE` is generated if `index` is greater than or equal to `GL_MAX_VERTEX_ATTRIBS`.

`GL_INVALID_ENUM` is generated if `pname` is not an accepted value.
---
### Associated Gets
glGet with argument `GL_MAX_VERTEX_ATTRIBS`
---
### Version Support
`glGetVertexAttribPointerv`
---
### See Also
glGetVertexAttrib, glVertexAttribPointer
---
### Copyright
Copyright 2003-2005 3Dlabs Inc. Ltd. Copyright 2010-2014 Khronos Group. This material may be
distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8
June 1999. https://opencontent.org/openpub/.
]],
  [[Creates and initializes a buffer object's immutable data store
---
### Parameters
`target` Specifies the target to which the buffer object is bound for `glBufferStorage`,
which must be one of the buffer binding targets in the following table:

`buffer` Specifies the name of the buffer object for `glNamedBufferStorage` function.

`size` Specifies the size in bytes of the buffer object's new data store.
`data` Specifies a pointer to data that will be copied into the data store for initialization,
or `NULL` if no data is to be copied.

`flags` Specifies the intended usage of the buffer's data store. Must be a bitwise combination
of the following flags. `GL_DYNAMIC_STORAGE_BIT`, `GL_MAP_READ_BIT` `GL_MAP_WRITE_BIT`,
`GL_MAP_PERSISTENT_BIT`, `GL_MAP_COHERENT_BIT`, and `GL_CLIENT_STORAGE_BIT`.

---
### Description
`glBufferStorage` and `glNamedBufferStorage` create a new immutable data store. For
`glBufferStorage`, the buffer object currently bound to `target` will be initialized. For
`glNamedBufferStorage`, `buffer` is the name of the buffer object that will be configured. The
size of the data store is specified by `size`. If an initial data is available, its address may be
supplied in `data`. Otherwise, to create an uninitialized data store, `data` should be `NULL`.

The `flags` parameters specifies the intended usage of the buffer's data store. It must be a
bitwise combination of a subset of the following flags: `GL_DYNAMIC_STORAGE_BIT` The contents
of the data store may be updated after creation through calls to glBufferSubData. If this bit is
not set, the buffer content may not be directly updated by the client. The data argument may be used
to specify the initial content of the buffer's data store regardless of the presence of the
`GL_DYNAMIC_STORAGE_BIT`. Regardless of the presence of this bit, buffers may always be updated
with server-side calls such as glCopyBufferSubData and glClearBufferSubData.

`GL_MAP_READ_BIT` The data store may be mapped by the client for read access and a pointer in
the client's address space obtained that may be read from.
`GL_MAP_WRITE_BIT` The data store may be mapped by the client for write access and a pointer in
the client's address space obtained that may be written through.
`GL_MAP_PERSISTENT_BIT` The client may request that the server read from or write to the buffer
while it is mapped. The client's pointer to the data store remains valid so long as the data store
is mapped, even during execution of drawing or dispatch commands.
`GL_MAP_COHERENT_BIT` Shared access to buffers that are simultaneously mapped for client access
and are used by the server will be coherent, so long as that mapping is performed using
glMapBufferRange. That is, data written to the store by either the client or server will be
immediately visible to the other with no further action taken by the application. In particular,

If `GL_MAP_COHERENT_BIT` is not set and the client performs a write followed by a call to the
glMemoryBarrier command with the `GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT` set, then in subsequent
commands the server will see the writes.

If `GL_MAP_COHERENT_BIT` is set and the client performs a write, then in subsequent commands the
server will see the writes.

If `GL_MAP_COHERENT_BIT` is not set and the server performs a write, the application must call
glMemoryBarrier with the `GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT` set and then call glFenceSync
with `GL_SYNC_GPU_COMMANDS_COMPLETE` (or `glFinish` ). Then the CPU will see the writes after the
sync is complete.

If `GL_MAP_COHERENT_BIT` is set and the server does a write, the app must call `glFenceSync`
with `GL_SYNC_GPU_COMMANDS_COMPLETE` (or glFinish ). Then the CPU will see the writes after the
sync is complete.

`GL_CLIENT_STORAGE_BIT` When all other criteria for the buffer storage allocation are met, this
bit may be used by an implementation to determine whether to use storage that is local to the server
or to the client to serve as the backing store for the buffer.

The allowed combinations of flags are subject to certain restrictions. They are as follows: If
`flags` contains `GL_MAP_PERSISTENT_BIT`, it must also contain at least one of `GL_MAP_READ_BIT`
or `GL_MAP_WRITE_BIT`.

If `flags` contains `GL_MAP_COHERENT_BIT`, it must also contain `GL_MAP_PERSISTENT_BIT`.

---
### Notes
`glBufferStorage` is available only if the GL version is 4.4 or greater.

`glNamedBufferStorage` is available only if the GL version is 4.5 or greater.

If `data` is `NULL`, a data store of the specified size is still created, but its contents
remain uninitialized and thus undefined.
---
### Errors
`GL_INVALID_ENUM` is generated by `glBufferStorage` if `target` is not one of the accepted
buffer targets.

`GL_INVALID_OPERATION` is generated by `glNamedBufferStorage` if buffer is not the name of an
existing buffer object.

`GL_INVALID_VALUE` is generated if `size` is less than or equal to zero.

`GL_INVALID_OPERATION` is generated by `glBufferStorage` if the reserved buffer object name 0
is bound to `target`.

`GL_OUT_OF_MEMORY` is generated if the GL is unable to create a data store with the properties
requested in `flags`.

`GL_INVALID_VALUE` is generated if `flags` has any bits set other than those defined above.

`GL_INVALID_VALUE` error is generated if `flags` contains `GL_MAP_PERSISTENT_BIT` but does
not contain at least one of `GL_MAP_READ_BIT` or `GL_MAP_WRITE_BIT`.

`GL_INVALID_VALUE` is generated if `flags` contains `GL_MAP_COHERENT_BIT`, but does not also
contain `GL_MAP_PERSISTENT_BIT`.

`GL_INVALID_OPERATION` is generated by `glBufferStorage` if the `GL_BUFFER_IMMUTABLE_STORAGE`
flag of the buffer bound to `target` is `GL_TRUE`.
---
### Associated Gets
glGetBufferSubData

glGetBufferParameter with argument `GL_BUFFER_SIZE` or `GL_BUFFER_USAGE`
---
### Version Support
`glBufferStorage` `glNamedBufferStorage`
---
### See Also
glBindBuffer, glBufferSubData, glMapBuffer, glUnmapBuffer
---
### Copyright
Copyright 2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Specify implementation-specific hints
---
### Parameters
`target` Specifies a symbolic constant indicating the behavior to be controlled.
`GL_LINE_SMOOTH_HINT`, `GL_POLYGON_SMOOTH_HINT`, `GL_TEXTURE_COMPRESSION_HINT`, and
`GL_FRAGMENT_SHADER_DERIVATIVE_HINT` are accepted.

`mode` Specifies a symbolic constant indicating the desired behavior. `GL_FASTEST`,
`GL_NICEST`, and `GL_DONT_CARE` are accepted.

---
### Description
Certain aspects of GL behavior, when there is room for interpretation, can be controlled with
hints. A hint is specified with two arguments. `target` is a symbolic constant indicating the
behavior to be controlled, and `mode` is another symbolic constant indicating the desired
behavior. The initial value for each `target` is `GL_DONT_CARE`. `mode` can be one of the
following:

`GL_FASTEST` The most efficient option should be chosen.
`GL_NICEST` The most correct, or highest quality, option should be chosen.
`GL_DONT_CARE` No preference.

Though the implementation aspects that can be hinted are well defined, the interpretation of the
hints depends on the implementation. The hint aspects that can be specified with `target`, along
with suggested semantics, are as follows:

`GL_FRAGMENT_SHADER_DERIVATIVE_HINT` Indicates the accuracy of the derivative calculation for
the GL shading language fragment processing built-in functions: `dFdx`, `dFdy`, and `fwidth`.


`GL_LINE_SMOOTH_HINT` Indicates the sampling quality of antialiased lines. If a larger filter
function is applied, hinting `GL_NICEST` can result in more pixel fragments being generated during
rasterization.

`GL_POLYGON_SMOOTH_HINT` Indicates the sampling quality of antialiased polygons. Hinting
`GL_NICEST` can result in more pixel fragments being generated during rasterization, if a larger
filter function is applied.

`GL_TEXTURE_COMPRESSION_HINT` Indicates the quality and performance of the compressing texture
images. Hinting `GL_FASTEST` indicates that texture images should be compressed as quickly as
possible, while `GL_NICEST` indicates that texture images should be compressed with as little
image quality loss as possible. `GL_NICEST` should be selected if the texture is to be retrieved
by glGetCompressedTexImage for reuse.

---
### Notes
The interpretation of hints depends on the implementation. Some implementations ignore `glHint`
settings.
---
### Errors
`GL_INVALID_ENUM` is generated if either `target` or `mode` is not an accepted value.
---
### Version Support
`glHint`
---
### See Also
---
### Copyright
Copyright 1991-2006 Silicon Graphics, Inc. Copyright 2010-2014 Khronos Group. This document
is licensed under the SGI Free Software B License. For details, see
https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.
]],
  [[Invalidate the content of a buffer object's data store
---
### Parameters
`buffer` The name of a buffer object whose data store to invalidate.
---
### Description
`glInvalidateBufferData` invalidates all of the content of the data store of a buffer object.

After invalidation, the content of the buffer's data store becomes undefined.
---
### Errors
`GL_INVALID_VALUE` is generated if `buffer` is not the name of an existing buffer object.

`GL_INVALID_OPERATION` is generated if any part of `buffer` is currently mapped.
---
### Associated Gets
glGetBufferParameter with argument `GL_BUFFER_SIZE`
---
### Version Support
`glInvalidateBufferData`
---
### See Also
glInvalidateTexSubImage,, glInvalidateTexImage, glInvalidateBufferSubData,
glInvalidateFramebuffer, glInvalidateSubFramebuffer.
---
### Copyright
Copyright 2013-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Updates a subset of a buffer object's data store
---
### Parameters
`target` Specifies the target to which the buffer object is bound for `glBufferSubData`,
which must be one of the buffer binding targets in the following table:

`buffer` Specifies the name of the buffer object for `glNamedBufferSubData`.

`offset` Specifies the offset into the buffer object's data store where data replacement will
begin, measured in bytes.
`size` Specifies the size in bytes of the data store region being replaced.
`data` Specifies a pointer to the new data that will be copied into the data store.
---
### Description
`glBufferSubData` and `glNamedBufferSubData` redefine some or all of the data store for the
specified buffer object. Data starting at byte offset `offset` and extending for `size` bytes is
copied to the data store from the memory pointed to by `data`. `offset` and `size` must define
a range lying entirely within the buffer object's data store.
---
### Notes
When replacing the entire data store, consider using `glBufferSubData` rather than completely
recreating the data store with `glBufferData`. This avoids the cost of reallocating the data
store.

Consider using multiple buffer objects to avoid stalling the rendering pipeline during data store
updates. If any rendering in the pipeline makes reference to data in the buffer object being updated
by `glBufferSubData`, especially from the specific region being updated, that rendering must drain
from the pipeline before the data store can be updated.

Clients must align data elements consistent with the requirements of the client platform, with an
additional base-level requirement that an offset within a buffer to a datum comprising $N$ bytes be
a multiple of $N$. The `GL_ATOMIC_COUNTER_BUFFER` target is available only if the GL version is
4.2 or greater.

The `GL_DISPATCH_INDIRECT_BUFFER` and `GL_SHADER_STORAGE_BUFFER` targets are available only if
the GL version is 4.3 or greater.

The `GL_QUERY_BUFFER` target is available only if the GL version is 4.4 or greater.
---
### Errors
`GL_INVALID_ENUM` is generated by `glBufferSubData` if `target` is not one of the accepted
buffer targets.

`GL_INVALID_OPERATION` is generated by `glBufferSubData` if zero is bound to `target`.

`GL_INVALID_OPERATION` is generated by `glNamedBufferSubData` if `buffer` is not the name of
an existing buffer object.

`GL_INVALID_VALUE` is generated if `offset` or `size` is negative, or if $offset + size$ is
greater than the value of `GL_BUFFER_SIZE` for the specified buffer object.

`GL_INVALID_OPERATION` is generated if any part of the specified range of the buffer object is
mapped with glMapBufferRange or glMapBuffer, unless it was mapped with the
`GL_MAP_PERSISTENT_BIT` bit set in the `glMapBufferRange` `access` flags.

`GL_INVALID_OPERATION` is generated if the value of the `GL_BUFFER_IMMUTABLE_STORAGE` flag of
the buffer object is `GL_TRUE` and the value of `GL_BUFFER_STORAGE_FLAGS` for the buffer object
does not have the `GL_DYNAMIC_STORAGE_BIT` bit set.
---
### Associated Gets
glGetBufferSubData
---
### Version Support
`glBufferSubData` `glNamedBufferSubData`
---
### See Also
glBindBuffer, glBufferData, glMapBuffer, glMapBufferRange, glUnmapBuffer
---
### Copyright
Copyright 2005 Addison-Wesley. Copyright 2010-2014 Khronos Group. This material may be
distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8
June 1999. https://opencontent.org/openpub/.
]],
  [[Invalidate a region of a buffer object's data store
---
### Parameters
`buffer` The name of a buffer object, a subrange of whose data store to invalidate.
`offset` The offset within the buffer's data store of the start of the range to be invalidated.

`length` The length of the range within the buffer's data store to be invalidated.
---
### Description
`glInvalidateBufferSubData` invalidates all or part of the content of the data store of a buffer
object. After invalidation, the content of the specified range of the buffer's data store becomes
undefined. The start of the range is given by `offset` and its size is given by `length`, both
measured in basic machine units.
---
### Errors
`GL_INVALID_VALUE` is generated if `offset` or `length` is negative, or if `offset` +
`length` is greater than the value of `GL_BUFFER_SIZE` for `buffer`.

`GL_INVALID_VALUE` is generated if `buffer` is not the name of an existing buffer object.

`GL_INVALID_OPERATION` is generated if any part of `buffer` is currently mapped.
---
### Associated Gets
glGetBufferParameter with argument `GL_BUFFER_SIZE`
---
### Version Support
`glInvalidateBufferSubData`
---
### See Also
glInvalidateTexSubImage,, glInvalidateTexImage, glInvalidateBufferData,
glInvalidateFramebuffer, glInvalidateSubFramebuffer.
---
### Copyright
Copyright 2013-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Invalidate the content of some or all of a framebuffer's attachments
---
### Parameters
`target` Specifies the target to which the framebuffer object is attached for
`glInvalidateFramebuffer`.

`framebuffer` Specifies the name of the framebuffer object for
`glInvalidateNamedFramebufferData`.

`numAttachments` Specifies the number of entries in the `attachments` array.

`attachments` Specifies a pointer to an array identifying the attachments to be invalidated.
---
### Description
`glInvalidateFramebuffer` and `glInvalidateNamedFramebufferData` invalidate the entire contents
of a specified set of attachments of a framebuffer.

For `glInvalidateFramebuffer`, the framebuffer object is that bound to `target`. `target`
must be `GL_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER` or `GL_DRAW_FRAMEBUFFER`. `GL_FRAMEBUFFER`
is equivalent to `GL_DRAW_FRAMEBUFFER`. Default framebuffers may also be invalidated if bound to
`target`.

For `glInvalidateNamedFramebufferData`, `framebuffer` is the name of the framebuffer object.

If `framebuffer` is zero, the default draw framebuffer is affected.

The set of attachments whose contents are to be invalidated are specified in the `attachments`
array, which contains `numAttachments` elements.

If the specified framebuffer is a framebuffer object, each element of `attachments` must be one
of `GL_DEPTH_ATTACHMENT`, `GL_STENCIL_ATTACHMENT` `GL_DEPTH_STENCIL_ATTACHMENT`, or
`GL_COLOR_ATTACHMENT` i, where i is between zero and the value of
`GL_MAX_FRAMEBUFFER_ATTACHMENTS` minus one.

If the specified framebuffer is a default framebuffer, each element of `attachments` must be one
of `GL_FRONT_LEFT`, `GL_FRONT_RIGHT`, `GL_BACK_LEFT`, `GL_BACK_RIGHT`, `GL_AUX` i,
`GL_ACCUM`, `GL_COLOR`, `GL_DEPTH`, or `GL_STENCIL`. `GL_COLOR`, is treated as
`GL_BACK_LEFT` for a double-buffered context and `GL_FRONT_LEFT` for a single-buffered context.

The other attachments identify the corresponding specific buffer.

The entire contents of each specified attachment become undefined after execution of
`glInvalidateFramebuffer` or `glInvalidateNamedFramebufferData`.

If the framebuffer object is not complete, `glInvalidateFramebuffer` and
`glInvalidateNamedFramebufferData` may be ignored. This is not an error.
---
### Errors
`GL_INVALID_ENUM` is generated by `glInvalidateFramebuffer` if `target` is not one of the
accepted framebuffer targets.

`GL_INVALID_OPERATION` is generated by `glInvalidateNamedFramebufferData` if `framebuffer` is
not zero or the name of an existing framebuffer object.

`GL_INVALID_VALUE` is generated if `numAttachments` is negative.

`GL_INVALID_ENUM` is generated if any element of `attachments` is not one of the accepted
framebuffer attachment points, as described above.

`GL_INVALID_OPERATION` is generated if element of `attachments` is `GL_COLOR_ATTACHMENT` m
where m is greater than or equal to the value of `GL_MAX_COLOR_ATTACHMENTS`.
---
### Associated Gets
glGet with argument `GL_MAX_COLOR_ATTACHMENTS`
---
### Version Support
`glInvalidateFramebuffer` `glInvalidateNamedFramebufferData`
---
### See Also
glInvalidateTexSubImage, glInvalidateTexImage, glInvalidateBufferSubData,
glInvalidateBufferData, glInvalidateSubFramebuffer.
---
### Copyright
Copyright 2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Check the completeness status of a framebuffer
---
### Parameters
`target` Specify the target to which the framebuffer is bound for `glCheckFramebufferStatus`,
and the target against which framebuffer completeness of `framebuffer` is checked for
`glCheckNamedFramebufferStatus`.

`framebuffer` Specifies the name of the framebuffer object for `glCheckNamedFramebufferStatus`

---
### Description
`glCheckFramebufferStatus` and `glCheckNamedFramebufferStatus` return the completeness status
of a framebuffer object when treated as a read or draw framebuffer, depending on the value of
`target`.

For `glCheckFramebufferStatus`, the framebuffer checked is that bound to `target`, which must
be `GL_DRAW_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER` or `GL_FRAMEBUFFER`. `GL_FRAMEBUFFER` is
equivalent to `GL_DRAW_FRAMEBUFFER`.

For `glCheckNamedFramebufferStatus`, `framebuffer` is zero or the name of the framebuffer
object to check. If `framebuffer` is zero, then the status of the default read or draw
framebuffer, as determined by `target`, is returned.

The return value is `GL_FRAMEBUFFER_COMPLETE` if the specified framebuffer is complete.

Otherwise, the return value is determined as follows: `GL_FRAMEBUFFER_UNDEFINED` is returned if
the specified framebuffer is the default read or draw framebuffer, but the default framebuffer does
not exist.

`GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT` is returned if any of the framebuffer attachment points
are framebuffer incomplete.

`GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT` is returned if the framebuffer does not have at
least one image attached to it.

`GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER` is returned if the value of
`GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE` is `GL_NONE` for any color attachment point(s) named by
`GL_DRAW_BUFFERi`.

`GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER` is returned if `GL_READ_BUFFER` is not `GL_NONE` and
the value of `GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE` is `GL_NONE` for the color attachment point
named by `GL_READ_BUFFER`.

`GL_FRAMEBUFFER_UNSUPPORTED` is returned if the combination of internal formats of the attached
images violates an implementation-dependent set of restrictions.

`GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE` is returned if the value of `GL_RENDERBUFFER_SAMPLES`
is not the same for all attached renderbuffers; if the value of `GL_TEXTURE_SAMPLES` is the not
same for all attached textures; or, if the attached images are a mix of renderbuffers and textures,
the value of `GL_RENDERBUFFER_SAMPLES` does not match the value of `GL_TEXTURE_SAMPLES`.

`GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE` is also returned if the value of
`GL_TEXTURE_FIXED_SAMPLE_LOCATIONS` is not the same for all attached textures; or, if the attached
images are a mix of renderbuffers and textures, the value of `GL_TEXTURE_FIXED_SAMPLE_LOCATIONS`
is not `GL_TRUE` for all attached textures.

`GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS` is returned if any framebuffer attachment is layered,
and any populated attachment is not layered, or if all populated color attachments are not from
textures of the same target.


Additionally, if an error occurs, zero is returned.
---
### Errors
`GL_INVALID_ENUM` is generated if `target` is not `GL_DRAW_FRAMEBUFFER`,
`GL_READ_FRAMEBUFFER` or `GL_FRAMEBUFFER`.

`GL_INVALID_OPERATION` is generated by `glCheckNamedFramebufferStatus` if `framebuffer` is
not zero or the name of an existing framebuffer object.
---
### Version Support
`glCheckFramebufferStatus` `glCheckNamedFramebufferStatus`
---
### See Also
glGenFramebuffers, glDeleteFramebuffers glBindFramebuffer
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Invalidate the content of a region of some or all of a framebuffer's attachments
---
### Parameters
`target` Specifies the target to which the framebuffer object is attached for
`glInvalidateSubFramebuffer`.

`framebuffer` Specifies the name of the framebuffer object for
`glInvalidateNamedFramebufferSubData`.

`numAttachments` Specifies the number of entries in the `attachments` array.

`attachments` Specifies a pointer to an array identifying the attachments to be invalidated.
`x` Specifies the X offset of the region to be invalidated.
`y` Specifies the Y offset of the region to be invalidated.
`width` Specifies the width of the region to be invalidated.
`height` Specifies the height of the region to be invalidated.
---
### Description
`glInvalidateSubFramebuffer` and `glInvalidateNamedFramebufferSubData` invalidate the contents
of a specified region of a specified set of attachments of a framebuffer.

For `glInvalidateSubFramebuffer`, the framebuffer object is that bound to `target`, which must
be one of `GL_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER` or `GL_DRAW_FRAMEBUFFER`. `GL_FRAMEBUFFER`
is equivalent to `GL_DRAW_FRAMEBUFFER`. Default framebuffers may also be invalidated if bound to
`target`.

For `glInvalidateNamedFramebufferSubData`, `framebuffer` is the name of the framebuffer
object. If `framebuffer` is zero, the default draw framebuffer is affected.

The set of attachments of which a region is to be invalidated are specified in the `attachments`
array, which contains `numAttachments` elements.

If the specified framebuffer is a framebuffer object, each element of `attachments` must be one
of `GL_DEPTH_ATTACHMENT`, `GL_STENCIL_ATTACHMENT` `GL_DEPTH_STENCIL_ATTACHMENT`, or
`GL_COLOR_ATTACHMENT` i, where i is between zero and the value of
`GL_MAX_FRAMEBUFFER_ATTACHMENTS` minus one.

If the specified framebuffer is a default framebuffer, each element of `attachments` must be one
of `GL_FRONT_LEFT`, `GL_FRONT_RIGHT`, `GL_BACK_LEFT`, `GL_BACK_RIGHT`, `GL_AUX` i,
`GL_ACCUM`, `GL_COLOR`, `GL_DEPTH`, or `GL_STENCIL`. `GL_COLOR`, is treated as
`GL_BACK_LEFT` for a double-buffered context and `GL_FRONT_LEFT` for a single-buffered context.

The other attachments identify the corresponding specific buffer.

The contents of the specified region of each specified attachment become undefined after execution
of `glInvalidateSubFramebuffer` or `glInvalidateNamedFramebufferSubData`. The region to be
invalidated is specified by `x`, `y`, `width` and `height` where `x` and `y` give the
offset from the origin (with lower-left corner at $(0,0)$) and `width` and `height` are the
width and height, respectively, of the region. Any pixels lying outside of the window allocated to
the current GL context (for the default framebuffer), or outside of the attachments of the
framebuffer object, are ignored. If the framebuffer object is not complete, these commands may be
ignored.

If the framebuffer object is not complete, `glInvalidateSubFramebuffer` and
`glInvalidateNamedFramebufferSubData` may be ignored. This is not an error.
---
### Errors
`GL_INVALID_ENUM` by `glInvalidateSubFramebuffer` if `target` is not one of the accepted
framebuffer targets.

`GL_INVALID_OPERATION` by `glInvalidateNamedFramebufferSubData` if `framebuffer` is not zero
of the name of an existing framebuffer object.

`GL_INVALID_VALUE` is generated if `numAttachments`, `width` or `height` is negative.

`GL_INVALID_ENUM` is generated if any element of `attachments` is not one of the accepted
framebuffer attachment points, as described above.

`GL_INVALID_OPERATION` is generated if element of `attachments` is `GL_COLOR_ATTACHMENT` m
where m is greater than or equal to the value of `GL_MAX_COLOR_ATTACHMENTS`.
---
### Associated Gets
glGet with argument `GL_MAX_COLOR_ATTACHMENTS`
---
### Version Support
`glInvalidateNamedFramebufferSubData` `glInvalidateSubFramebuffer`
---
### See Also
glInvalidateTexSubImage, glInvalidateTexImage, glInvalidateBufferSubData,
glInvalidateBufferData, glInvalidateFramebuffer.
---
### Copyright
Copyright 2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Specify whether data read via GlReadPixels should be clamped
---
### Parameters
`target` Target for color clamping. `target` must be `GL_CLAMP_READ_COLOR`.

`clamp` Specifies whether to apply color clamping. `clamp` must be `GL_TRUE` or `GL_FALSE`.

---
### Description
`glClampColor` controls color clamping that is performed during glReadPixels. `target` must
be `GL_CLAMP_READ_COLOR`. If `clamp` is `GL_TRUE`, read color clamping is enabled; if `clamp`
is `GL_FALSE`, read color clamping is disabled. If `clamp` is `GL_FIXED_ONLY`, read color
clamping is enabled only if the selected read buffer has fixed point components and disabled
otherwise.
---
### Errors
`GL_INVALID_ENUM` is generated if `target` is not `GL_CLAMP_READ_COLOR`.

`GL_INVALID_ENUM` is generated if `clamp` is not `GL_TRUE` or `GL_FALSE`.
---
### Associated Gets
glGet with argument `GL_CLAMP_READ_COLOR`.
---
### Version Support
`glClampColor`
---
### See Also
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Clear buffers to preset values
---
### Parameters
`mask` Bitwise OR of masks that indicate the buffers to be cleared. The three masks are
`GL_COLOR_BUFFER_BIT`, `GL_DEPTH_BUFFER_BIT`, and `GL_STENCIL_BUFFER_BIT`.

---
### Description
`glClear` sets the bitplane area of the window to values previously selected by `glClearColor`,
`glClearDepth`, and `glClearStencil`. Multiple color buffers can be cleared simultaneously by
selecting more than one buffer at a time using glDrawBuffer.

The pixel ownership test, the scissor test, dithering, and the buffer writemasks affect the
operation of `glClear`. The scissor box bounds the cleared region. Alpha function, blend function,
logical operation, stenciling, texture mapping, and depth-buffering are ignored by `glClear`.

`glClear` takes a single argument that is the bitwise OR of several values indicating which
buffer is to be cleared.

The values are as follows: `GL_COLOR_BUFFER_BIT` Indicates the buffers currently enabled for
color writing.
`GL_DEPTH_BUFFER_BIT` Indicates the depth buffer.
`GL_STENCIL_BUFFER_BIT` Indicates the stencil buffer.

The value to which each buffer is cleared depends on the setting of the clear value for that
buffer.
---
### Notes
If a buffer is not present, then a `glClear` directed at that buffer has no effect.
---
### Errors
`GL_INVALID_VALUE` is generated if any bit other than the three defined bits is set in `mask`.

---
### Associated Gets
glGet with argument `GL_DEPTH_CLEAR_VALUE`

glGet with argument `GL_COLOR_CLEAR_VALUE`

glGet with argument `GL_STENCIL_CLEAR_VALUE`
---
### Version Support
`glClear`
---
### See Also
`glClearColor`, `glClearDepth`, `glClearStencil`, glColorMask, glDepthMask,
glDrawBuffer, glScissor, glStencilMask
---
### Copyright
Copyright 1991-2006 Silicon Graphics, Inc. Copyright 2010-2014 Khronos Group. This document
is licensed under the SGI Free Software B License. For details, see
https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.
]],
  [[Invalidate the entirety a texture image
---
### Parameters
`texture` The name of a texture object to invalidate.
`level` The level of detail of the texture object to invalidate.
---
### Description
`glInvalidateTexSubImage` invalidates all of a texture image. `texture` and `level` indicated
which texture image is being invalidated. After this command, data in the texture image has
undefined values.

`level` must be greater than or equal to zero and be less than the base 2 logarithm of the
maximum texture width, height, or depth.

For textures of targets `GL_TEXTURE_RECTANGLE`, `GL_TEXTURE_BUFFER`,
`GL_TEXTURE_2D_MULTISAMPLE`, or `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`, level must be zero.
---
### Errors
`GL_INVALID_VALUE` is generated if `level` is less than zero or if it is greater or equal to
the base 2 logarithm of the maximum texture width, height, or depth.

`GL_INVALID_VALUE` is generated if the target of `texture` is any of `GL_TEXTURE_RECTANGLE`,
`GL_TEXTURE_BUFFER`, `GL_TEXTURE_2D_MULTISAMPLE`, or `GL_TEXTURE_2D_MULTISAMPLE_ARRAY` and
`level` is not zero.

`GL_INVALID_VALUE` is generated if `texture` is not the name of an existing texture object.
---
### Associated Gets
glGet with argument `GL_MAX_TEXTURE_SIZE`
---
### Version Support
`glInvalidateTexImage`
---
### See Also
glInvalidateTexSubImage,, glInvalidateBufferSubData, glInvalidateBufferData,
glInvalidateFramebuffer, glInvalidateSubFramebuffer.
---
### Copyright
Copyright 2013-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Clear individual buffers of a framebuffer
---
### Parameters
`framebuffer` Specifies the name of the framebuffer object for `glClearNamedFramebuffer*`.

`buffer` Specify the buffer to clear.
`drawbuffer` Specify a particular draw buffer to clear.
`value` A pointer to the value or values to clear the buffer to.
`depth` The value to clear the depth buffer to.
`stencil` The value to clear the stencil buffer to.
---
### Description
These commands clear a specified buffer of a framebuffer to specified value(s). For
`glClearBuffer*`, the framebuffer is the currently bound draw framebuffer object. For
`glClearNamedFramebuffer*`, `framebuffer` is zero, indicating the default draw framebuffer, or
the name of a framebuffer object.

`buffer` and `drawbuffer` identify the buffer to clear.

If `buffer` is `GL_COLOR`, a particular draw buffer `GL_DRAW_BUFFER` `i` is specified by
passing `i` as `drawbuffer`, and `value` points to a four-element vector specifying the R, G,
B and A color to clear that draw buffer to. If the value of `GL_DRAW_BUFFER` `i` is `GL_NONE`,
the command has no effect. Otherwise, the value of `GL_DRAW_BUFFER` `i` identifies one or more
color buffers, each of which is cleared to the same value. Clamping and type conversion for
fixed-point color buffers are performed in the same fashion as for glClearColor. The `*fv`,
`*iv` and `*uiv` forms of these commands should be used to clear fixed- and floating-point,
signed integer, and unsigned integer color buffers respectively.

If `buffer` is `GL_DEPTH`, `drawbuffer` must be zero, and `value` points to a single value
to clear the depth buffer to. Clamping and type conversion for fixed-point depth buffers are
performed in the same fashion as for glClearDepth. Only the `*fv` forms of these commands
should be used to clear depth buffers; other forms do not accept a `buffer` of `GL_DEPTH`.

If `buffer` is `GL_STENCIL`, `drawbuffer` must be zero, and `value` points to a single
value to clear the stencil buffer to. Masking is performed in the same fashion as for
glClearStencil. Only the `*iv` forms of these commands should be used to clear stencil buffers;
be used to clear stencil buffers; other forms do not accept a `buffer` of `GL_STENCIL`.

`glClearBufferfi` and `glClearNamedFramebufferfi` are used to clear the depth and stencil
buffers simultaneously. `buffer` must be `GL_DEPTH_STENCIL` and `drawbuffer` must be zero.
`depth` and `stencil` are the values to clear the depth and stencil buffers to, respectively.

Clamping and type conversion of `depth` for fixed-point depth buffers are performed in the same
fashion as for glClearDepth. Masking of `stencil` for stencil buffers is performed in the same
fashion as for glClearStencil. These commands are equivalent to clearing the depth and stencil
buffers separately, but may be faster when a buffer of internal format `GL_DEPTH_STENCIL` is being
cleared. The same per-fragment and masking operations defined for `glClear` are applied.

The result of these commands is undefined if no conversion between the type of the specified
`value` and the type of the buffer being cleared is defined (for example, if `glClearBufferiv` is
called for a fixed- or floating-point buffer, or if `glClearBufferfv` is called for a signed or
unsigned integer buffer). This is not an error.
---
### Errors
`GL_INVALID_OPERATION` is generated by `glClearNamedFramebuffer*` if `framebuffer` is not
zero or the name of an existing framebuffer object.

`GL_INVALID_ENUM` is generated by `glClearBufferiv` and `glClearNamedFramebufferiv` `buffer`
is not `GL_COLOR` or `GL_STENCIL`.

`GL_INVALID_ENUM` is generated by `glClearBufferuiv` and `glClearNamedFramebufferuiv` `buffer`
is not `GL_COLOR`.

`GL_INVALID_ENUM` is generated by `glClearBufferfv` and `glClearNamedFramebufferfv` `buffer`
is not `GL_COLOR` or `GL_DEPTH`.

`GL_INVALID_ENUM` is generated by `glClearBufferfi` and `glClearNamedFramebufferfi` `buffer`
is not `GL_DEPTH_STENCIL`.

`GL_INVALID_VALUE` is generated if `buffer` is `GL_COLOR` `drawbuffer` is negative, or
greater than the value of `GL_MAX_DRAW_BUFFERS` minus one.

`GL_INVALID_VALUE` is generated if `buffer` is `GL_DEPTH`, `GL_STENCIL` or
`GL_DEPTH_STENCIL` and `drawbuffer` is not zero.
---
### Version Support
`glClearBufferfi` `glClearBufferfv` `glClearBufferiv` `glClearBufferuiv`
`glClearNamedFramebufferfi` `glClearNamedFramebufferfv` `glClearNamedFramebufferiv`
`glClearNamedFramebufferuiv`
---
### See Also
glClearColor, glClearDepth, glClearStencil, glClear
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Invalidate a region of a texture image
---
### Parameters
`texture` The name of a texture object a subregion of which to invalidate.
`level` The level of detail of the texture object within which the region resides.
`xoffset` The X offset of the region to be invalidated.
`yoffset` The Y offset of the region to be invalidated.
`zoffset` The Z offset of the region to be invalidated.
`width` The width of the region to be invalidated.
`height` The height of the region to be invalidated.
`depth` The depth of the region to be invalidated.
---
### Description
`glInvalidateTexSubImage` invalidates all or part of a texture image. `texture` and `level`
indicated which texture image is being invalidated. After this command, data in that subregion have
undefined values. `xoffset`, `yoffset`, `zoffset`, `width`, `height`, and `depth` are
interpreted as they are in glTexSubImage3D. For texture targets that don't have certain
dimensions, this command treats those dimensions as having a size of 1. For example, to invalidate a
portion of a two- dimensional texture, the application would use `zoffset` equal to zero and
`depth` equal to one. Cube map textures are treated as an array of six slices in the z-dimension,
where a value of `zoffset` is interpreted as specifying face `GL_TEXTURE_CUBE_MAP_POSITIVE_X` +
`zoffset`.

`level` must be greater than or equal to zero and be less than the base 2 logarithm of the
maximum texture width, height, or depth. `xoffset`, `yoffset` and `zoffset` must be greater
than or equal to zero and be less than the width, height or depth of the image, respectively.

Furthermore, `xoffset` + `width`, `yoffset` + `height`, and `zoffset` + `depth` must be
less than or equal to the width, height or depth of the image, respectively.

For textures of targets `GL_TEXTURE_RECTANGLE`, `GL_TEXTURE_BUFFER`,
`GL_TEXTURE_2D_MULTISAMPLE`, or `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`, level must be zero.
---
### Errors
`GL_INVALID_VALUE` is generated if `xoffset`, `yoffset` or `zoffset` is less than zero, or
if any of them is greater than the size of the image in the corresponding dimension.

`GL_INVALID_VALUE` is generated if `level` is less than zero or if it is greater or equal to
the base 2 logarithm of the maximum texture width, height, or depth.

`GL_INVALID_VALUE` is generated if the target of `texture` is any of `GL_TEXTURE_RECTANGLE`,
`GL_TEXTURE_BUFFER`, `GL_TEXTURE_2D_MULTISAMPLE`, or `GL_TEXTURE_2D_MULTISAMPLE_ARRAY` and
`level` is not zero.

`GL_INVALID_VALUE` is generated if `texture` is not the name of an existing texture object.
---
### Associated Gets
glGet with argument `GL_MAX_TEXTURE_SIZE`
---
### Version Support
`glInvalidateTexSubImage`
---
### See Also
glInvalidateTexImage,, glInvalidateBufferSubData, glInvalidateBufferData,
glInvalidateFramebuffer, glInvalidateSubFramebuffer.
---
### Copyright
Copyright 2013-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Determine if a name corresponds to a buffer object
---
### Parameters
`buffer` Specifies a value that may be the name of a buffer object.
---
### Description
`glIsBuffer` returns `GL_TRUE` if `buffer` is currently the name of a buffer object. If
`buffer` is zero, or is a non-zero value that is not currently the name of a buffer object, or if
an error occurs, `glIsBuffer` returns `GL_FALSE`.

A name returned by glGenBuffers, but not yet associated with a buffer object by calling
glBindBuffer, is not the name of a buffer object.
---
### Version Support
`glIsBuffer`
---
### See Also
glBindBuffer, glDeleteBuffers, glGenBuffers, glGet
---
### Copyright
Copyright 2005 Addison-Wesley. Copyright 2010-2014 Khronos Group. This material may be
distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8
June 1999. https://opencontent.org/openpub/.
]],
  [[Test whether a capability is enabled
---
### Parameters
`cap` Specifies a symbolic constant indicating a GL capability.
`index` Specifies the index of the capability.
---
### Description
`glIsEnabled` returns `GL_TRUE` if `cap` is an enabled capability and returns `GL_FALSE`
otherwise. Boolean states that are indexed may be tested with `glIsEnabledi`. For `glIsEnabledi`,
`index` specifies the index of the capability to test. `index` must be between zero and the
count of indexed capabilities for `cap`. Initially all capabilities except `GL_DITHER` are
disabled; `GL_DITHER` is initially enabled.

The following capabilities are accepted for `cap` :

Constant See `GL_BLEND` glBlendFunc, glLogicOp `GL_CLIP_DISTANCE` i
glEnable `GL_COLOR_LOGIC_OP` glLogicOp `GL_CULL_FACE` glCullFace `GL_DEPTH_CLAMP`
glEnable `GL_DEBUG_OUTPUT` glEnable `GL_DEBUG_OUTPUT_SYNCHRONOUS` glEnable `GL_DEPTH_TEST`
glDepthFunc, glDepthRange `GL_DITHER` glEnable `GL_FRAMEBUFFER_SRGB` glEnable
`GL_LINE_SMOOTH` glLineWidth `GL_MULTISAMPLE` glSampleCoverage `GL_POLYGON_SMOOTH`
glPolygonMode `GL_POLYGON_OFFSET_FILL` glPolygonOffset `GL_POLYGON_OFFSET_LINE`
glPolygonOffset `GL_POLYGON_OFFSET_POINT` glPolygonOffset `GL_PROGRAM_POINT_SIZE` glEnable
`GL_PRIMITIVE_RESTART` glEnable, glPrimitiveRestartIndex `GL_PRIMITIVE_RESTART_FIXED_INDEX`
glEnable, `GL_SAMPLE_ALPHA_TO_COVERAGE` glSampleCoverage `GL_SAMPLE_ALPHA_TO_ONE`
glSampleCoverage `GL_SAMPLE_COVERAGE` glSampleCoverage `GL_SAMPLE_MASK` glEnable
`GL_SCISSOR_TEST` glScissor `GL_STENCIL_TEST` glStencilFunc, glStencilOp
`GL_TEXTURE_CUBE_MAP_SEAMLESS` glEnable
---
### Notes
If an error is generated, `glIsEnabled` and `glIsEnabledi` return `GL_FALSE`.

`GL_PRIMITIVE_RESTART_FIXED_INDEX` are available only if the GL version is 4.3 or greater.

`GL_DEBUG_OUTPUT` and `GL_DEBUG_OUTPUT_SYNCHRONOUS` are available only if the GL version is 4.3
or greater.
---
### Errors
`GL_INVALID_ENUM` is generated if `cap` is not an accepted value.

`GL_INVALID_VALUE` is generated by `glIsEnabledi` if `index` is outside the valid range for
the indexed state `cap`.
---
### Version Support
`glIsEnabled` `glIsEnabledi`
---
### See Also
glEnable, `glDisable`, glGet
---
### Copyright
Copyright 1991-2006 Silicon Graphics, Inc. Copyright 2010-2014 Khronos Group. This document
is licensed under the SGI Free Software B License. For details, see
https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.
]],
  [[Determine if a name corresponds to a framebuffer object
---
### Parameters
`framebuffer` Specifies a value that may be the name of a framebuffer object.
---
### Description
`glIsFramebuffer` returns `GL_TRUE` if `framebuffer` is currently the name of a framebuffer
object. If `framebuffer` is zero, or if `framebuffer` is not the name of a framebuffer object,
or if an error occurs, `glIsFramebuffer` returns `GL_FALSE`. If `framebuffer` is a name
returned by glGenFramebuffers, by that has not yet been bound through a call to
glBindFramebuffer, then the name is not a framebuffer object and `glIsFramebuffer` returns
`GL_FALSE`.
---
### Version Support
`glIsFramebuffer`
---
### See Also
glGenFramebuffers, glBindFramebuffer, glDeleteFramebuffers
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Determines if a name corresponds to a program object
---
### Parameters
`program` Specifies a potential program object.
---
### Description
`glIsProgram` returns `GL_TRUE` if `program` is the name of a program object previously
created with glCreateProgram and not yet deleted with glDeleteProgram. If `program` is zero
or a non-zero value that is not the name of a program object, or if an error occurs, `glIsProgram`
returns `GL_FALSE`.
---
### Notes
No error is generated if `program` is not a valid program object name.

A program object marked for deletion with glDeleteProgram but still in use as part of current
rendering state is still considered a program object and `glIsProgram` will return `GL_TRUE`.
---
### Associated Gets
glGet with the argument `GL_CURRENT_PROGRAM`

glGetActiveAttrib with arguments `program` and the index of an active attribute variable

glGetActiveUniform with arguments `program` and the index of an active uniform variable

glGetAttachedShaders with argument `program`

glGetAttribLocation with arguments `program` and the name of an attribute variable

glGetProgram with arguments `program` and the parameter to be queried

glGetProgramInfoLog with argument `program`

glGetUniform with arguments `program` and the location of a uniform variable

glGetUniformLocation with arguments `program` and the name of a uniform variable
---
### Version Support
`glIsProgram`
---
### See Also
glAttachShader, glBindAttribLocation, glCreateProgram, glDeleteProgram,
glDetachShader, glLinkProgram, glUniform, glUseProgram, glValidateProgram
---
### Copyright
Copyright 2003-2005 3Dlabs Inc. Ltd. Copyright 2010-2014 Khronos Group. This material may be
distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8
June 1999. https://opencontent.org/openpub/.
]],
  [[Determine if a name corresponds to a program pipeline object
---
### Parameters
`pipeline` Specifies a value that may be the name of a program pipeline object.
---
### Description
`glIsProgramPipeline` returns `GL_TRUE` if `pipeline` is currently the name of a program
pipeline object. If `pipeline` is zero, or if `pipeline` is not the name of a program pipeline
object, or if an error occurs, `glIsProgramPipeline` returns `GL_FALSE`. If `pipeline` is a
name returned by glGenProgramPipelines, but that has not yet been bound through a call to
glBindProgramPipeline, then the name is not a program pipeline object and `glIsProgramPipeline`
returns `GL_FALSE`.
---
### Version Support
`glIsProgramPipeline`
---
### See Also
glGenProgramPipelines, glBindProgramPipeline, glDeleteProgramPipelines
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Determine if a name corresponds to a query object
---
### Parameters
`id` Specifies a value that may be the name of a query object.
---
### Description
`glIsQuery` returns `GL_TRUE` if `id` is currently the name of a query object. If `id` is
zero, or is a non-zero value that is not currently the name of a query object, or if an error
occurs, `glIsQuery` returns `GL_FALSE`.

A name returned by glGenQueries, but not yet associated with a query object by calling
glBeginQuery, is not the name of a query object.
---
### Version Support
`glIsQuery`
---
### See Also
glBeginQuery, glDeleteQueries, `glEndQuery`, glGenQueries
---
### Copyright
Copyright 2005 Addison-Wesley. Copyright 2010-2014 Khronos Group. This material may be
distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8
June 1999. https://opencontent.org/openpub/.
]],
  [[Fill a buffer object's data store with a fixed value
---
### Parameters
`target` Specifies the target to which the buffer object is bound for `glClearBufferData`,
which must be one of the buffer binding targets in the following table:

`buffer` Specifies the name of the buffer object for `glClearNamedBufferData`.

`internalformat` The internal format with which the data will be stored in the buffer object.
`format` The format of the data in memory addressed by `data`.

`type` The type of the data in memory addressed by `data`.

`data` The address of a memory location storing the data to be replicated into the buffer's
data store.
---
### Description
`glClearBufferData` and `glClearNamedBufferData` fill the entirety of a buffer object's data
store with data from client memory.

Data, initially supplied in a format specified by `format` in data type `type` is read from
the memory address given by `data` and converted into the internal representation given by
`internalformat`, which must be one of the following sized internal formats:

This converted data is then replicated throughout the buffer object's data store. If `data` is
NULL, then the buffer's data store is filled with zeros.
---
### Errors
`GL_INVALID_ENUM` is generated by `glClearBufferData` if `target` is not one of the generic
buffer binding targets.

`GL_INVALID_VALUE` is generated by `glClearBufferData` if no buffer is bound `target`.

`GL_INVALID_OPERATION` is generated by `glClearNamedBufferData` if `buffer` is not the name
of an existing buffer object.

`GL_INVALID_ENUM` is generated if `internalformat` is not one of the valid sized internal
formats listed in the table above.

`GL_INVALID_OPERATION` is generated if any part of the specified range of the buffer object is
mapped with glMapBufferRange or glMapBuffer, unless it was mapped with the
`GL_MAP_PERSISTENT_BIT` bit set in the `glMapBufferRange` `access` flags.

`GL_INVALID_VALUE` is generated if `format` is not a valid format, or `type` is not a valid
type.
---
### Version Support
`glClearBufferData` `glClearNamedBufferData`
---
### See Also
glClearBufferSubData.
---
### Copyright
Copyright 2011-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Determine if a name corresponds to a renderbuffer object
---
### Parameters
`renderbuffer` Specifies a value that may be the name of a renderbuffer object.
---
### Description
`glIsRenderbuffer` returns `GL_TRUE` if `renderbuffer` is currently the name of a
renderbuffer object. If `renderbuffer` is zero, or if `renderbuffer` is not the name of a
renderbuffer object, or if an error occurs, `glIsRenderbuffer` returns `GL_FALSE`. If
`renderbuffer` is a name returned by glGenRenderbuffers, by that has not yet been bound through
a call to glBindRenderbuffer or glFramebufferRenderbuffer, then the name is not a renderbuffer
object and `glIsRenderbuffer` returns `GL_FALSE`.
---
### Version Support
`glIsRenderbuffer`
---
### See Also
glGenRenderbuffers, glBindRenderbuffer, glFramebufferRenderbuffer, glDeleteRenderbuffers

---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Fill all or part of buffer object's data store with a fixed value
---
### Parameters
`target` Specifies the target to which the buffer object is bound for `glClearBufferSubData`,
which must be one of the buffer binding targets in the following table:

`buffer` Specifies the name of the buffer object for `glClearNamedBufferSubData`.

`internalformat` The internal format with which the data will be stored in the buffer object.
`offset` The offset in basic machine units into the buffer object's data store at which to
start filling.
`size` The size in basic machine units of the range of the data store to fill.
`format` The format of the data in memory addressed by `data`.

`type` The type of the data in memory addressed by `data`.

`data` The address of a memory location storing the data to be replicated into the buffer's
data store.
---
### Description
`glClearBufferSubData` and `glClearNamedBufferSubData` fill a specified region of a buffer
object's data store with data from client memory.

`offset` and `size` specify the extent of the region within the data store of the buffer object
to fill with data. Data, initially supplied in a format specified by `format` in data type `type`
is read from the memory address given by `data` and converted into the internal representation
given by `internalformat`, which must be one of the following sized internal formats:

This converted data is then replicated throughout the specified region of the buffer object's
data store. If `data` is NULL, then the subrange of the buffer's data store is filled with zeros.

---
### Errors
`GL_INVALID_ENUM` is generated by `glClearBufferSubData` if `target` is not one of the
generic buffer binding targets.

`GL_INVALID_VALUE` is generated by `glClearBufferSubData` if no buffer is bound to `target`.

`GL_INVALID_OPERATION` is generated by `glClearNamedBufferSubData` if `buffer` is not the
name of an existing buffer object.

`GL_INVALID_ENUM` is generated if `internalformat` is not one of the valid sized internal
formats listed in the table above.

`GL_INVALID_VALUE` is generated if `offset` or `range` are not multiples of the number of
basic machine units per-element for the internal format specified by `internalformat`. This value
may be computed by multiplying the number of components for `internalformat` from the table by the
size of the base type from the table.

`GL_INVALID_VALUE` is generated if `offset` or `size` is negative, or if $offset + size$ is
greater than the value of `GL_BUFFER_SIZE` for the buffer object.

`GL_INVALID_OPERATION` is generated if any part of the specified range of the buffer object is
mapped with glMapBufferRange or glMapBuffer, unless it was mapped with the
`GL_MAP_PERSISTENT_BIT` bit set in the `glMapBufferRange` `access` flags.

`GL_INVALID_VALUE` is generated if `format` is not a valid format, or `type` is not a valid
type.
---
### Version Support
`glClearBufferSubData` `glClearNamedBufferSubData`
---
### See Also
glClearBufferData.
---
### Copyright
Copyright 2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Specify clear values for the color buffers
---
### Parameters
`red` `green` `blue` `alpha` Specify the red, green, blue, and alpha values used when the
color buffers are cleared. The initial values are all 0.
---
### Description
`glClearColor` specifies the red, green, blue, and alpha values used by glClear to clear the
color buffers. Values specified by `glClearColor` are clamped to the range 0 1.
---
### Notes
The type of the `red`, `green`, `blue`, and `alpha` parameters was changed from GLclampf
to GLfloat. This change is transparent to user code and is described in detail on the removedTypes
page.
---
### Associated Gets
glGet with argument `GL_COLOR_CLEAR_VALUE`
---
### Version Support
`glClearColor`
---
### See Also
glClear, removedTypes
---
### Copyright
Copyright 1991-2006 Silicon Graphics, Inc. Copyright 2010-2014 Khronos Group. This document
is licensed under the SGI Free Software B License. For details, see
https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.
]],
  [[Specify the clear value for the depth buffer
---
### Parameters
`depth` Specifies the depth value used when the depth buffer is cleared. The initial value is
1.
---
### Description
`glClearDepth` specifies the depth value used by glClear to clear the depth buffer. Values
specified by `glClearDepth` are clamped to the range 0 1.
---
### Notes
The type of the `depth` parameter was changed from GLclampf to GLfloat for `glClearDepthf` and
from GLclampd to GLdouble for `glClearDepth`. This change is transparent to user code and is
described in detail on the removedTypes page.
---
### Associated Gets
glGet with argument `GL_DEPTH_CLEAR_VALUE`
---
### Version Support
`glClearDepth` `glClearDepthf`
---
### See Also
glClear, removedTypes
---
### Copyright
Copyright 1991-2006 Silicon Graphics, Inc. Copyright 2010-2014 Khronos Group. This document
is licensed under the SGI Free Software B License. For details, see
https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.
]],
  [[Specify the clear value for the stencil buffer
---
### Parameters
`s` Specifies the index used when the stencil buffer is cleared. The initial value is 0.
---
### Description
`glClearStencil` specifies the index used by glClear to clear the stencil buffer. `s` is
masked with 2 m - 1, where m is the number of bits in the stencil buffer.
---
### Associated Gets
glGet with argument `GL_STENCIL_CLEAR_VALUE`

glGet with argument `GL_STENCIL_BITS`
---
### Version Support
`glClearStencil`
---
### See Also
glClear, glStencilFunc, glStencilFuncSeparate, glStencilMask, glStencilMaskSeparate,
glStencilOp, glStencilOpSeparate
---
### Copyright
Copyright 1991-2006 Silicon Graphics, Inc. Copyright 2010-2014 Khronos Group. This document
is licensed under the SGI Free Software B License. For details, see
https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.
]],
  [[Fills all a texture image with a constant value
---
### Parameters
`texture` The name of an existing texture object containing the image to be cleared.
`level` The level of `texture` containing the region to be cleared.

`format` The format of the data whose address in memory is given by `data`.

`type` The type of the data whose address in memory is given by `data`.

`data` The address in memory of the data to be used to clear the specified region.
---
### Description
`glClearTexImage` fills all an image contained in a texture with an application supplied value.
`texture` must be the name of an existing texture. Further, `texture` may not be the name of a
buffer texture, nor may its internal format be compressed.

`format` and `type` specify the format and type of the source data and are interpreted as they
are for glTexImage3D. Textures with a base internal format of `GL_DEPTH_COMPONENT`,
`GL_STENCIL_INDEX`, or `GL_DEPTH_STENCIL` require depth component, stencil, or depth-stencil
component data respectively. Textures with other base internal formats require RGBA formats.

Textures with integer internal formats require integer data.

`data` is a pointer to an array of between one and four components of texel data that will be
used as the source for the constant fill value. The elements of data are converted by the GL into
the internal format of the texture image (that was specified when the level was defined by any of
the `glTexImage*`, `glTexStorage*` or `glCopyTexImage*` commands), and then used to fill the
specified range of the destination texture level. If `data` is `NULL`, then the pointer is
ignored and the sub-range of the texture image is filled with zeros. If texture is a multisample
texture, all the samples in a texel are cleared to the value specified by data.
---
### Notes
`glClearTexImage` is available only if the GL version is 4.4 or greater.
---
### Errors
`GL_INVALID_OPERATION` is generated if `texture` is zero or not the name of an existing texture
object.

`GL_INVALID_OPERATION` is generated if `texture` is a buffer texture.

`GL_INVALID_OPERATION` is generated if `texture` has a compressed internal format.

`GL_INVALID_OPERATION` is generated if the base internal format is `GL_DEPTH_COMPONENT` and
`format` is not `GL_DEPTH_COMPONENT`.

`GL_INVALID_OPERATION` is generated if the base internal format is `GL_DEPTH_STENCIL` and
`format` is not `GL_DEPTH_STENCIL`.

`GL_INVALID_OPERATION` is generated if the base internal format is `GL_STENCIL_INDEX` and
`format` is not `GL_STENCIL_INDEX`.

`GL_INVALID_OPERATION` is generated if the base internal format is `GL_RGBA` and `format` is
`GL_DEPTH_COMPONENT`, `GL_STENCIL_INDEX`, or `GL_DEPTH_STENCIL`.

`GL_INVALID_OPERATION` is generated if the internal format is integer and `format` does not
specify integer data.

`GL_INVALID_OPERATION` is generated if the internal format is not integer and `format`
specifies integer data.

`GL_INVALID_OPERATION` is generated if the image array identified by `level` has not previously
been defined by a call to `glTexImage*` or `glTexStorage*`.
---
### Associated Gets
glGetTexImage, glGetInternalformat
---
### Version Support
`glClearTexImage`
---
### See Also
glClearTexSubImage, glTexStorage1D, glTexStorage2D, glTexStorage3D, glTexImage1D,
glTexImage2D, glTexImage3D
---
### Copyright
Copyright 2013-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Fills all or part of a texture image with a constant value
---
### Parameters
`texture` The name of an existing texture object containing the image to be cleared.
`level` The level of `texture` containing the region to be cleared.

`xoffset` The coordinate of the left edge of the region to be cleared.
`yoffset` The coordinate of the lower edge of the region to be cleared.
`zoffset` The coordinate of the front of the region to be cleared.
`width` The width of the region to be cleared.
`height` The height of the region to be cleared.
`depth` The depth of the region to be cleared.
`format` The format of the data whose address in memory is given by `data`.

`type` The type of the data whose address in memory is given by `data`.

`data` The address in memory of the data to be used to clear the specified region.
---
### Description
`glClearTexSubImage` fills all or part of an image contained in a texture with an application
supplied value. `texture` must be the name of an existing texture. Further, `texture` may not be
the name of a buffer texture, nor may its internal format be compressed.

Arguments `xoffset`, `yoffset`, and `zoffset` specify the lower left texel coordinates of a
width-wide by height-high by depth-deep rectangular subregion of the texel array.

For one-dimensional array textures, `yoffset` is interpreted as the first layer to be cleared
and `height` is the number of layers to clear. For two-dimensional array textures, `zoffset` is
interpreted as the first layer to be cleared and `depth` is the number of layers to clear. Cube
map textures are treated as an array of six slices in the z-dimension, where the value of `zoffset`
is interpreted as specifying the cube map face for the corresponding layer and `depth` is the
number of faces to clear. For cube map array textures, `zoffset` is the first layer-face to clear,
and `depth` is the number of layer-faces to clear. Each layer-face is translated into an array
layer and a cube map face as described in the OpenGL Specification.

Negative values of `xoffset`, `yoffset`, and `zoffset` correspond to the coordinates of
border texels. Taking ws, hs, ds, wb, hb, and db to be the specified
`width`, `height`, `depth`, and the border width, border height, and border depth of the texel
array and taking x, y, z, w, h, and d to be the `xoffset`, `yoffset`,
`zoffset`, `width`, `height`, and `depth` argument values, any of the following relationships
generates a `GL_INVALID_OPERATION` error: x < w b x + w > w s - w b y < - h b
y + h > h s - h b z < - d b z + d > d s - d b

For texture types that do not have certain dimensions, this command treats those dimensions as
having a size of 1. For example, to clear a portion of a two-dimensional texture, use `zoffset`
equal to zero and `depth` equal to one.

`format` and `type` specify the format and type of the source data and are interpreted as they
are for glTexImage3D. Textures with a base internal format of `GL_DEPTH_COMPONENT`,
`GL_STENCIL_INDEX`, or `GL_DEPTH_STENCIL` require depth component, stencil, or depth-stencil
component data respectively. Textures with other base internal formats require RGBA formats.

Textures with integer internal formats require integer data.

`data` is a pointer to an array of between one and four components of texel data that will be
used as the source for the constant fill value. The elements of data are converted by the GL into
the internal format of the texture image (that was specified when the level was defined by any of
the `glTexImage*`, `glTexStorage*` or `glCopyTexImage*` commands), and then used to fill the
specified range of the destination texture level. If `data` is `NULL`, then the pointer is
ignored and the sub-range of the texture image is filled with zeros. If texture is a multisample
texture, all the samples in a texel are cleared to the value specified by data.
---
### Notes
`glClearTexSubImage` is available only if the GL version is 4.4 or greater.
---
### Errors
`GL_INVALID_OPERATION` is generated if `texture` is zero or not the name of an existing texture
object.

`GL_INVALID_OPERATION` is generated if `texture` is a buffer texture.

`GL_INVALID_OPERATION` is generated if `texture` has a compressed internal format.

`GL_INVALID_OPERATION` is generated if the base internal format is `GL_DEPTH_COMPONENT` and
`format` is not `GL_DEPTH_COMPONENT`.

`GL_INVALID_OPERATION` is generated if the base internal format is `GL_DEPTH_STENCIL` and
`format` is not `GL_DEPTH_STENCIL`.

`GL_INVALID_OPERATION` is generated if the base internal format is `GL_STENCIL_INDEX` and
`format` is not `GL_STENCIL_INDEX`.

`GL_INVALID_OPERATION` is generated if the base internal format is `GL_RGBA` and `format` is
`GL_DEPTH_COMPONENT`, `GL_STENCIL_INDEX`, or `GL_DEPTH_STENCIL`.

`GL_INVALID_OPERATION` is generated if the internal format is integer and `format` does not
specify integer data.

`GL_INVALID_OPERATION` is generated if the internal format is not integer and `format`
specifies integer data.

`GL_INVALID_OPERATION` error is generated if the `xoffset`, `yoffset`, `zoffset`, `width`,
`height`, and `depth` parameters (or combinations thereof) specify a region that falls outside
the defined texture image array (including border, if any).
---
### Associated Gets
glGetTexImage, glGetInternalformat
---
### Version Support
`glClearTexSubImage`
---
### See Also
glClearTexImage, glTexStorage1D, glTexStorage2D, glTexStorage3D, glTexImage1D,
glTexImage2D, glTexImage3D
---
### Copyright
Copyright 2013-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Block and wait for a sync object to become signaled
---
### Parameters
`sync` The sync object whose status to wait on.
`flags` A bitfield controlling the command flushing behavior. `flags` may be
`GL_SYNC_FLUSH_COMMANDS_BIT`.

`timeout` The timeout, specified in nanoseconds, for which the implementation should wait for
`sync` to become signaled.

---
### Description
`glClientWaitSync` causes the client to block and wait for the sync object specified by `sync`
to become signaled. If `sync` is signaled when `glClientWaitSync` is called, `glClientWaitSync`
returns immediately, otherwise it will block and wait for up to `timeout` nanoseconds for `sync`
to become signaled.

The return value is one of four status values: `GL_ALREADY_SIGNALED` indicates that `sync`
was signaled at the time that `glClientWaitSync` was called.

`GL_TIMEOUT_EXPIRED` indicates that at least `timeout` nanoseconds passed and `sync` did not
become signaled.

`GL_CONDITION_SATISFIED` indicates that `sync` was signaled before the timeout expired.

`GL_WAIT_FAILED` indicates that an error occurred. Additionally, an OpenGL error will be
generated.

---
### Notes
`glClientWaitSync` is available only if the GL version is 3.2 or greater.
---
### Errors
`GL_INVALID_VALUE` is generated if `sync` is not the name of an existing sync object.

`GL_INVALID_VALUE` is generated if `flags` contains any unsupported flag.
---
### Version Support
`glClientWaitSync`
---
### See Also
glFenceSync, glIsSync glWaitSync
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Control clip coordinate to window coordinate behavior
---
### Parameters
`origin` Specifies the clip control origin. Must be one of `GL_LOWER_LEFT` or
`GL_UPPER_LEFT`.

`depth` Specifies the clip control depth mode. Must be one of `GL_NEGATIVE_ONE_TO_ONE` or
`GL_ZERO_TO_ONE`.

---
### Description
`glClipControl` controls the clipping volume behavior and the clip coordinate to window
coordinate transformation behavior.

The view volume is defined by $$z_{min} \\\\leq z_c \\\\leq w_c$$ where $z_{min} = -w_c$ when `depth`
is `GL_NEGATIVE_ONE_TO_ONE`, and $z_{min} = 0$ when `depth` is `GL_ZERO_TO_ONE`.

The normalized device coordinate $y_d$ is given by $$y_d = { { f \\\\times y_c } \\\\over w_c }$$ where
$f = 1$ when `origin` is `GL_LOWER_LEFT`, and $f = -1$ when `origin` is `GL_UPPER_LEFT`.

The window coordinate $z_w$ is given by $$z_w = s \\\\times z_d + b$$ where $s = { { f - n } \\\\over 2
}$ and $b = { {n + f} \\\\over 2 }$ when `depth` is `GL_NEGATIVE_ONE_TO_ONE`, and $s = f - n$ and
$b = n$ when `depth` is `GL_ZERO_TO_ONE`. $n$ and $f$ are the near and far depth range values
set with glDepthRange.

Finally, the polygon area computation defined by gl_FrontFacing to determine if a polygon is
front- or back-facing has its sign negated when `origin` is `GL_UPPER_LEFT`.
---
### Notes
The default GL clip volume definition is for a `origin` of `GL_LOWER_LEFT` and a `depth` of
`GL_NEGATIVE_ONE_TO_ONE`.

An `origin` of `GL_UPPER_LEFT` and a `depth` of `GL_ZERO_TO_ONE` corresponds to Direct3D's
clip volume definition.

An `origin` of `GL_UPPER_LEFT` and a `depth` of `GL_NEGATIVE_ONE_TO_ONE` corresponds to
the upper-left origin of the window coordinate system of Microsoft Windows and the X Window System.

There is extensive discussion of the uses and further consequences of the different clip volume
settings in the GL_ARB_clip_control extension specification in the OpenGL Registry at URL
http://www.opengl.org/registry/.
---
### Errors
An `GL_INVALID_ENUM` error is generated if `origin` is not `GL_LOWER_LEFT` or
`GL_UPPER_LEFT`.

An `GL_INVALID_ENUM` error is generated if `depth` is not `GL_NEGATIVE_ONE_TO_ONE` or
`GL_ZERO_TO_ONE`.
---
### Version Support
`glClipControl`
---
### See Also
gl_ClipDistance, gl_CullDistance, gl_FrontFacing, glDepthRange.
---
### Copyright
Copyright 2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Enable and disable writing of frame buffer color components
---
### Parameters
`buf` For `glColorMaski`, specifies the index of the draw buffer whose color mask to set.

`red` `green` `blue` `alpha` Specify whether red, green, blue, and alpha are to be written
into the frame buffer. The initial values are all `GL_TRUE`, indicating that the color components
are written.

---
### Description
`glColorMask` and `glColorMaski` specify whether the individual color components in the frame
buffer can or cannot be written. `glColorMaski` sets the mask for a specific draw buffer, whereas
`glColorMask` sets the mask for all draw buffers. If `red` is `GL_FALSE`, for example, no
change is made to the red component of any pixel in any of the color buffers, regardless of the
drawing operation attempted.

Changes to individual bits of components cannot be controlled. Rather, changes are either enabled
or disabled for entire color components.
---
### Associated Gets
glGet with argument `GL_COLOR_WRITEMASK`
---
### Version Support
`glColorMask` `glColorMaski`
---
### See Also
glClear, glDepthMask, glStencilMask
---
### Copyright
Copyright 1991-2006 Silicon Graphics, Inc. Copyright 2010-2014 Khronos Group. This document
is licensed under the SGI Free Software B License. For details, see
https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.
]],
  [[Compiles a shader object
---
### Parameters
`shader` Specifies the shader object to be compiled.
---
### Description
`glCompileShader` compiles the source code strings that have been stored in the shader object
specified by `shader`.

The compilation status will be stored as part of the shader object's state. This value will be set
to `GL_TRUE` if the shader was compiled without errors and is ready for use, and `GL_FALSE`
otherwise. It can be queried by calling glGetShader with arguments `shader` and
`GL_COMPILE_STATUS`.

Compilation of a shader can fail for a number of reasons as specified by the OpenGL Shading
Language Specification. Whether or not the compilation was successful, information about the
compilation can be obtained from the shader object's information log by calling glGetShaderInfoLog.
---
### Errors
`GL_INVALID_VALUE` is generated if `shader` is not a value generated by OpenGL.

`GL_INVALID_OPERATION` is generated if `shader` is not a shader object.
---
### Associated Gets
glGetShaderInfoLog with argument `shader`

glGetShader with arguments `shader` and `GL_COMPILE_STATUS`

glIsShader
---
### Version Support
`glCompileShader`
---
### See Also
glCreateShader, glLinkProgram, glShaderSource
---
### Copyright
Copyright 2003-2005 3Dlabs Inc. Ltd. Copyright 2010-2014 Khronos Group. This material may be
distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8
June 1999. https://opencontent.org/openpub/.
]],
  [[Specify a one-dimensional texture image in a compressed format
---
### Parameters
`target` Specifies the target texture. Must be `GL_TEXTURE_1D` or `GL_PROXY_TEXTURE_1D`.

`level` Specifies the level-of-detail number. Level 0 is the base image level. Level n is the
n th mipmap reduction image.

`internalformat` Specifies the format of the compressed image data stored at address `data`.


`width` Specifies the width of the texture image. All implementations support texture images
that are at least 64 texels wide. The height of the 1D texture image is 1.
`border` This value must be 0.
`imageSize` Specifies the number of unsigned bytes of image data starting at the address
specified by `data`.

`data` Specifies a pointer to the compressed image data in memory.
]],
  [[Specify a two-dimensional texture image in a compressed format
---
### Parameters
`target` Specifies the target texture. Must be `GL_TEXTURE_2D`, `GL_PROXY_TEXTURE_2D`,
`GL_TEXTURE_1D_ARRAY`, `GL_PROXY_TEXTURE_1D_ARRAY`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`,
`GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`,
`GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`,
`GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`, or `GL_PROXY_TEXTURE_CUBE_MAP`.

`level` Specifies the level-of-detail number. Level 0 is the base image level. Level n is the
n th mipmap reduction image.

`internalformat` Specifies the format of the compressed image data stored at address `data`.


`width` Specifies the width of the texture image. All implementations support 2D texture and
cube map texture images that are at least 16384 texels wide.
`height` Specifies the height of the texture image. All implementations support 2D texture and
cube map texture images that are at least 16384 texels high.
`border` This value must be 0.
`imageSize` Specifies the number of unsigned bytes of image data starting at the address
specified by `data`.

`data` Specifies a pointer to the compressed image data in memory.
]],
  [[Specify a three-dimensional texture image in a compressed format
---
### Parameters
`target` Specifies the target texture. Must be `GL_TEXTURE_3D`, `GL_PROXY_TEXTURE_3D`,
`GL_TEXTURE_2D_ARRAY` or `GL_PROXY_TEXTURE_2D_ARRAY`.

`level` Specifies the level-of-detail number. Level 0 is the base image level. Level n is the
n th mipmap reduction image.

`internalformat` Specifies the format of the compressed image data stored at address `data`.


`width` Specifies the width of the texture image. All implementations support 3D texture images
that are at least 16 texels wide.
`height` Specifies the height of the texture image. All implementations support 3D texture
images that are at least 16 texels high.
`depth` Specifies the depth of the texture image. All implementations support 3D texture images
that are at least 16 texels deep.
`border` This value must be 0.
`imageSize` Specifies the number of unsigned bytes of image data starting at the address
specified by `data`.

`data` Specifies a pointer to the compressed image data in memory.
]],
  [[Specify a one-dimensional texture subimage in a compressed format
---
### Parameters
`target` Specifies the target, to which the texture is bound, for `glCompressedTexSubImage1D`
function. Must be `GL_TEXTURE_1D`.

`texture` Specifies the texture object name for `glCompressedTextureSubImage1D` function.

`level` Specifies the level-of-detail number. Level 0 is the base image level. Level n is the
n th mipmap reduction image.

`xoffset` Specifies a texel offset in the x direction within the texture array.
`width` Specifies the width of the texture subimage.
`format` Specifies the format of the compressed image data stored at address `data`.

`imageSize` Specifies the number of unsigned bytes of image data starting at the address
specified by `data`.

`data` Specifies a pointer to the compressed image data in memory.
---
### Description
Texturing allows elements of an image array to be read by shaders. `glCompressedTexSubImage1D`
and `glCompressedTextureSubImage1D` redefine a contiguous subregion of an existing one-dimensional
texture image. The texels referenced by `data` replace the portion of the existing texture array
with x indices `xoffset` and xoffset + width - 1, inclusive. This region may not include any
texels outside the range of the texture array as it was originally specified. It is not an error to
specify a subtexture with width of 0, but such a specification has no effect.

`internalformat` must be a known compressed image format (such as `GL_RGTC` ) or an
extension-specified compressed-texture format. The `format` of the compressed texture image is
selected by the GL implementation that compressed it (see glTexImage1D ), and should be queried at
the time the texture was compressed with glGetTexLevelParameter.

If a non-zero named buffer object is bound to the `GL_PIXEL_UNPACK_BUFFER` target (see
glBindBuffer ) while a texture image is specified, `data` is treated as a byte offset into the
buffer object's data store.
---
### Errors
`GL_INVALID_ENUM` is generated if `internalformat` is not one of the generic compressed
internal formats: `GL_COMPRESSED_RED`, `GL_COMPRESSED_RG`, `GL_COMPRESSED_RGB`,
`GL_COMPRESSED_RGBA`. `GL_COMPRESSED_SRGB`, or `GL_COMPRESSED_SRGB_ALPHA`.

`GL_INVALID_VALUE` is generated if `imageSize` is not consistent with the format, dimensions,
and contents of the specified compressed image data.

`GL_INVALID_OPERATION` is generated if parameter combinations are not supported by the specific
compressed internal format as specified in the specific texture compression extension.

`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the
`GL_PIXEL_UNPACK_BUFFER` target and the buffer object's data store is currently mapped.

`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the
`GL_PIXEL_UNPACK_BUFFER` target and the data would be unpacked from the buffer object such that the
memory reads required would exceed the data store size.

GL_INVALID_OPERATION is generated by `glCompressedTextureSubImage1D` function if texture is not
the name of an existing texture object.

Undefined results, including abnormal program termination, are generated if `data` is not encoded
in a manner consistent with the extension specification defining the internal compression format.
---
### Associated Gets
glGetCompressedTexImage

glGet with argument `GL_TEXTURE_COMPRESSED`

glGet with argument `GL_PIXEL_UNPACK_BUFFER_BINDING`

glGetTexLevelParameter with arguments `GL_TEXTURE_INTERNAL_FORMAT` and
`GL_TEXTURE_COMPRESSED_IMAGE_SIZE`
---
### Version Support
`glCompressedTexSubImage1D` `glCompressedTextureSubImage1D`
---
### See Also
glActiveTexture, glCompressedTexImage1D, glCompressedTexImage2D, glCompressedTexImage3D,
glCompressedTexSubImage2D, glCompressedTexSubImage3D, glCopyTexImage1D,
glCopyTexImage2D, glCopyTexSubImage1D, glCopyTexSubImage2D, glCopyTexSubImage3D,
glPixelStore, glTexImage2D, glTexImage3D, glTexSubImage1D, glTexSubImage2D,
glTexSubImage3D, glTexParameter
---
### Copyright
Copyright 1991-2006 Silicon Graphics, Inc. Copyright 2010-2014 Khronos Group. This document
is licensed under the SGI Free Software B License. For details, see
https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.
]],
  [[Specify a two-dimensional texture subimage in a compressed format
---
### Parameters
`target` Specifies the target to which the texture is bound for `glCompressedTexSubImage2D`
function. Must be `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`,
`GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`,
`GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, or
`GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`.

`texture` Specifies the texture object name for `glCompressedTextureSubImage2D` function.

`level` Specifies the level-of-detail number. Level 0 is the base image level. Level n is the
n th mipmap reduction image.

`xoffset` Specifies a texel offset in the x direction within the texture array.
`yoffset` Specifies a texel offset in the y direction within the texture array.
`width` Specifies the width of the texture subimage.
`height` Specifies the height of the texture subimage.
`format` Specifies the format of the compressed image data stored at address `data`.

`imageSize` Specifies the number of unsigned bytes of image data starting at the address
specified by `data`.

`data` Specifies a pointer to the compressed image data in memory.
---
### Description
Texturing allows elements of an image array to be read by shaders. `glCompressedTexSubImage2D`
and `glCompressedTextureSubImage2D` redefine a contiguous subregion of an existing two-dimensional
texture image. The texels referenced by `data` replace the portion of the existing texture array
with x indices `xoffset` and xoffset + width - 1, and the y indices `yoffset` and
yoffset + height - 1, inclusive. This region may not include any texels outside the range of the
texture array as it was originally specified. It is not an error to specify a subtexture with width
of 0, but such a specification has no effect.

`internalformat` must be a known compressed image format (such as `GL_RGTC` ) or an
extension-specified compressed-texture format. The `format` of the compressed texture image is
selected by the GL implementation that compressed it (see glTexImage2D ) and should be queried at
the time the texture was compressed with glGetTexLevelParameter.

If a non-zero named buffer object is bound to the `GL_PIXEL_UNPACK_BUFFER` target (see
glBindBuffer ) while a texture image is specified, `data` is treated as a byte offset into the
buffer object's data store.
---
### Errors
`GL_INVALID_ENUM` is generated if `internalformat` is of the generic compressed internal
formats: `GL_COMPRESSED_RED`, `GL_COMPRESSED_RG`, `GL_COMPRESSED_RGB`, `GL_COMPRESSED_RGBA`.
`GL_COMPRESSED_SRGB`, or `GL_COMPRESSED_SRGB_ALPHA`.

`GL_INVALID_ENUM` is generated by `glCompressedTexSubImage2D` if `target` is
`GL_TEXTURE_RECTANGLE` or `GL_PROXY_TEXTURE_RECTANGLE`.

`GL_INVALID_VALUE` is generated if `imageSize` is not consistent with the format, dimensions,
and contents of the specified compressed image data.

`GL_INVALID_OPERATION` is generated if parameter combinations are not supported by the specific
compressed internal format as specified in the specific texture compression extension.

`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the
`GL_PIXEL_UNPACK_BUFFER` target and the buffer object's data store is currently mapped.

`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the
`GL_PIXEL_UNPACK_BUFFER` target and the data would be unpacked from the buffer object such that the
memory reads required would exceed the data store size.

`GL_INVALID_OPERATION` is generated by `glCompressedTextureSubImage2D` if `texture` is not
the name of an existing texture object.

`GL_INVALID_OPERATION` is generated by `glCompressedTextureSubImage2D` if the effective target
is `GL_TEXTURE_RECTANGLE`.

Undefined results, including abnormal program termination, are generated if `data` is not encoded
in a manner consistent with the extension specification defining the internal compression format.
---
### Associated Gets
glGetCompressedTexImage

glGet with argument `GL_TEXTURE_COMPRESSED`

glGet with argument `GL_PIXEL_UNPACK_BUFFER_BINDING`

glGetTexLevelParameter with arguments `GL_TEXTURE_INTERNAL_FORMAT` and
`GL_TEXTURE_COMPRESSED_IMAGE_SIZE`
---
### Version Support
`glCompressedTexSubImage2D` `glCompressedTextureSubImage2D`
---
### See Also
glActiveTexture, glCompressedTexImage1D, glCompressedTexImage2D, glCompressedTexImage3D,
glCompressedTexSubImage1D, glCompressedTexSubImage3D, glCopyTexImage1D,
glCopyTexImage2D, glCopyTexSubImage1D, glCopyTexSubImage2D, glCopyTexSubImage3D,
glPixelStore, glTexImage2D, glTexImage3D, glTexSubImage1D, glTexSubImage2D,
glTexSubImage3D, glTexParameter
---
### Copyright
Copyright 1991-2006 Silicon Graphics, Inc. Copyright 2010-2014 Khronos Group. This document
is licensed under the SGI Free Software B License. For details, see
https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.
]],
  [[Specify a three-dimensional texture subimage in a compressed format
---
### Parameters
`target` Specifies the target to which the texture is bound for `glCompressedTexSubImage3D`
function. Must be `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_3D`, or `GL_TEXTURE_CUBE_MAP_ARRAY`.

`texture` Specifies the texture object name for `glCompressedTextureSubImage3D` function.

`level` Specifies the level-of-detail number. Level 0 is the base image level. Level n is the
n th mipmap reduction image.

`xoffset` Specifies a texel offset in the x direction within the texture array.
`yoffset` Specifies a texel offset in the y direction within the texture array.
`zoffset` Specifies a texel offset in the z direction within the texture array.
`width` Specifies the width of the texture subimage.
`height` Specifies the height of the texture subimage.
`depth` Specifies the depth of the texture subimage.
`format` Specifies the format of the compressed image data stored at address `data`.

`imageSize` Specifies the number of unsigned bytes of image data starting at the address
specified by `data`.

`data` Specifies a pointer to the compressed image data in memory.
---
### Description
Texturing allows elements of an image array to be read by shaders. `glCompressedTexSubImage3D`
and `glCompressedTextureSubImage3D` redefine a contiguous subregion of an existing
three-dimensional texture image. The texels referenced by `data` replace the portion of the
existing texture array with x indices `xoffset` and xoffset + width - 1, and the y indices
`yoffset` and yoffset + height - 1, and the z indices `zoffset` and zoffset + depth - 1,
inclusive. This region may not include any texels outside the range of the texture array as it was
originally specified. It is not an error to specify a subtexture with width of 0, but such a
specification has no effect.

`internalformat` must be a known compressed image format (such as `GL_RGTC` ) or an
extension-specified compressed-texture format. The `format` of the compressed texture image is
selected by the GL implementation that compressed it (see glTexImage3D ) and should be queried at
the time the texture was compressed with glGetTexLevelParameter.

If a non-zero named buffer object is bound to the `GL_PIXEL_UNPACK_BUFFER` target (see
glBindBuffer ) while a texture image is specified, `data` is treated as a byte offset into the
buffer object's data store.
---
### Errors
`GL_INVALID_ENUM` is generated if `internalformat` is one of the generic compressed internal
formats: `GL_COMPRESSED_RED`, `GL_COMPRESSED_RG`, `GL_COMPRESSED_RGB`, `GL_COMPRESSED_RGBA`.
`GL_COMPRESSED_SRGB`, or `GL_COMPRESSED_SRGB_ALPHA`.

`GL_INVALID_ENUM` is generated by `glCompressedTexSubImage3D` if `target` is not
`GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_3D`, or `GL_TEXTURE_CUBE_MAP_ARRAY`.

`GL_INVALID_OPERATION` is generated by `glCompressedTextureSubImage3D` if `texture` is not
the name of an existing texture object.

`GL_INVALID_VALUE` is generated if `imageSize` is not consistent with the format, dimensions,
and contents of the specified compressed image data.

`GL_INVALID_OPERATION` is generated if parameter combinations are not supported by the specific
compressed internal format as specified in the specific texture compression extension.

`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the
`GL_PIXEL_UNPACK_BUFFER` target and the buffer object's data store is currently mapped.

`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the
`GL_PIXEL_UNPACK_BUFFER` target and the data would be unpacked from the buffer object such that the
memory reads required would exceed the data store size.

Undefined results, including abnormal program termination, are generated if `data` is not encoded
in a manner consistent with the extension specification defining the internal compression format.
---
### Associated Gets
glGetCompressedTexImage

glGet with argument `GL_TEXTURE_COMPRESSED`

glGet with argument `GL_PIXEL_UNPACK_BUFFER_BINDING`

glGetTexLevelParameter with arguments `GL_TEXTURE_INTERNAL_FORMAT` and
`GL_TEXTURE_COMPRESSED_IMAGE_SIZE`
---
### Version Support
`glCompressedTexSubImage3D` `glCompressedTextureSubImage3D`
---
### See Also
glActiveTexture, glCompressedTexImage1D, glCompressedTexImage2D, glCompressedTexImage3D,
glCompressedTexSubImage1D, glCompressedTexSubImage2D, glCopyTexImage1D,
glCopyTexImage2D, glCopyTexSubImage1D, glCopyTexSubImage2D, glCopyTexSubImage3D,
glPixelStore, glTexImage2D, glTexImage3D, glTexSubImage1D, glTexSubImage2D,
glTexSubImage3D, glTexParameter
---
### Copyright
Copyright 1991-2006 Silicon Graphics, Inc. Copyright 2010-2014 Khronos Group. This document
is licensed under the SGI Free Software B License. For details, see
https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.
]],
  [[Copy all or part of the data store of a buffer object to the data store of another buffer object
---
### Parameters
`readTarget` Specifies the target to which the source buffer object is bound for
`glCopyBufferSubData`

`writeTarget` Specifies the target to which the destination buffer object is bound for
`glCopyBufferSubData`.

`readBuffer` Specifies the name of the source buffer object for `glCopyNamedBufferSubData`.

`writeBuffer` Specifies the name of the destination buffer object for
`glCopyNamedBufferSubData`.

`readOffset` Specifies the offset, in basic machine units, within the data store of the source
buffer object at which data will be read.
`writeOffset` Specifies the offset, in basic machine units, within the data store of the
destination buffer object at which data will be written.
`size` Specifies the size, in basic machine units, of the data to be copied from the source
buffer object to the destination buffer object.
---
### Description
`glCopyBufferSubData` and `glCopyNamedBufferSubData` copy part of the data store attached to a
source buffer object to the data store attached to a destination buffer object. The number of basic
machine units indicated by `size` is copied from the source at offset `readOffset` to the
destination at `writeOffset`. `readOffset`, `writeOffset` and `size` are in terms of basic
machine units.

For `glCopyBufferSubData`, `readTarget` and `writeTarget` specify the targets to which the
source and destination buffer objects are bound, and must each be one of the buffer binding targets
in the following table:

Any of these targets may be used, but the targets `GL_COPY_READ_BUFFER` and
`GL_COPY_WRITE_BUFFER` are provided specifically to allow copies between buffers without disturbing
other GL state.

`readOffset`, `writeOffset` and `size` must all be greater than or equal to zero.

Furthermore, $readOffset+size$ must not exceeed the size of the source buffer object, and
$writeOffset+size$ must not exceeed the size of the buffer bound to `writeTarget`. If the source
and destination are the same buffer object, then the source and destination ranges must not overlap.

---
### Notes
The `GL_DISPATCH_INDIRECT_BUFFER` and `GL_SHADER_STORAGE_BUFFER` targets are available only if
the GL version is 4.3 or greater.

The `GL_QUERY_BUFFER` target is available only if the GL version is 4.4 or greater.
---
### Errors
`GL_INVALID_ENUM` is generated by `glCopyBufferSubData` if `readTarget` or `writeTarget` is
not one of the buffer binding targets listed above.

`GL_INVALID_OPERATION` is generated by `glCopyBufferSubData` if zero is bound to `readTarget`
or `writeTarget`.

`GL_INVALID_OPERATION` is generated by `glCopyNamedBufferSubData` if `readBuffer` or
`writeBuffer` is not the name of an existing buffer object.

`GL_INVALID_VALUE` is generated if any of `readOffset`, `writeOffset` or `size` is
negative, if $readOffset + size$ is greater than the size of the source buffer object (its value of
`GL_BUFFER_SIZE` ), or if $writeOffset + size$ is greater than the size of the destination buffer
object.

`GL_INVALID_VALUE` is generated if the source and destination are the same buffer object, and the
ranges $[readOffset,readOffset+size)$ and $[writeOffset,writeOffset+size)$ overlap.

`GL_INVALID_OPERATION` is generated if either the source or destination buffer object is mapped
with glMapBufferRange or glMapBuffer, unless they were mapped with the `GL_MAP_PERSISTENT`
bit set in the `glMapBufferRange` `access` flags.
---
### Version Support
`glCopyBufferSubData` `glCopyNamedBufferSubData`
---
### See Also
glGenBuffers, glBindBuffer, glBufferData, glBufferSubData, glGetBufferSubData,
glMapBuffer, glMapBufferRange
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Perform a raw data copy between two images
---
### Parameters
`srcName` The name of a texture or renderbuffer object from which to copy.
`srcTarget` The target representing the namespace of the source name `srcName`.

`srcLevel` The mipmap level to read from the source.
`srcX` The X coordinate of the left edge of the souce region to copy.
`srcY` The Y coordinate of the top edge of the souce region to copy.
`srcZ` The Z coordinate of the near edge of the souce region to copy.
`dstName` The name of a texture or renderbuffer object to which to copy.
`dstTarget` The target representing the namespace of the destination name `dstName`.

`dstX` The X coordinate of the left edge of the destination region.
`dstY` The Y coordinate of the top edge of the destination region.
`dstZ` The Z coordinate of the near edge of the destination region.
`srcWidth` The width of the region to be copied.
`srcHeight` The height of the region to be copied.
`srcDepth` The depth of the region to be copied.
---
### Description
`glCopyImageSubData` may be used to copy data from one image (i.e. texture or renderbuffer) to
another. `glCopyImageSubData` does not perform general-purpose conversions such as scaling,
resizing, blending, color-space, or format conversions. It should be considered to operate in a
manner similar to a CPU memcpy. CopyImageSubData can copy between images with different internal
formats, provided the formats are compatible.

`glCopyImageSubData` also allows copying between certain types of compressed and uncompressed
internal formats. This copy does not perform on-the-fly compression or decompression. When copying
from an uncompressed internal format to a compressed internal format, each texel of uncompressed
data becomes a single block of compressed data. When copying from a compressed internal format to an
uncompressed internal format, a block of compressed data becomes a single texel of uncompressed
data. The texel size of the uncompressed format must be the same size the block size of the
compressed formats. Thus it is permitted to copy between a 128-bit uncompressed format and a
compressed format which uses 8-bit 4x4 blocks, or between a 64-bit uncompressed format and a
compressed format which uses 4-bit 4x4 blocks.

The source object is identified by `srcName` and `srcTarget` and the destination object is
identified by `dstName` and `dstTarget`. The interpretation of the name depends on the value of
the corresponding `target` parameter. If `target` is `GL_RENDERBUFFER`, the name is
interpreted as the name of a renderbuffer object. If the target parameter is a texture target, the
name is interpreted as a texture object. All non-proxy texture targets are accepted, with the
exception of `GL_TEXTURE_BUFFER` and the cubemap face selectors.

`srcLevel` and `dstLevel` identify the source and destination level of detail. For textures,
this must be a valid level of detail in the texture object. For renderbuffers, this value must be
zero.

`srcX`, `srcY`, and `srcZ` specify the lower left texel coordinates of a `srcWidth` -wide by
`srcHeight` -high by `srcDepth` -deep rectangular subregion of the source texel array. Similarly,
`dstX`, `dstY` and `dstZ` specify the coordinates of a subregion of the destination texel
array. The source and destination subregions must be contained entirely within the specified level
of the corresponding image objects.

The dimensions are always specified in texels, even for compressed texture formats. However, it
should be noted that if only one of the source and destination textures is compressed then the
number of texels touched in the compressed image will be a factor of the block size larger than in
the uncompressed image. Slices of a `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D_ARRAY`,
`GL_TEXTURE_CUBE_MAP_ARRAY` `GL_TEXTURE_3D` and faces of `GL_TEXTURE_CUBE_MAP` are all compatible
provided they share a compatible internal format, and multiple slices or faces may be copied between
these objects with a single call by specifying the starting slice with `srcZ` and `dstZ`, and
the number of slices to be copied with `srcDepth`. Cubemap textures always have six faces which
are selected by a zero-based face index.

For the purposes of CopyImageSubData, two internal formats are considered compatible if any of the
following conditions are met: the formats are the same, the formats are considered compatible
according to the compatibility rules used for texture views as defined in section 3.9.X. In
particular, if both internal formats are listed in the same entry of Table 3.X.2, they are
considered compatible, or one format is compressed and the other is uncompressed and Table 4.X.1
lists the two formats in the same row. If the formats are not compatible, an INVALID_OPERATION
error is generated.

### Sized Internal Formats
Texel / Block Size Uncompressed Internal Format Compressed Internal Format(s)
64-bit `GL_RGBA32UI`, `GL_RGBA32I`, `GL_RGBA32F` `GL_COMPRESSED_RGBA_S3TC_DXT3_EXT`,
`GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT`, `GL_COMPRESSED_RGBA_S3TC_DXT5_EXT`,
`GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT`, `GL_COMPRESSED_RG_RGTC2`,
`GL_COMPRESSED_SIGNED_RG_RGTC2`, `GL_COMPRESSED_RGBA_BPTC_UNORM`,
`GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM`, `GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT`,
`GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT` 128-bit `GL_RGBA16UI`, `GL_RGBA16I`, `GL_RGBA16F`,
`GL_RG32F`, `GL_RG32UI`, `GL_RG32I`, `GL_RGBA16`, `GL_RGBA16_SNORM`
`GL_COMPRESSED_RGB_S3TC_DXT1_EXT`, `GL_COMPRESSED_SRGB_S3TC_DXT1_EXT`,
`GL_COMPRESSED_RGBA_S3TC_DXT1_EXT`, `GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT`,
`GL_COMPRESSED_RED_RGTC1`, `GL_COMPRESSED_SIGNED_RED_RGTC1`
---
### Errors
`GL_INVALID_OPERATION` is generated if the texel size of the uncompressed image is not equal to
the block size of the compressed image.

`GL_INVALID_ENUM` is generated if either target parameter is not `GL_RENDERBUFFER`, a valid
non-proxy texture target other than `GL_TEXTURE_BUFFER`, or is one of the cubemap face selectors.

`GL_INVALID_ENUM` is generated if `target` does not match the type of the object.

`GL_INVALID_OPERATION` is generated if either object is a texture and the texture is not
complete.

`GL_INVALID_OPERATION` is generated if the source and destination internal formats are not
compatible, or if the number of samples do not match.

`GL_INVALID_VALUE` is generated if either name does not correspond to a valid renderbuffer or
texture object according to the corresponding target parameter.

`GL_INVALID_VALUE` is generated if the specified level of either the source or destination is not
a valid level for the corresponding image.

`GL_INVALID_VALUE` is generated if the dimensions of the either subregion exceeds the boundaries
of the corresponding image object, or if the image format is compressed and the dimensions of the
subregion fail to meet the alignment constraints of the format.
---
### Associated Gets
glGet with argument `GL_MAX_COMPUTE_WORK_GROUP_COUNT`
---
### Version Support
`glCopyImageSubData`
---
### See Also
glDispatchComputeIndirect.
---
### Copyright
Copyright 2013-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Copy pixels into a 1D texture image
---
### Parameters
`target` Specifies the target texture. Must be `GL_TEXTURE_1D`.

`level` Specifies the level-of-detail number. Level 0 is the base image level. Level n is the
n th mipmap reduction image.

`internalformat` Specifies the internal format of the texture. Must be one of the following
symbolic constants: `GL_COMPRESSED_RED`, `GL_COMPRESSED_RG`, `GL_COMPRESSED_RGB`,
`GL_COMPRESSED_RGBA`. `GL_COMPRESSED_SRGB`, `GL_COMPRESSED_SRGB_ALPHA`. `GL_DEPTH_COMPONENT`,
`GL_DEPTH_COMPONENT16`, `GL_DEPTH_COMPONENT24`, `GL_DEPTH_COMPONENT32`, `GL_STENCIL_INDEX8`,
`GL_RED`, `GL_RG`, `GL_RGB`, `GL_R3_G3_B2`, `GL_RGB4`, `GL_RGB5`, `GL_RGB8`,
`GL_RGB10`, `GL_RGB12`, `GL_RGB16`, `GL_RGBA`, `GL_RGBA2`, `GL_RGBA4`, `GL_RGB5_A1`,
`GL_RGBA8`, `GL_RGB10_A2`, `GL_RGBA12`, `GL_RGBA16`, `GL_SRGB`, `GL_SRGB8`,
`GL_SRGB_ALPHA`, or `GL_SRGB8_ALPHA8`.

`x` `y` Specify the window coordinates of the left corner of the row of pixels to be copied.
`width` Specifies the width of the texture image. The height of the texture image is 1.
`border` Must be 0.
---
### Description
`glCopyTexImage1D` defines a one-dimensional texture image with pixels from the current
`GL_READ_BUFFER`.

The screen-aligned pixel row with left corner at x y and with a length of width defines
the texture array at the mipmap level specified by `level`. `internalformat` specifies the
internal format of the texture array.

The pixels in the row are processed exactly as if glReadPixels had been called, but the process
stops just before final conversion. At this point all pixel component values are clamped to the
range 0 1 and then converted to the texture's internal format for storage in the texel array.

Pixel ordering is such that lower x screen coordinates correspond to lower texture
coordinates.

If any of the pixels within the specified row of the current `GL_READ_BUFFER` are outside the
window associated with the current rendering context, then the values obtained for those pixels are
undefined.

`glCopyTexImage1D` defines a one-dimensional texture image with pixels from the current
`GL_READ_BUFFER`.

When `internalformat` is one of the sRGB types, the GL does not automatically convert the source
pixels to the sRGB color space. In this case, the `glPixelMap` function can be used to accomplish
the conversion.
---
### Notes
1, 2, 3, and 4 are not accepted values for `internalformat`.

An image with 0 width indicates a NULL texture. `GL_STENCIL_INDEX8` is accepted for
`internalformat` only if the GL version is 4.4 or higher.
]],
  [[Copy pixels into a 2D texture image
---
### Parameters
`target` Specifies the target texture. Must be `GL_TEXTURE_2D`,
`GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`,
`GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`,
`GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`.

`level` Specifies the level-of-detail number. Level 0 is the base image level. Level n is the
n th mipmap reduction image.

`internalformat` Specifies the internal format of the texture. Must be one of the following
symbolic constants: `GL_COMPRESSED_RED`, `GL_COMPRESSED_RG`, `GL_COMPRESSED_RGB`,
`GL_COMPRESSED_RGBA`. `GL_COMPRESSED_SRGB`, `GL_COMPRESSED_SRGB_ALPHA`. `GL_DEPTH_COMPONENT`,
`GL_DEPTH_COMPONENT16`, `GL_DEPTH_COMPONENT24`, `GL_DEPTH_COMPONENT32`, `GL_STENCIL_INDEX8`,
`GL_RED`, `GL_RG`, `GL_RGB`, `GL_R3_G3_B2`, `GL_RGB4`, `GL_RGB5`, `GL_RGB8`,
`GL_RGB10`, `GL_RGB12`, `GL_RGB16`, `GL_RGBA`, `GL_RGBA2`, `GL_RGBA4`, `GL_RGB5_A1`,
`GL_RGBA8`, `GL_RGB10_A2`, `GL_RGBA12`, `GL_RGBA16`, `GL_SRGB`, `GL_SRGB8`,
`GL_SRGB_ALPHA`, or `GL_SRGB8_ALPHA8`.

`x` `y` Specify the window coordinates of the lower left corner of the rectangular region of
pixels to be copied.
`width` Specifies the width of the texture image.
`height` Specifies the height of the texture image.
`border` Must be 0.
---
### Description
`glCopyTexImage2D` defines a two-dimensional texture image, or cube-map texture image with pixels
from the current `GL_READ_BUFFER`.

The screen-aligned pixel rectangle with lower left corner at ( `x`, `y` ) and with a width of
width and a height of height defines the texture array at the mipmap level specified by
`level`. `internalformat` specifies the internal format of the texture array.

The pixels in the rectangle are processed exactly as if glReadPixels had been called, but the
process stops just before final conversion. At this point all pixel component values are clamped to
the range 0 1 and then converted to the texture's internal format for storage in the texel
array.

Pixel ordering is such that lower x and y screen coordinates correspond to lower s and
t texture coordinates.

If any of the pixels within the specified rectangle of the current `GL_READ_BUFFER` are outside
the window associated with the current rendering context, then the values obtained for those pixels
are undefined.

When `internalformat` is one of the sRGB types, the GL does not automatically convert the source
pixels to the sRGB color space. In this case, the `glPixelMap` function can be used to accomplish
the conversion.
---
### Notes
1, 2, 3, and 4 are not accepted values for `internalformat`.

An image with height or width of 0 indicates a NULL texture. `GL_STENCIL_INDEX8` is accepted
for `internalformat` only if the GL version is 4.4 or higher.
]],
  [[Copy a one-dimensional texture subimage
---
### Parameters
`target` Specifies the target to which the texture object is bound for `glCopyTexSubImage1D`
function. Must be `GL_TEXTURE_1D`.

`texture` Specifies the texture object name for `glCopyTextureSubImage1D` function.

`level` Specifies the level-of-detail number. Level 0 is the base image level. Level n is the
n th mipmap reduction image.

`xoffset` Specifies the texel offset within the texture array.
`x` `y` Specify the window coordinates of the left corner of the row of pixels to be copied.
`width` Specifies the width of the texture subimage.
---
### Description
`glCopyTexSubImage1D` and `glCopyTextureSubImage1D` replace a portion of a one-dimensional
texture image with pixels from the current `GL_READ_BUFFER` (rather than from main memory, as is
the case for glTexSubImage1D ). For `glCopyTexSubImage1D`, the texture object that is bound to
`target` will be used for the process. For `glCopyTextureSubImage1D`, `texture` tells which
texture object should be used for the purpose of the call.

The screen-aligned pixel row with left corner at ( `x`,\\\\ `y` ), and with length `width`
replaces the portion of the texture array with x indices `xoffset` through xoffset + width - 1,
inclusive. The destination in the texture array may not include any texels outside the texture
array as it was originally specified.

The pixels in the row are processed exactly as if glReadPixels had been called, but the process
stops just before final conversion. At this point, all pixel component values are clamped to the
range 0 1 and then converted to the texture's internal format for storage in the texel array.

It is not an error to specify a subtexture with zero width, but such a specification has no effect.

If any of the pixels within the specified row of the current `GL_READ_BUFFER` are outside the read
window associated with the current rendering context, then the values obtained for those pixels are
undefined.

No change is made to the internalformat or width parameters of the specified texture array or
to texel values outside the specified subregion.
---
### Notes
The glPixelStore mode affects texture images.
]],
  [[Copy a two-dimensional texture subimage
---
### Parameters
`target` Specifies the target to which the texture object is bound for `glCopyTexSubImage2D`
function. Must be `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`,
`GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`,
`GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`,
`GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`, or `GL_TEXTURE_RECTANGLE`.

`texture` Specifies the texture object name for `glCopyTextureSubImage2D` function.

`level` Specifies the level-of-detail number. Level 0 is the base image level. Level n is the
n th mipmap reduction image.

`xoffset` Specifies a texel offset in the x direction within the texture array.
`yoffset` Specifies a texel offset in the y direction within the texture array.
`x` `y` Specify the window coordinates of the lower left corner of the rectangular region of
pixels to be copied.
`width` Specifies the width of the texture subimage.
`height` Specifies the height of the texture subimage.
---
### Description
`glCopyTexSubImage2D` and `glCopyTextureSubImage2D` replace a rectangular portion of a
two-dimensional texture image, cube-map texture image, rectangular image, or a linear portion of a
number of slices of a one-dimensional array texture with pixels from the current `GL_READ_BUFFER`
(rather than from main memory, as is the case for glTexSubImage2D ).

The screen-aligned pixel rectangle with lower left corner at x y and with width `width` and
height `height` replaces the portion of the texture array with x indices `xoffset` through
xoffset + width - 1, inclusive, and y indices `yoffset` through yoffset + height - 1,
inclusive, at the mipmap level specified by `level`.

The pixels in the rectangle are processed exactly as if glReadPixels had been called, but the
process stops just before final conversion. At this point, all pixel component values are clamped to
the range $[0,1]$ and then converted to the texture's internal format for storage in the texel
array.

The destination rectangle in the texture array may not include any texels outside the texture array
as it was originally specified. It is not an error to specify a subtexture with zero width or
height, but such a specification has no effect. When `target` is `GL_TEXTURE_1D_ARRAY` then the
y coordinate and height are treated as the start slice and number of slices to modify, respectively.

If any of the pixels within the specified rectangle of the current `GL_READ_BUFFER` are outside
the read window associated with the current rendering context, then the values obtained for those
pixels are undefined.

No change is made to the internalformat, width or height parameters of the specified texture
array, or to texel values outside the specified subregion.
---
### Notes
glPixelStore modes affect texture images.
]],
  [[Copy a three-dimensional texture subimage
---
### Parameters
`target` Specifies the target to which the texture object is bound for `glCopyTexSubImage3D`
function. Must be `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY` or `GL_TEXTURE_CUBE_MAP_ARRAY`.

`texture` Specifies the texture object name for `glCopyTextureSubImage3D` function.

`level` Specifies the level-of-detail number. Level 0 is the base image level. Level n is the
n th mipmap reduction image.

`xoffset` Specifies a texel offset in the x direction within the texture array.
`yoffset` Specifies a texel offset in the y direction within the texture array.
`zoffset` Specifies a texel offset in the z direction within the texture array.
`x` `y` Specify the window coordinates of the lower left corner of the rectangular region of
pixels to be copied.
`width` Specifies the width of the texture subimage.
`height` Specifies the height of the texture subimage.
---
### Description
`glCopyTexSubImage3D` and `glCopyTextureSubImage3D` functions replace a rectangular portion of
a three-dimensional or two-dimensional array texture image with pixels from the current
`GL_READ_BUFFER` (rather than from main memory, as is the case for glTexSubImage3D ).

The screen-aligned pixel rectangle with lower left corner at ( `x`, `y` ) and with width
`width` and height `height` replaces the portion of the texture array with x indices `xoffset`
through xoffset + width - 1, inclusive, and y indices `yoffset` through yoffset + height
- 1, inclusive, at z index `zoffset` and at the mipmap level specified by `level`.

The pixels in the rectangle are processed exactly as if glReadPixels had been called, but the
process stops just before final conversion. At this point, all pixel component values are clamped to
the range 0 1 and then converted to the texture's internal format for storage in the texel
array.

The destination rectangle in the texture array may not include any texels outside the texture
array as it was originally specified. It is not an error to specify a subtexture with zero width or
height, but such a specification has no effect. If any of the pixels within the specified
rectangle of the current `GL_READ_BUFFER` are outside the read window associated with the current
rendering context, then the values obtained for those pixels are undefined.

No change is made to the internalformat, width, height, depth, or border parameters of
the specified texture array or to texel values outside the specified subregion.
---
### Notes
glPixelStore modes affect texture images.
]],
  [[Create buffer objects
---
### Parameters
`n` Specifies the number of buffer objects to create.
`buffers` Specifies an array in which names of the new buffer objects are stored.
---
### Description
`glCreateBuffers` returns `n` previously unused buffer names in `buffers`, each representing
a new buffer object initialized as if it had been bound to an unspecified target.
---
### Errors
`GL_INVALID_VALUE` is generated if `n` is negative.
---
### Version Support
`glCreateBuffers`
---
### See Also
glGenBuffers, glBindBufferBase, glBindBufferRange, glMapBuffer, glUnmapBuffer,
glDeleteBuffers, glGet, glIsBuffer
---
### Copyright
Copyright 2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Create framebuffer objects
---
### Parameters
`n` Number of framebuffer objects to create.
`framebuffers` Specifies an array in which names of the new framebuffer objects are stored.
---
### Description
`glCreateFramebuffers` returns `n` previously unused framebuffer names in `framebuffers`,
each representing a new framebuffer object initialized to the default state.
---
### Errors
`GL_INVALID_VALUE` is generated if `n` is negative.
---
### Version Support
`glCreateFramebuffers`
---
### See Also
glGenFramebuffers, glBindFramebuffer, glFramebufferRenderbuffer, glFramebufferTexture,
`glFramebufferTexture1D`, `glFramebufferTexture2D`, `glFramebufferTexture3D`,
glFramebufferTextureLayer, glDeleteFramebuffers, glIsFramebuffer
---
### Copyright
Copyright 2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Creates a program object
---
### Description
`glCreateProgram` creates an empty program object and returns a non-zero value by which it can be
referenced. A program object is an object to which shader objects can be attached. This provides a
mechanism to specify the shader objects that will be linked to create a program. It also provides a
means for checking the compatibility of the shaders that will be used to create a program (for
instance, checking the compatibility between a vertex shader and a fragment shader). When no longer
needed as part of a program object, shader objects can be detached.

One or more executables are created in a program object by successfully attaching shader objects to
it with glAttachShader, successfully compiling the shader objects with glCompileShader, and
successfully linking the program object with glLinkProgram. These executables are made part of
current state when glUseProgram is called. Program objects can be deleted by calling
glDeleteProgram. The memory associated with the program object will be deleted when it is no longer
part of current rendering state for any context.
---
### Notes
Like buffer and texture objects, the name space for program objects may be shared across a set of
contexts, as long as the server sides of the contexts share the same address space. If the name
space is shared across contexts, any attached objects and the data associated with those attached
objects are shared as well. Applications are responsible for providing the synchronization across
API calls when objects are accessed from different execution threads.
---
### Errors
This function returns 0 if an error occurs creating the program object.
---
### Associated Gets
glGet with the argument `GL_CURRENT_PROGRAM`

glGetActiveAttrib with a valid program object and the index of an active attribute variable

glGetActiveUniform with a valid program object and the index of an active uniform variable

glGetAttachedShaders with a valid program object

glGetAttribLocation with a valid program object and the name of an attribute variable

glGetProgram with a valid program object and the parameter to be queried

glGetProgramInfoLog with a valid program object

glGetUniform with a valid program object and the location of a uniform variable

glGetUniformLocation with a valid program object and the name of a uniform variable

glIsProgram
---
### Version Support
`glCreateProgram`
---
### See Also
glAttachShader, glBindAttribLocation, glCreateShader, glDeleteProgram, glDetachShader,
glLinkProgram, glUniform, glUseProgram, glValidateProgram
---
### Copyright
Copyright 2003-2005 3Dlabs Inc. Ltd. Copyright 2010-2014 Khronos Group. This material may be
distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8
June 1999. https://opencontent.org/openpub/.
]],
  [[Create program pipeline objects
---
### Parameters
`n` Number of program pipeline objects to create.
`pipelines` Specifies an array in which names of the new program pipeline objects are stored.
---
### Description
`glCreateProgramPipelines` returns `n` previously unused program pipeline names in `pipelines`,
each representing a new program pipeline object initialized to the default state.
---
### Errors
`GL_INVALID_VALUE` is generated if `n` is negative.
---
### Version Support
`glCreateProgramPipelines`
---
### See Also
glBindProgramPipeline, glCreateShader, glCreateProgram, glCompileShader,
glLinkProgram, glGenProgramPipelines, glDeleteProgramPipelines, glIsProgramPipeline
---
### Copyright
Copyright 2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Create query objects
---
### Parameters
`target` Specifies the target of each created query object.
`n` Number of query objects to create.
`ids` Specifies an array in which names of the new query objects are stored.
---
### Description
`glCreateQueries` returns `n` previously unused query object names in `ids`, each
representing a new query object with the specified `target`.

`target` may be one of `GL_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED`,
`GL_ANY_SAMPLES_PASSED_CONSERVATIVE`, `GL_TIME_ELAPSED`, `GL_TIMESTAMP`,
`GL_PRIMITIVES_GENERATED` or `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`.
---
### Errors
`GL_INVALID_ENUM` is generated if `target` is not an accepted value.

`GL_INVALID_VALUE` is generated if `n` is negative.
---
### Version Support
`glCreateQueries`
---
### See Also
glBeginQuery, glBeginQueryIndexed, glDeleteQueries, `glEndQuery`, glGenQueries,
glGetQueryObject, glGetQueryiv, glIsQuery
---
### Copyright
Copyright 2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Create renderbuffer objects
---
### Parameters
`n` Number of renderbuffer objects to create.
`renderbuffers` Specifies an array in which names of the new renderbuffer objects are stored.
---
### Description
`glCreateRenderbuffers` returns `n` previously unused renderbuffer object names in
`renderbuffers`, each representing a new renderbuffer object initialized to the default state.
---
### Errors
`GL_INVALID_VALUE` is generated if `n` is negative.
---
### Version Support
`glCreateRenderbuffers`
---
### See Also
glBindRenderbuffer, glDeleteRenderbuffers, glGenRenderbuffers, glIsRenderbuffer,
glRenderbufferStorage, glRenderbufferStorageMultisample
---
### Copyright
Copyright 2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Create sampler objects
---
### Parameters
`n` Number of sampler objects to create.
`samplers` Specifies an array in which names of the new sampler objects are stored.
---
### Description
`glCreateSamplers` returns `n` previously unused sampler names in `samplers`, each
representing a new sampler object initialized to the default state.
---
### Errors
`GL_INVALID_VALUE` is generated if `n` is negative.
---
### Version Support
`glCreateSamplers`
---
### See Also
glBindSampler, glBindTexture, glDeleteSamplers, glDeleteTextures, glGenSamplers,
glGenTextures, glGet, glGetSamplerParameter, glSamplerParameter
---
### Copyright
Copyright 2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Creates a shader object
---
### Parameters
`shaderType` Specifies the type of shader to be created. Must be one of `GL_COMPUTE_SHADER`,
`GL_VERTEX_SHADER`, `GL_TESS_CONTROL_SHADER`, `GL_TESS_EVALUATION_SHADER`,
`GL_GEOMETRY_SHADER`, or `GL_FRAGMENT_SHADER`.

---
### Description
`glCreateShader` creates an empty shader object and returns a non-zero value by which it can be
referenced. A shader object is used to maintain the source code strings that define a shader.
`shaderType` indicates the type of shader to be created. Five types of shader are supported. A
shader of type `GL_COMPUTE_SHADER` is a shader that is intended to run on the programmable compute
processor. A shader of type `GL_VERTEX_SHADER` is a shader that is intended to run on the
programmable vertex processor. A shader of type `GL_TESS_CONTROL_SHADER` is a shader that is
intended to run on the programmable tessellation processor in the control stage. A shader of type
`GL_TESS_EVALUATION_SHADER` is a shader that is intended to run on the programmable tessellation
processor in the evaluation stage. A shader of type `GL_GEOMETRY_SHADER` is a shader that is
intended to run on the programmable geometry processor. A shader of type `GL_FRAGMENT_SHADER` is a
shader that is intended to run on the programmable fragment processor.

When created, a shader object's `GL_SHADER_TYPE` parameter is set to either `GL_COMPUTE_SHADER`,
`GL_VERTEX_SHADER`, `GL_TESS_CONTROL_SHADER`, `GL_TESS_EVALUATION_SHADER`,
`GL_GEOMETRY_SHADER` or `GL_FRAGMENT_SHADER`, depending on the value of `shaderType`.
---
### Notes
Like buffer and texture objects, the name space for shader objects may be shared across a set of
contexts, as long as the server sides of the contexts share the same address space. If the name
space is shared across contexts, any attached objects and the data associated with those attached
objects are shared as well. Applications are responsible for providing the synchronization across
API calls when objects are accessed from different execution threads. `GL_COMPUTE_SHADER` is
available only if the GL version is 4.3 or higher.
---
### Errors
This function returns 0 if an error occurs creating the shader object. `GL_INVALID_ENUM` is
generated if `shaderType` is not an accepted value.
---
### Associated Gets
glGetShader with a valid shader object and the parameter to be queried

glGetShaderInfoLog with a valid shader object

glGetShaderSource with a valid shader object

glIsShader
---
### Version Support
`glCreateShader`
---
### See Also
glAttachShader, glCompileShader, glDeleteShader, glDetachShader, glShaderSource
---
### Copyright
Copyright 2003-2005 3Dlabs Inc. Ltd. Copyright 2010-2014 Khronos Group. This material may be
distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8
June 1999. https://opencontent.org/openpub/.
]],
  [[Create a stand-alone program from an array of null-terminated source code strings
---
### Parameters
`type` Specifies the type of shader to create.
`count` Specifies the number of source code strings in the array `strings`.

`strings` Specifies the address of an array of pointers to source code strings from which to
create the program object.
---
### Description
`glCreateShaderProgram` creates a program object containing compiled and linked shaders for a
single stage specified by `type`. `strings` refers to an array of `count` strings from which
to create the shader executables.

`glCreateShaderProgram` is equivalent (assuming no errors are generated) to:

const GLuint shader = glCreateShader(type); if (shader) { glShaderSource(shader, count, strings,
NULL); glCompileShader(shader); const GLuint program = glCreateProgram(); if (program) { GLint
compiled = GL_FALSE; glGetShaderiv(shader, GL_COMPILE_STATUS, &compiled);
glProgramParameteri(program, GL_PROGRAM_SEPARABLE, GL_TRUE); if (compiled) { glAttachShader(program,
shader); glLinkProgram(program); glDetachShader(program, shader); } /*
append-shader-info-log-to-program-info-log */ } glDeleteShader(shader); return program; } else {
return 0; } The program object created by `glCreateShaderProgram` has its `GL_PROGRAM_SEPARABLE`
status set to `GL_TRUE`.
---
### Errors
`GL_INVALID_ENUM` is generated if `type` is not an accepted shader type.

`GL_INVALID_VALUE` is generated if `count` is negative.

Other errors are generated if the supplied shader code fails to compile and link, as described for
the commands in the pseudocode sequence above, but all such errors are generated without any side
effects of executing those commands.
---
### Version Support
`glCreateShaderProgramv`
---
### See Also
glCreateShader, glCreateProgram, glCompileShader, glLinkProgram
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Create texture objects
---
### Parameters
`target` Specifies the effective texture target of each created texture.
`n` Number of texture objects to create.
`textures` Specifies an array in which names of the new texture objects are stored.
---
### Description
`glCreateTextures` returns `n` previously unused texture names in `textures`, each
representing a new texture object of the dimensionality and type specified by `target` and
initialized to the default values for that texture type.

`target` must be one of `GL_TEXTURE_1D`, `GL_TEXTURE_2D`, `GL_TEXTURE_3D`,
`GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_RECTANGLE`, `GL_TEXTURE_CUBE_MAP`,
`GL_TEXTURE_CUBE_MAP_ARRAY`, `GL_TEXTURE_BUFFER`, `GL_TEXTURE_2D_MULTISAMPLE` or
`GL_TEXTURE_2D_MULTISAMPLE_ARRAY`.
---
### Errors
`GL_INVALID_ENUM` is generated if `target` is not one of the allowable values.

`GL_INVALID_VALUE` is generated if `n` is negative.
---
### Version Support
`glCreateTextures`
---
### See Also
glBindTexture, glDeleteTextures, glGenTextures, glGet, glGetTexParameter,
glIsTexture, glTexBuffer, glTexImage1D, glTexImage2D, glTexImage2DMultisample,
glTexImage3D, glTexImage3DMultisample, glTexParameter
---
### Copyright
Copyright 2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Create transform feedback objects
---
### Parameters
`n` Number of transform feedback objects to create.
`ids` Specifies an array in which names of the new transform feedback objects are stored.
---
### Description
`glCreateTransformFeedbacks` returns `n` previously unused transform feedback object names in
`ids`, each representing a new transform feedback object initialized to the default state.
---
### Errors
`GL_INVALID_VALUE` is generated if `n` is negative.
---
### Version Support
`glCreateTransformFeedbacks`
---
### See Also
glBeginTransformFeedback, glBindTransformFeedback, glDeleteTransformFeedbacks,
`glEndTransformFeedback`, glGenTransformFeedbacks, glIsTransformFeedback,
glPauseTransformFeedback, glResumeTransformFeedback
---
### Copyright
Copyright 2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Create vertex array objects
---
### Parameters
`n` Number of vertex array objects to create.
`arrays` Specifies an array in which names of the new vertex array objects are stored.
---
### Description
`glCreateVertexArrays` returns `n` previously unused vertex array object names in `arrays`,
each representing a new vertex array object initialized to the default state.
---
### Errors
`GL_INVALID_VALUE` is generated if `n` is negative.
---
### Version Support
`glCreateVertexArrays`
---
### See Also
glBindVertexArray, glDeleteVertexArrays glEnableVertexAttribArray glGenVertexArrays,
glIsVertexArray, glVertexAttribPointer
---
### Copyright
Copyright 2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Specify whether front- or back-facing facets can be culled
---
### Parameters
`mode` Specifies whether front- or back-facing facets are candidates for culling. Symbolic
constants `GL_FRONT`, `GL_BACK`, and `GL_FRONT_AND_BACK` are accepted. The initial value is
`GL_BACK`.

---
### Description
`glCullFace` specifies whether front- or back-facing facets are culled (as specified by mode )
when facet culling is enabled. Facet culling is initially disabled. To enable and disable facet
culling, call the glEnable and `glDisable` commands with the argument `GL_CULL_FACE`. Facets
include triangles, quadrilaterals, polygons, and rectangles.

glFrontFace specifies which of the clockwise and counterclockwise facets are front-facing and
back-facing. See glFrontFace.
---
### Notes
If `mode` is `GL_FRONT_AND_BACK`, no facets are drawn, but other primitives such as points and
lines are drawn.
---
### Errors
`GL_INVALID_ENUM` is generated if `mode` is not an accepted value.
---
### Associated Gets
glIsEnabled with argument `GL_CULL_FACE`

glGet with argument `GL_CULL_FACE_MODE`
---
### Version Support
`glCullFace`
---
### See Also
glEnable, glFrontFace
---
### Copyright
Copyright 1991-2006 Silicon Graphics, Inc. Copyright 2010-2014 Khronos Group. This document
is licensed under the SGI Free Software B License. For details, see
https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.
]],
  [[Specify a callback to receive debugging messages from the GL
---
### Parameters
`callback` The address of a callback function that will be called when a debug message is
generated.
`userParam` A user supplied pointer that will be passed on each invocation of `callback`.

---
### Description
`glDebugMessageCallback` sets the current debug output callback function to the function whose
address is given in `callback`. The callback function should have the following prototype (in C),
or be otherwise compatible with such a prototype:

typedef void (APIENTRY *DEBUGPROC)(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei
length, const GLchar *message, const void *userParam); This function is defined to have the same
calling convention as the GL API functions. In most cases this is defined as APIENTRY, although it
will vary depending on platform, language and compiler.

Each time a debug message is generated the debug callback function will be invoked with `source`,
`type`, `id`, and `severity` associated with the message, and `length` set to the length
of debug message whose character string is in the array pointed to by `message`. `userParam`
will be set to the value passed in the `userParam` parameter to the most recent call to
`glDebugMessageCallback`.
---
### Notes
When the GL is in use remotely, the server may not be able to call functions in the client's
address space. In such cases, the callback function may not be invoked and the user should retrieve
debug messages from the context's debug message log by calling glGetDebugMessageLog.
---
### Version Support
`glDebugMessageCallback`
---
### See Also
glDebugMessageControl, glDebugMessageInsert, glGetDebugMessageLog.
---
### Copyright
Copyright 2013-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Control the reporting of debug messages in a debug context
---
### Parameters
`source` The source of debug messages to enable or disable.
`type` The type of debug messages to enable or disable.
`severity` The severity of debug messages to enable or disable.
`count` The length of the array `ids`.

`ids` The address of an array of unsigned integers contianing the ids of the messages to enable
or disable.
`enabled` A Boolean flag determining whether the selected messages should be enabled or
disabled.
---
### Description
`glDebugMessageControl` controls the reporting of debug messages generated by a debug context.

The parameters `source`, `type` and `severity` form a filter to select messages from the pool
of potential messages generated by the GL.

`source` may be `GL_DEBUG_SOURCE_API`, `GL_DEBUG_SOURCE_WINDOW_SYSTEM_`,
`GL_DEBUG_SOURCE_SHADER_COMPILER`, `GL_DEBUG_SOURCE_THIRD_PARTY`, `GL_DEBUG_SOURCE_APPLICATION`,
`GL_DEBUG_SOURCE_OTHER` to select messages generated by usage of the GL API, the window system,
the shader compiler, third party tools or libraries, explicitly by the application or by some other
source, respectively. It may also take the value `GL_DONT_CARE`. If `source` is not
`GL_DONT_CARE` then only messages whose source matches `source` will be referenced.

`type` may be one of `GL_DEBUG_TYPE_ERROR`, `GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR`,
`GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR`, `GL_DEBUG_TYPE_PORTABILITY`, `GL_DEBUG_TYPE_PERFORMANCE`,
`GL_DEBUG_TYPE_MARKER`, `GL_DEBUG_TYPE_PUSH_GROUP`, `GL_DEBUG_TYPE_POP_GROUP`, or
`GL_DEBUG_TYPE_OTHER` to indicate the type of messages describing GL errors, attempted use of
deprecated features, triggering of undefined behavior, portability issues, performance
notifications, markers, group push and pop events, and other types of messages, respectively. It may
also take the value `GL_DONT_CARE`. If `type` is not `GL_DONT_CARE` then only messages whose
type matches `type` will be referenced.

`severity` may be one of `GL_DEBUG_SEVERITY_LOW`, `GL_DEBUG_SEVERITY_MEDIUM`, or
`GL_DEBUG_SEVERITY_HIGH` to select messages of low, medium or high severity messages or to
`GL_DEBUG_SEVERITY_NOTIFICATION` for notifications. It may also take the value `GL_DONT_CARE`. If
`severity` is not `GL_DONT_CARE` then only messages whose severity matches `severity` will be
referenced.

`ids` contains a list of `count` message identifiers to select specific messages from the pool
of available messages. If `count` is zero then the value of `ids` is ignored. Otherwise, only
messages appearing in this list are selected. In this case, `source` and `type` may not be
`GL_DONT_CARE` and `severity` must be `GL_DONT_CARE`.

If `enabled` is `GL_TRUE` then messages that match the filter formed by `source`, `type`,
`severity` and `ids` are enabled. Otherwise, those messages are disabled.
---
### Notes
Although debug messages may be enabled in a non-debug context, the quantity and detail of such
messages may be substantially inferior to those in a debug context. In particular, a valid
implementation of the debug message queue in a non-debug context may produce no messages at all.
`GL_DEBUG_TYPE_MARKER`, `GL_DEBUG_TYPE_PUSH_GROUP`, `GL_DEBUG_TYPE_POP_GROUP`, and
`GL_DEBUG_SEVERITY_NOTIFICATION` are available only if the GL version is 4.3 or higher.
---
### Errors
`GL_INVALID_VALUE` is generated if `count` is negative.

`GL_INVALID_ENUM` is generated if any of `source`, `type` or `severity` is not one of the
accepted interface types.

`GL_INVALID_OPERATION` is generated if `count` is non-zero and either `source` or `type` is
`GL_DONT_CARE` or if `severity` is not `GL_DONT_CARE`.
---
### Version Support
`glDebugMessageControl`
---
### See Also
glDebugMessageInsert, glDebugMessageCallback, glGetDebugMessageLog.
---
### Copyright
Copyright 2013-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Inject an application-supplied message into the debug message queue
---
### Parameters
`source` The source of the debug message to insert.
`type` The type of the debug message insert.
`id` The user-supplied identifier of the message to insert.
`severity` The severity of the debug messages to insert.
`length` The length string contained in the character array whose address is given by
`message`.

`message` The address of a character array containing the message to insert.
---
### Description
`glDebugMessageInsert` inserts a user-supplied message into the debug output queue. `source`
specifies the source that will be used to classify the message and must be
`GL_DEBUG_SOURCE_APPLICATION` or `GL_DEBUG_SOURCE_THIRD_PARTY`. All other sources are reserved
for use by the GL implementation. `type` indicates the type of the message to be inserted and may
be one of `GL_DEBUG_TYPE_ERROR`, `GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR`,
`GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR`, `GL_DEBUG_TYPE_PORTABILITY`, `GL_DEBUG_TYPE_PERFORMANCE`,
`GL_DEBUG_TYPE_MARKER`, `GL_DEBUG_TYPE_PUSH_GROUP`, `GL_DEBUG_TYPE_POP_GROUP`, or
`GL_DEBUG_TYPE_OTHER`. `severity` indicates the severity of the message and may be
`GL_DEBUG_SEVERITY_LOW`, `GL_DEBUG_SEVERITY_MEDIUM`, `GL_DEBUG_SEVERITY_HIGH` or
`GL_DEBUG_SEVERITY_NOTIFICATION`. `id` is available for application defined use and may be any
value. This value will be recorded and used to identify the message.

`length` contains a count of the characters in the character array whose address is given in
`message`. If `length` is negative then `message` is treated as a null-terminated string. The
length of the message, whether specified explicitly or implicitly, must be less than or equal to the
implementation defined constant `GL_MAX_DEBUG_MESSAGE_LENGTH`.
---
### Notes
`GL_DEBUG_TYPE_MARKER`, `GL_DEBUG_TYPE_PUSH_GROUP`, `GL_DEBUG_TYPE_POP_GROUP`, and
`GL_DEBUG_SEVERITY_NOTIFICATION` are available only if the GL version is 4.3 or higher.
---
### Errors
`GL_INVALID_ENUM` is generated if any of `source`, `type` or `severity` is not one of the
accepted interface types.

`GL_INVALID_VALUE` is generated if the length of the message is greater than the value of
`GL_MAX_DEBUG_MESSAGE_LENGTH`.
---
### Version Support
`glDebugMessageInsert`
---
### See Also
glDebugMessageControl, glDebugMessageCallback, glGetDebugMessageLog.
---
### Copyright
Copyright 2013-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Delete named buffer objects
---
### Parameters
`n` Specifies the number of buffer objects to be deleted.
`buffers` Specifies an array of buffer objects to be deleted.
---
### Description
`glDeleteBuffers` deletes `n` buffer objects named by the elements of the array `buffers`.

After a buffer object is deleted, it has no contents, and its name is free for reuse (for example by
glGenBuffers ). If a buffer object that is currently bound is deleted, the binding reverts to 0
(the absence of any buffer object).

`glDeleteBuffers` silently ignores 0's and names that do not correspond to existing buffer
objects.
---
### Errors
`GL_INVALID_VALUE` is generated if `n` is negative.
---
### Associated Gets
glIsBuffer
---
### Version Support
`glDeleteBuffers`
---
### See Also
glBindBuffer, glGenBuffers, glGet
---
### Copyright
Copyright 2005 Addison-Wesley. Copyright 2010-2014 Khronos Group. This material may be
distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8
June 1999. https://opencontent.org/openpub/.
]],
  [[Delete framebuffer objects
---
### Parameters
`n` Specifies the number of framebuffer objects to be deleted.
`framebuffers` A pointer to an array containing `n` framebuffer objects to be deleted.

---
### Description
`glDeleteFramebuffers` deletes the `n` framebuffer objects whose names are stored in the array
addressed by `framebuffers`. The name zero is reserved by the GL and is silently ignored, should
it occur in `framebuffers`, as are other unused names. Once a framebuffer object is deleted, its
name is again unused and it has no attachments. If a framebuffer that is currently bound to one or
more of the targets `GL_DRAW_FRAMEBUFFER` or `GL_READ_FRAMEBUFFER` is deleted, it is as though
glBindFramebuffer had been executed with the corresponding `target` and `framebuffer` zero.
---
### Errors
`GL_INVALID_VALUE` is generated if `n` is negative.
---
### Version Support
`glDeleteFramebuffers`
---
### See Also
glGenFramebuffers, glBindFramebuffer, glCheckFramebufferStatus
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Deletes a program object
---
### Parameters
`program` Specifies the program object to be deleted.
---
### Description
`glDeleteProgram` frees the memory and invalidates the name associated with the program object
specified by `program.` This command effectively undoes the effects of a call to glCreateProgram.

If a program object is in use as part of current rendering state, it will be flagged for deletion,
but it will not be deleted until it is no longer part of current state for any rendering context. If
a program object to be deleted has shader objects attached to it, those shader objects will be
automatically detached but not deleted unless they have already been flagged for deletion by a
previous call to glDeleteShader. A value of 0 for `program` will be silently ignored.

To determine whether a program object has been flagged for deletion, call glGetProgram with
arguments `program` and `GL_DELETE_STATUS`.
---
### Errors
`GL_INVALID_VALUE` is generated if `program` is not a value generated by OpenGL.
---
### Associated Gets
glGet with argument `GL_CURRENT_PROGRAM`

glGetProgram with arguments `program` and `GL_DELETE_STATUS`

glIsProgram
---
### Version Support
`glDeleteProgram`
---
### See Also
glCreateShader, glDetachShader, glUseProgram
---
### Copyright
Copyright 2003-2005 3Dlabs Inc. Ltd. Copyright 2010-2014 Khronos Group. This material may be
distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8
June 1999. https://opencontent.org/openpub/.
]],
  [[Delete program pipeline objects
---
### Parameters
`n` Specifies the number of program pipeline objects to delete.
`pipelines` Specifies an array of names of program pipeline objects to delete.
---
### Description
`glDeleteProgramPipelines` deletes the `n` program pipeline objects whose names are stored in
the array `pipelines`. Unused names in `pipelines` are ignored, as is the name zero. After a
program pipeline object is deleted, its name is again unused and it has no contents. If program
pipeline object that is currently bound is deleted, the binding for that object reverts to zero and
no program pipeline object becomes current.
---
### Associated Gets
glGet with argument `GL_PROGRAM_PIPELINE_BINDING`
---
### Version Support
`glDeleteProgramPipelines`
---
### See Also
glGenProgramPipelines, glBindProgramPipeline, glIsProgramPipeline, glUseProgramStages,
glUseProgram
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Delete named query objects
---
### Parameters
`n` Specifies the number of query objects to be deleted.
`ids` Specifies an array of query objects to be deleted.
---
### Description
`glDeleteQueries` deletes `n` query objects named by the elements of the array `ids`. After a
query object is deleted, it has no contents, and its name is free for reuse (for example by
glGenQueries ).

`glDeleteQueries` silently ignores 0's and names that do not correspond to existing query
objects.
---
### Errors
`GL_INVALID_VALUE` is generated if `n` is negative.
---
### Associated Gets
glIsQuery
---
### Version Support
`glDeleteQueries`
---
### See Also
glBeginQuery, `glEndQuery`, glGenQueries, glGetQueryiv, glGetQueryObject
---
### Copyright
Copyright 2005 Addison-Wesley. Copyright 2010-2014 Khronos Group. This material may be
distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8
June 1999. https://opencontent.org/openpub/.
]],
  [[Set the active program object for a program pipeline object
---
### Parameters
`pipeline` Specifies the program pipeline object to set the active program object for.
`program` Specifies the program object to set as the active program pipeline object `pipeline`.

---
### Description
`glActiveShaderProgram` sets the linked program named by `program` to be the active program for
the program pipeline object `pipeline`. The active program in the active program pipeline object
is the target of calls to glUniform when no program has been made current through a call to
glUseProgram.
---
### Errors
`GL_INVALID_OPERATION` is generated if `pipeline` is not a name previously returned from a call
to glGenProgramPipelines or if such a name has been deleted by a call to
glDeleteProgramPipelines.

`GL_INVALID_OPERATION` is generated if `program` refers to a program object that has not been
successfully linked.
---
### Version Support
`glActiveShaderProgram`
---
### See Also
glGenProgramPipelines, glDeleteProgramPipelines, glIsProgramPipeline, glUseProgram,
glUniform
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Select active texture unit
---
### Parameters
`texture` Specifies which texture unit to make active. The number of texture units is
implementation dependent, but must be at least 80. `texture` must be one of `GL_TEXTURE` i,
where i ranges from zero to the value of `GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS` minus one. The
initial value is `GL_TEXTURE0`.

---
### Description
`glActiveTexture` selects which texture unit subsequent texture state calls will affect. The
number of texture units an implementation supports is implementation dependent, but must be at least
80.
---
### Errors
`GL_INVALID_ENUM` is generated if `texture` is not one of `GL_TEXTURE` i, where i ranges
from zero to the value of `GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS` minus one.
---
### Associated Gets
glGet with argument `GL_ACTIVE_TEXTURE`, or `GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS`.
---
### Version Support
`glActiveTexture`
---
### See Also
glGenTextures, glBindTexture, glCompressedTexImage1D, glCompressedTexImage2D,
glCompressedTexImage3D, glCompressedTexSubImage1D, glCompressedTexSubImage2D,
glCompressedTexSubImage3D, glCopyTexImage1D, glCopyTexImage2D, glCopyTexSubImage1D,
glCopyTexSubImage2D, glCopyTexSubImage3D, glDeleteTextures glIsTexture, glTexImage1D,
glTexImage2D, glTexImage2DMultisample, glTexImage3D, glTexImage3DMultisample,
glTexSubImage1D, glTexSubImage2D, glTexSubImage3D, glTexParameter,
---
### Copyright
Copyright 1991-2006 Silicon Graphics, Inc. Copyright 2010-2014 Khronos Group. This document
is licensed under the SGI Free Software B License. For details, see
https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.
]],
  [[Attaches a shader object to a program object
---
### Parameters
`program` Specifies the program object to which a shader object will be attached.
`shader` Specifies the shader object that is to be attached.
---
### Description
In order to create a complete shader program, there must be a way to specify the list of things
that will be linked together. Program objects provide this mechanism. Shaders that are to be linked
together in a program object must first be attached to that program object. `glAttachShader`
attaches the shader object specified by `shader` to the program object specified by `program`.

This indicates that `shader` will be included in link operations that will be performed on
`program`.

All operations that can be performed on a shader object are valid whether or not the shader object
is attached to a program object. It is permissible to attach a shader object to a program object
before source code has been loaded into the shader object or before the shader object has been
compiled. It is permissible to attach multiple shader objects of the same type because each may
contain a portion of the complete shader. It is also permissible to attach a shader object to more
than one program object. If a shader object is deleted while it is attached to a program object, it
will be flagged for deletion, and deletion will not occur until glDetachShader is called to
detach it from all program objects to which it is attached.
---
### Errors
`GL_INVALID_VALUE` is generated if either `program` or `shader` is not a value generated by
OpenGL.

`GL_INVALID_OPERATION` is generated if `program` is not a program object.

`GL_INVALID_OPERATION` is generated if `shader` is not a shader object.

`GL_INVALID_OPERATION` is generated if `shader` is already attached to `program`.
---
### Associated Gets
glGetAttachedShaders with the handle of a valid program object

glGetShaderInfoLog

glGetShaderSource

glIsProgram

glIsShader
---
### Version Support
`glAttachShader`
---
### See Also
glCompileShader, glCreateShader, glDeleteShader, glDetachShader, glLinkProgram,
glShaderSource
---
### Copyright
Copyright 2003-2005 3Dlabs Inc. Ltd. Copyright 2010-2014 Khronos Group. This material may be
distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8
June 1999. https://opencontent.org/openpub/.
]],
  [[Configures element array buffer binding of a vertex array object
---
### Parameters
`vaobj` Specifies the name of the vertex array object.
`buffer` Specifies the name of the buffer object to use for the element array buffer binding.
---
### Description
`glVertexArrayElementBuffer` binds a buffer object with id `buffer` to the element array buffer
bind point of a vertex array object with id `vaobj`. If `buffer` is zero, any existing element
array buffer binding to `vaobj` is removed.
---
### Associated Gets
glGet with argument `GL_ELEMENT_ARRAY_BUFFER_BINDING`.

glGetVertexArrayiv with argument `GL_ELEMENT_ARRAY_BUFFER_BINDING`.
---
### Errors
`GL_INVALID_OPERATION` error is generated if `vaobj` is not the name of an existing vertex
array object.

`GL_INVALID_OPERATION` error is generated if `buffer` is not zero or the name of an existing
buffer object.
---
### Version Support
`glVertexArrayElementBuffer`
---
### See Also
glGet, glGetVertexArrayiv
---
### Copyright
Copyright 2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Validate a program pipeline object against current GL state
---
### Parameters
`pipeline` Specifies the name of a program pipeline object to validate.
---
### Description
`glValidateProgramPipeline` instructs the implementation to validate the shader executables
contained in `pipeline` against the current GL state. The implementation may use this as an
opportunity to perform any internal shader modifications that may be required to ensure correct
operation of the installed shaders given the current GL state.

After a program pipeline has been validated, its validation status is set to `GL_TRUE`. The
validation status of a program pipeline object may be queried by calling glGetProgramPipeline
with parameter `GL_VALIDATE_STATUS`.

If `pipeline` is a name previously returned from a call to glGenProgramPipelines but that has
not yet been bound by a call to glBindProgramPipeline, a new program pipeline object is created
with name `pipeline` and the default state vector.
---
### Errors
`GL_INVALID_OPERATION` is generated if `pipeline` is not a name previously returned from a call
to glGenProgramPipelines or if such a name has been deleted by a call to
glDeleteProgramPipelines.
---
### Associated Gets
glGetProgramPipeline with parameter `GL_VALIDATE_STATUS`.
---
### Version Support
`glValidateProgramPipeline`
---
### See Also
glGenProgramPipelines, glBindProgramPipeline, glDeleteProgramPipelines
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Validates a program object
---
### Parameters
`program` Specifies the handle of the program object to be validated.
---
### Description
`glValidateProgram` checks to see whether the executables contained in `program` can execute
given the current OpenGL state. The information generated by the validation process will be stored
in `program` 's information log. The validation information may consist of an empty string, or it
may be a string containing information about how the current program object interacts with the rest
of current OpenGL state. This provides a way for OpenGL implementers to convey more information
about why the current program is inefficient, suboptimal, failing to execute, and so on.

The status of the validation operation will be stored as part of the program object's state. This
value will be set to `GL_TRUE` if the validation succeeded, and `GL_FALSE` otherwise. It can be
queried by calling glGetProgram with arguments `program` and `GL_VALIDATE_STATUS`. If
validation is successful, `program` is guaranteed to execute given the current state. Otherwise,
`program` is guaranteed to not execute.

This function is typically useful only during application development. The informational string
stored in the information log is completely implementation dependent; therefore, an application
should not expect different OpenGL implementations to produce identical information strings.
---
### Notes
This function mimics the validation operation that OpenGL implementations must perform when
rendering commands are issued while programmable shaders are part of current state. The error
`GL_INVALID_OPERATION` will be generated by any command that triggers the rendering of geometry if:

any two active samplers in the current program object are of different types, but refer to the
same texture image unit, the number of active samplers in the program exceeds the maximum number of
texture image units allowed. It may be difficult or cause a performance degradation for applications
to catch these errors when rendering commands are issued. Therefore, applications are advised to
make calls to `glValidateProgram` to detect these issues during application development.
---
### Errors
`GL_INVALID_VALUE` is generated if `program` is not a value generated by OpenGL.

`GL_INVALID_OPERATION` is generated if `program` is not a program object.
---
### Associated Gets
glGetProgram with arguments `program` and `GL_VALIDATE_STATUS`

glGetProgramInfoLog with argument `program`

glIsProgram
---
### Version Support
`glValidateProgram`
---
### See Also
glLinkProgram, glUseProgram
---
### Copyright
Copyright 2003-2005 3Dlabs Inc. Ltd. Copyright 2010-2014 Khronos Group. This material may be
distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8
June 1999. https://opencontent.org/openpub/.
]],
  [[Bind stages of a program object to a program pipeline
---
### Parameters
`pipeline` Specifies the program pipeline object to which to bind stages from `program`.

`stages` Specifies a set of program stages to bind to the program pipeline object.
`program` Specifies the program object containing the shader executables to use in `pipeline`.

---
### Description
`glUseProgramStages` binds executables from a program object associated with a specified set of
shader stages to the program pipeline object given by `pipeline`. `pipeline` specifies the
program pipeline object to which to bind the executables. `stages` contains a logical combination
of bits indicating the shader stages to use within `program` with the program pipeline object
`pipeline`. `stages` must be a logical combination of `GL_VERTEX_SHADER_BIT`,
`GL_TESS_CONTROL_SHADER_BIT`, `GL_TESS_EVALUATION_SHADER_BIT`, `GL_GEOMETRY_SHADER_BIT`,
`GL_FRAGMENT_SHADER_BIT` and `GL_COMPUTE_SHADER_BIT`. Additionally, the special value
`GL_ALL_SHADER_BITS` may be specified to indicate that all executables contained in `program`
should be installed in `pipeline`.

If `program` refers to a program object with a valid shader attached for an indicated shader
stage, `glUseProgramStages` installs the executable code for that stage in the indicated program
pipeline object `pipeline`. If `program` is zero, or refers to a program object with no valid
shader executable for a given stage, it is as if the pipeline object has no programmable stage
configured for the indicated shader stages. If `stages` contains bits other than those listed
above, and is not equal to `GL_ALL_SHADER_BITS`, an error is generated.
---
### Notes
The `GL_COMPUTE_SHADER_BIT` bit is available only if the GL version is 4.3 or greater.
---
### Errors
`GL_INVALID_VALUE` is generated if `shaders` contains set bits that are not recognized, and is
not the reserved value `GL_ALL_SHADER_BITS`.

`GL_INVALID_OPERATION` is generated if `program` refers to a program object that was not linked
with its `GL_PROGRAM_SEPARABLE` status set.

`GL_INVALID_OPERATION` is generated if `program` refers to a program object that has not been
successfully linked.

`GL_INVALID_OPERATION` is generated if `pipeline` is not a name previously returned from a call
to glGenProgramPipelines or if such a name has been deleted by a call to
glDeleteProgramPipelines.
---
### Version Support
`glUseProgramStages`
---
### See Also
glGenProgramPipelines, glDeleteProgramPipelines, glIsProgramPipeline
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Installs a program object as part of current rendering state
---
### Parameters
`program` Specifies the handle of the program object whose executables are to be used as part
of current rendering state.
---
### Description
`glUseProgram` installs the program object specified by `program` as part of current rendering
state. One or more executables are created in a program object by successfully attaching shader
objects to it with glAttachShader, successfully compiling the shader objects with
glCompileShader, and successfully linking the program object with glLinkProgram.

A program object will contain an executable that will run on the vertex processor if it contains
one or more shader objects of type `GL_VERTEX_SHADER` that have been successfully compiled and
linked. A program object will contain an executable that will run on the geometry processor if it
contains one or more shader objects of type `GL_GEOMETRY_SHADER` that have been successfully
compiled and linked. Similarly, a program object will contain an executable that will run on the
fragment processor if it contains one or more shader objects of type `GL_FRAGMENT_SHADER` that
have been successfully compiled and linked.

While a program object is in use, applications are free to modify attached shader objects, compile
attached shader objects, attach additional shader objects, and detach or delete shader objects. None
of these operations will affect the executables that are part of the current state. However,
relinking the program object that is currently in use will install the program object as part of the
current rendering state if the link operation was successful (see glLinkProgram ). If the program
object currently in use is relinked unsuccessfully, its link status will be set to `GL_FALSE`, but
the executables and associated state will remain part of the current state until a subsequent call
to `glUseProgram` removes it from use. After it is removed from use, it cannot be made part of
current state until it has been successfully relinked.

If `program` is zero, then the current rendering state refers to an invalid program object and
the results of shader execution are undefined. However, this is not an error.

If `program` does not contain shader objects of type `GL_FRAGMENT_SHADER`, an executable will
be installed on the vertex, and possibly geometry processors, but the results of fragment shader
execution will be undefined.
---
### Notes
Like buffer and texture objects, the name space for program objects may be shared across a set of
contexts, as long as the server sides of the contexts share the same address space. If the name
space is shared across contexts, any attached objects and the data associated with those attached
objects are shared as well. Applications are responsible for providing the synchronization across
API calls when objects are accessed from different execution threads.
---
### Errors
`GL_INVALID_VALUE` is generated if `program` is neither 0 nor a value generated by OpenGL.

`GL_INVALID_OPERATION` is generated if `program` is not a program object.

`GL_INVALID_OPERATION` is generated if `program` could not be made part of current state.

`GL_INVALID_OPERATION` is generated if transform feedback mode is active.
---
### Associated Gets
glGet with the argument `GL_CURRENT_PROGRAM`

glGetActiveAttrib with a valid program object and the index of an active attribute variable

glGetActiveUniform with a valid program object and the index of an active uniform variable

glGetAttachedShaders with a valid program object

glGetAttribLocation with a valid program object and the name of an attribute variable

glGetProgram with a valid program object and the parameter to be queried

glGetProgramInfoLog with a valid program object

glGetUniform with a valid program object and the location of a uniform variable

glGetUniformLocation with a valid program object and the name of a uniform variable

glIsProgram
---
### Version Support
`glUseProgram`
---
### See Also
glAttachShader, glBindAttribLocation, glCompileShader, glCreateProgram,
glDeleteProgram, glDetachShader, glLinkProgram, glUniform, glValidateProgram,
glVertexAttrib
---
### Copyright
Copyright 2003-2005 3Dlabs Inc. Ltd. Copyright 2010-2014 Khronos Group. This material may be
distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8
June 1999. https://opencontent.org/openpub/.
]],
  [[Release the mapping of a buffer object's data store into the client's address space
---
### Parameters
`target` Specifies the target to which the buffer object is bound for `glUnmapBuffer`, which
must be one of the buffer binding targets in the following table:

`buffer` Specifies the name of the buffer object for `glUnmapNamedBuffer`.

---
### Description
`glUnmapBuffer` and `glUnmapNamedBuffer` unmap (release) any mapping of a specified buffer
object into the client's address space (see glMapBufferRange and glMapBuffer ).

If a mapping is not unmapped before the corresponding buffer object's data store is used by the
GL, an error will be generated by any GL command that attempts to dereference the buffer object's
data store, unless the buffer was successfully mapped with `GL_MAP_PERSISTENT_BIT` (see
glMapBufferRange ). When a data store is unmapped, the mapped pointer becomes invalid.

`glUnmapBuffer` returns `GL_TRUE` unless the data store contents have become corrupt during the
time the data store was mapped. This can occur for system-specific reasons that affect the
availability of graphics memory, such as screen mode changes. In such situations, `GL_FALSE` is
returned and the data store contents are undefined. An application must detect this rare condition
and reinitialize the data store.

A buffer object's mapped data store is automatically unmapped when the buffer object is deleted or
its data store is recreated with glBufferData ).
---
### Notes
If an error is generated, `glUnmapBuffer` returns `GL_FALSE`.

The `GL_ATOMIC_COUNTER_BUFFER` target is accepted only if the GL version is 4.2 or greater.

The `GL_DISPATCH_INDIRECT_BUFFER` and `GL_SHADER_STORAGE_BUFFER` targets are available only if
the GL version is 4.3 or greater.

The `GL_QUERY_BUFFER` target is available only if the GL version is 4.4 or greater.
---
### Errors
`GL_INVALID_ENUM` is generated by `glUnmapBuffer` if `target` is not one of the buffer
binding targets listed above.

`GL_INVALID_OPERATION` is generated by `glUnmapBuffer` if zero is bound to `target`.

`GL_INVALID_OPERATION` is generated by `glUnmapNamedBuffer` if `buffer` is not the name of an
existing buffer object.

`GL_INVALID_OPERATION` is generated if the buffer object is not in a mapped state.
---
### Associated Gets
glGetBufferParameter with argument `GL_BUFFER_MAPPED`.
---
### Version Support
`glUnmapBuffer` `glUnmapNamedBuffer`
---
### See Also
glBufferData, glDeleteBuffers, glMapBuffer, glMapBufferRange
---
### Copyright
Copyright 2005 Addison-Wesley. Copyright 2010-2014 Khronos Group. This material may be
distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8
June 1999. https://opencontent.org/openpub/.
]],
  [[Load active subroutine uniforms
---
### Parameters
`shadertype` Specifies the shader stage from which to query for subroutine uniform index.
`shadertype` must be one of `GL_VERTEX_SHADER`, `GL_TESS_CONTROL_SHADER`,
`GL_TESS_EVALUATION_SHADER`, `GL_GEOMETRY_SHADER` or `GL_FRAGMENT_SHADER`.

`count` Specifies the number of uniform indices stored in `indices`.

`indices` Specifies the address of an array holding the indices to load into the shader
subroutine variables.
---
### Description
`glUniformSubroutines` loads all active subroutine uniforms for shader stage `shadertype` of
the current program with subroutine indices from `indices`, storing `indices[i]` into the
uniform at location `i`. `count` must be equal to the value of
`GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS` for the program currently in use at shader stage
`shadertype`. Furthermore, all values in `indices` must be less than the value of
`GL_ACTIVE_SUBROUTINES` for the shader stage.
---
### Errors
`GL_INVALID_OPERATION` is generated if no program object is current.

`GL_INVALID_VALUE` is generated if `count` is not equal to the value of
`GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS` for the shader stage `shadertype` of the current
program.

`GL_INVALID_VALUE` is generated if any value in `indices` is geater than or equal to the value
of `GL_ACTIVE_SUBROUTINES` for the shader stage `shadertype` of the current program.

`GL_INVALID_ENUM` is generated if `shadertype` is not one of the accepted values.
---
### Associated Gets
glGetProgramStage with argument `GL_ACTIVE_SUBROUTINES`

glGetProgramStage with argument `GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS`
---
### Version Support
`glUniformSubroutinesuiv`
---
### See Also
glGetProgram, glGetActiveSubroutineUniform, glGetActiveSubroutineUniformName,
glGetProgramStage
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Assign a binding point to an active uniform block
---
### Parameters
`program` The name of a program object containing the active uniform block whose binding to
assign.
`uniformBlockIndex` The index of the active uniform block within `program` whose binding to
assign.

`uniformBlockBinding` Specifies the binding point to which to bind the uniform block with index
`uniformBlockIndex` within `program`.

---
### Description
Binding points for active uniform blocks are assigned using `glUniformBlockBinding`. Each of a
program's active uniform blocks has a corresponding uniform buffer binding point. `program` is the
name of a program object for which the command glLinkProgram has been issued in the past.

If successful, `glUniformBlockBinding` specifies that `program` will use the data store of the
buffer object bound to the binding point `uniformBlockBinding` to extract the values of the
uniforms in the uniform block identified by `uniformBlockIndex`.

When a program object is linked or re-linked, the uniform buffer object binding point assigned to
each of its active uniform blocks is reset to zero.
---
### Errors
`GL_INVALID_VALUE` is generated if `uniformBlockIndex` is not an active uniform block index of
`program`.

`GL_INVALID_VALUE` is generated if `uniformBlockBinding` is greater than or equal to the value
of `GL_MAX_UNIFORM_BUFFER_BINDINGS`.

`GL_INVALID_VALUE` is generated if `program` is not the name of a program object generated by
the GL.
---
### Notes
`glUniformBlockBinding` is available only if the GL version is 3.1 or greater.
---
### Associated Gets
glGetActiveUniformBlock with argument `GL_UNIFORM_BLOCK_BINDING`
---
### Version Support
`glUniformBlockBinding`
---
### See Also
glLinkProgram, glBindBufferBase, glBindBufferRange, glGetActiveUniformBlock
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Establish the data storage, format, dimensions, and number of samples of a multisample texture's
image
---
### Parameters
`target` Specifies the target of the operation. `target` must be
`GL_TEXTURE_2D_MULTISAMPLE_ARRAY` or `GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY`.

`samples` The number of samples in the multisample texture's image.
`internalformat` The internal format to be used to store the multisample texture's image.
`internalformat` must specify a color-renderable, depth-renderable, or stencil-renderable format.

`width` The width of the multisample texture's image, in texels.
`height` The height of the multisample texture's image, in texels.
`fixedsamplelocations` Specifies whether the image will use identical sample locations and the
same number of samples for all texels in the image, and the sample locations will not depend on the
internal format or size of the image.
---
### Description
`glTexImage3DMultisample` establishes the data storage, format, dimensions and number of samples
of a multisample texture's image.

`target` must be `GL_TEXTURE_2D_MULTISAMPLE_ARRAY` or `GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY`.
`width` and `height` are the dimensions in texels of the texture, and must be in the range zero
to the value of `GL_MAX_TEXTURE_SIZE` minus one. `depth` is the number of array slices in the
array texture's image. `samples` specifies the number of samples in the image and must be in the
range zero to the value of `GL_MAX_SAMPLES` minus one.

`internalformat` must be a color-renderable, depth-renderable, or stencil-renderable format.

If `fixedsamplelocations` is `GL_TRUE`, the image will use identical sample locations and the
same number of samples for all texels in the image, and the sample locations will not depend on the
internal format or size of the image.

When a multisample texture is accessed in a shader, the access takes one vector of integers
describing which texel to fetch and an integer corresponding to the sample numbers describing which
sample within the texel to fetch. No standard sampling instructions are allowed on the multisample
texture targets.
---
### Notes
`glTexImage2DMultisample` is available only if the GL version is 3.2 or greater.
---
### Errors
`GL_INVALID_OPERATION` is generated if `internalformat` is a depth- or stencil-renderable
format and `samples` is greater than the value of `GL_MAX_DEPTH_TEXTURE_SAMPLES`.

`GL_INVALID_OPERATION` is generated if `internalformat` is a color-renderable format and
`samples` is greater than the value of `GL_MAX_COLOR_TEXTURE_SAMPLES`.

`GL_INVALID_OPERATION` is generated if `internalformat` is a signed or unsigned integer format
and `samples` is greater than the value of `GL_MAX_INTEGER_SAMPLES`.

`GL_INVALID_VALUE` is generated if either `width` or `height` negative or is greater than
`GL_MAX_TEXTURE_SIZE`.

`GL_INVALID_VALUE` is generated if `depth` is negative or is greater than
`GL_MAX_ARRAY_TEXTURE_LAYERS`.

`GL_INVALID_VALUE` is generated if `samples` is zero.

`GL_INVALID_OPERATION` is generated if `samples` is greater than the maximum number of samples
supported for this `target` and `internalformat`.
---
### Version Support
`glTexImage3DMultisample`
---
### See Also
glTexImage3D, glTexImage2DMultisample
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Establish the data storage, format, dimensions, and number of samples of a multisample texture's
image
---
### Parameters
`target` Specifies the target of the operation. `target` must be
`GL_TEXTURE_2D_MULTISAMPLE` or `GL_PROXY_TEXTURE_2D_MULTISAMPLE`.

`samples` The number of samples in the multisample texture's image.
`internalformat` The internal format to be used to store the multisample texture's image.
`internalformat` must specify a color-renderable, depth-renderable, or stencil-renderable format.

`width` The width of the multisample texture's image, in texels.
`height` The height of the multisample texture's image, in texels.
`fixedsamplelocations` Specifies whether the image will use identical sample locations and the
same number of samples for all texels in the image, and the sample locations will not depend on the
internal format or size of the image.
---
### Description
`glTexImage2DMultisample` establishes the data storage, format, dimensions and number of samples
of a multisample texture's image.

`target` must be `GL_TEXTURE_2D_MULTISAMPLE` or `GL_PROXY_TEXTURE_2D_MULTISAMPLE`. `width`
and `height` are the dimensions in texels of the texture, and must be in the range zero to the
value of `GL_MAX_TEXTURE_SIZE` minus one. `samples` specifies the number of samples in the image
and must be in the range zero to the value of `GL_MAX_SAMPLES` minus one.

`internalformat` must be a color-renderable, depth-renderable, or stencil-renderable format.

If `fixedsamplelocations` is `GL_TRUE`, the image will use identical sample locations and the
same number of samples for all texels in the image, and the sample locations will not depend on the
internal format or size of the image.

When a multisample texture is accessed in a shader, the access takes one vector of integers
describing which texel to fetch and an integer corresponding to the sample numbers describing which
sample within the texel to fetch. No standard sampling instructions are allowed on the multisample
texture targets.
---
### Notes
`glTexImage2DMultisample` is available only if the GL version is 3.2 or greater.
---
### Errors
`GL_INVALID_OPERATION` is generated if `internalformat` is a depth- or stencil-renderable
format and `samples` is greater than the value of `GL_MAX_DEPTH_TEXTURE_SAMPLES`.

`GL_INVALID_OPERATION` is generated if `internalformat` is a color-renderable format and
`samples` is greater than the value of `GL_MAX_COLOR_TEXTURE_SAMPLES`.

`GL_INVALID_OPERATION` is generated if `internalformat` is a signed or unsigned integer format
and `samples` is greater than the value of `GL_MAX_INTEGER_SAMPLES`.

`GL_INVALID_VALUE` is generated if either `width` or `height` negative or is greater than
`GL_MAX_TEXTURE_SIZE`.

`GL_INVALID_VALUE` is generated if `samples` is zero.

`GL_INVALID_OPERATION` is generated if `samples` is greater than the maximum number of samples
supported for this `target` and `internalformat`.
---
### Version Support
`glTexImage2DMultisample`
---
### See Also
glTexImage3D, glTexImage2DMultisample
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Specify a one-dimensional texture image
---
### Parameters
`target` Specifies the target texture. Must be `GL_TEXTURE_1D` or `GL_PROXY_TEXTURE_1D`.

`level` Specifies the level-of-detail number. Level 0 is the base image level. Level n is the
n th mipmap reduction image.

`internalformat` Specifies the number of color components in the texture. Must be one of base
internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the
compressed internal formats given in Table 3, below.
`width` Specifies the width of the texture image. All implementations support texture images
that are at least 1024 texels wide. The height of the 1D texture image is 1.
`border` This value must be 0.
`format` Specifies the format of the pixel data. The following symbolic values are accepted:
`GL_RED`, `GL_RG`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, `GL_BGRA`, `GL_RED_INTEGER`,
`GL_RG_INTEGER`, `GL_RGB_INTEGER`, `GL_BGR_INTEGER`, `GL_RGBA_INTEGER`, `GL_BGRA_INTEGER`,
`GL_STENCIL_INDEX`, `GL_DEPTH_COMPONENT`, `GL_DEPTH_STENCIL`.

`type` Specifies the data type of the pixel data. The following symbolic values are accepted:
`GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`,
`GL_INT`, `GL_HALF_FLOAT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`,
`GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`,
`GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`,
`GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`,
`GL_UNSIGNED_INT_10_10_10_2`, and `GL_UNSIGNED_INT_2_10_10_10_REV`.

`data` Specifies a pointer to the image data in memory.
]],
  [[Specify a two-dimensional texture image
---
### Parameters
`target` Specifies the target texture. Must be `GL_TEXTURE_2D`, `GL_PROXY_TEXTURE_2D`,
`GL_TEXTURE_1D_ARRAY`, `GL_PROXY_TEXTURE_1D_ARRAY`, `GL_TEXTURE_RECTANGLE`,
`GL_PROXY_TEXTURE_RECTANGLE`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`,
`GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`,
`GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`, or
`GL_PROXY_TEXTURE_CUBE_MAP`.

`level` Specifies the level-of-detail number. Level 0 is the base image level. Level n is the
n th mipmap reduction image. If `target` is `GL_TEXTURE_RECTANGLE` or
`GL_PROXY_TEXTURE_RECTANGLE`, `level` must be 0.

`internalformat` Specifies the number of color components in the texture. Must be one of base
internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the
compressed internal formats given in Table 3, below.
`width` Specifies the width of the texture image. All implementations support texture images
that are at least 1024 texels wide.
`height` Specifies the height of the texture image, or the number of layers in a texture array,
in the case of the `GL_TEXTURE_1D_ARRAY` and `GL_PROXY_TEXTURE_1D_ARRAY` targets. All
implementations support 2D texture images that are at least 1024 texels high, and texture arrays
that are at least 256 layers deep.

`border` This value must be 0.
`format` Specifies the format of the pixel data. The following symbolic values are accepted:
`GL_RED`, `GL_RG`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, `GL_BGRA`, `GL_RED_INTEGER`,
`GL_RG_INTEGER`, `GL_RGB_INTEGER`, `GL_BGR_INTEGER`, `GL_RGBA_INTEGER`, `GL_BGRA_INTEGER`,
`GL_STENCIL_INDEX`, `GL_DEPTH_COMPONENT`, `GL_DEPTH_STENCIL`.

`type` Specifies the data type of the pixel data. The following symbolic values are accepted:
`GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`,
`GL_INT`, `GL_HALF_FLOAT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`,
`GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`,
`GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`,
`GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`,
`GL_UNSIGNED_INT_10_10_10_2`, and `GL_UNSIGNED_INT_2_10_10_10_REV`.

`data` Specifies a pointer to the image data in memory.
]],
  [[Specify a three-dimensional texture image
---
### Parameters
`target` Specifies the target texture. Must be one of `GL_TEXTURE_3D`,
`GL_PROXY_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY` or `GL_PROXY_TEXTURE_2D_ARRAY`.

`level` Specifies the level-of-detail number. Level 0 is the base image level. Level n is
the n th mipmap reduction image.

`internalformat` Specifies the number of color components in the texture. Must be one of base
internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the
compressed internal formats given in Table 3, below.
`width` Specifies the width of the texture image. All implementations support 3D texture images
that are at least 16 texels wide.
`height` Specifies the height of the texture image. All implementations support 3D texture
images that are at least 256 texels high.
`depth` Specifies the depth of the texture image, or the number of layers in a texture array.

All implementations support 3D texture images that are at least 256 texels deep, and texture arrays
that are at least 256 layers deep.
`border` This value must be 0.
`format` Specifies the format of the pixel data. The following symbolic values are accepted:
`GL_RED`, `GL_RG`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, `GL_BGRA`, `GL_RED_INTEGER`,
`GL_RG_INTEGER`, `GL_RGB_INTEGER`, `GL_BGR_INTEGER`, `GL_RGBA_INTEGER`, `GL_BGRA_INTEGER`,
`GL_STENCIL_INDEX`, `GL_DEPTH_COMPONENT`, `GL_DEPTH_STENCIL`.

`type` Specifies the data type of the pixel data. The following symbolic values are accepted:
`GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`,
`GL_INT`, `GL_HALF_FLOAT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`,
`GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`,
`GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`,
`GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`,
`GL_UNSIGNED_INT_10_10_10_2`, and `GL_UNSIGNED_INT_2_10_10_10_REV`.

`data` Specifies a pointer to the image data in memory.
]],
  [[Specify the value used for depth buffer comparisons
---
### Parameters
`func` Specifies the depth comparison function. Symbolic constants `GL_NEVER`, `GL_LESS`,
`GL_EQUAL`, `GL_LEQUAL`, `GL_GREATER`, `GL_NOTEQUAL`, `GL_GEQUAL`, and `GL_ALWAYS` are
accepted. The initial value is `GL_LESS`.

---
### Description
`glDepthFunc` specifies the function used to compare each incoming pixel depth value with the
depth value present in the depth buffer. The comparison is performed only if depth testing is
enabled. (See glEnable and `glDisable` of `GL_DEPTH_TEST` .)

`func` specifies the conditions under which the pixel will be drawn. The comparison functions are
as follows:

`GL_NEVER` Never passes.
`GL_LESS` Passes if the incoming depth value is less than the stored depth value.
`GL_EQUAL` Passes if the incoming depth value is equal to the stored depth value.
`GL_LEQUAL` Passes if the incoming depth value is less than or equal to the stored depth value.

`GL_GREATER` Passes if the incoming depth value is greater than the stored depth value.
`GL_NOTEQUAL` Passes if the incoming depth value is not equal to the stored depth value.
`GL_GEQUAL` Passes if the incoming depth value is greater than or equal to the stored depth
value.
`GL_ALWAYS` Always passes.

The initial value of `func` is `GL_LESS`. Initially, depth testing is disabled. If depth
testing is disabled or if no depth buffer exists, it is as if the depth test always passes.
---
### Notes
Even if the depth buffer exists and the depth mask is non-zero, the depth buffer is not updated if
the depth test is disabled. In order to unconditionally write to the depth buffer, the depth test
should be enabled and set to `GL_ALWAYS`.
---
### Errors
`GL_INVALID_ENUM` is generated if `func` is not an accepted value.
---
### Associated Gets
glGet with argument `GL_DEPTH_FUNC`

glIsEnabled with argument `GL_DEPTH_TEST`
---
### Version Support
`glDepthFunc`
---
### See Also
glDepthRange, glEnable, glPolygonOffset
---
### Copyright
Copyright 1991-2006 Silicon Graphics, Inc. Copyright 2010-2014 Khronos Group. This document
is licensed under the SGI Free Software B License. For details, see
https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.
]],
  [[Specify mapping of depth values from normalized device coordinates to window coordinates
---
### Parameters
`nearVal` Specifies the mapping of the near clipping plane to window coordinates. The initial
value is 0.
`farVal` Specifies the mapping of the far clipping plane to window coordinates. The initial
value is 1.
---
### Description
After clipping and division by w, depth coordinates range from -1 to 1, corresponding to the
near and far clipping planes. `glDepthRange` specifies a linear mapping of the normalized depth
coordinates in this range to window depth coordinates. Regardless of the actual depth buffer
implementation, window coordinate depth values are treated as though they range from 0 through 1
(like color components). Thus, the values accepted by `glDepthRange` are both clamped to this
range before they are accepted.

The setting of (0,1) maps the near plane to 0 and the far plane to 1. With this mapping, the depth
buffer range is fully utilized.
---
### Notes
It is not necessary that `nearVal` be less than `farVal`. Reverse mappings such as nearVal
= 1, and farVal = 0 are acceptable.

The type of the `nearVal` and `farVal` parameters was changed from GLclampf to GLfloat for
`glDepthRangef` and from GLclampd to GLdouble for `glDepthRange`. This change is transparent to
user code and is described in detail on the removedTypes page.
---
### Associated Gets
glGet with argument `GL_DEPTH_RANGE`
---
### Version Support
`glDepthRange` `glDepthRangef`
---
### See Also
glDepthFunc, glPolygonOffset, glViewport, removedTypes
---
### Copyright
Copyright 1991-2006 Silicon Graphics, Inc. Copyright 2010-2014 Khronos Group. This document
is licensed under the SGI Free Software B License. For details, see
https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.
]],
  [[Enable or disable writing into the depth buffer
---
### Parameters
`flag` Specifies whether the depth buffer is enabled for writing. If `flag` is `GL_FALSE`,
depth buffer writing is disabled. Otherwise, it is enabled. Initially, depth buffer writing is
enabled.

---
### Description
`glDepthMask` specifies whether the depth buffer is enabled for writing. If `flag` is
`GL_FALSE`, depth buffer writing is disabled. Otherwise, it is enabled. Initially, depth buffer
writing is enabled.
---
### Associated Gets
glGet with argument `GL_DEPTH_WRITEMASK`
---
### Notes
Even if the depth buffer exists and the depth mask is non-zero, the depth buffer is not updated if
the depth test is disabled. In order to unconditionally write to the depth buffer, the depth test
should be enabled and set to `GL_ALWAYS` (see glDepthFunc ).
---
### Version Support
`glDepthMask`
---
### See Also
glColorMask, glDepthFunc, glDepthRange, glStencilMask
---
### Copyright
Copyright 1991-2006 Silicon Graphics, Inc. Copyright 2010-2014 Khronos Group. This document
is licensed under the SGI This document is licensed under the SGI Free Software B License. For
details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.
]],
  [[Delete vertex array objects
---
### Parameters
`n` Specifies the number of vertex array objects to be deleted.
`arrays` Specifies the address of an array containing the `n` names of the objects to be
deleted.

---
### Description
`glDeleteVertexArrays` deletes `n` vertex array objects whose names are stored in the array
addressed by `arrays`. Once a vertex array object is deleted it has no contents and its name is
again unused. If a vertex array object that is currently bound is deleted, the binding for that
object reverts to zero and the default vertex array becomes current. Unused names in `arrays` are
silently ignored, as is the value zero.
---
### Errors
`GL_INVALID_VALUE` is generated if `n` is negative.
---
### Version Support
`glDeleteVertexArrays`
---
### See Also
glGenVertexArrays, glIsVertexArray, glBindVertexArray
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Set sampler parameters
---
### Parameters
`sampler` Specifies the sampler object whose parameter to modify.
`pname` Specifies the symbolic name of a sampler parameter. `pname` can be one of the
following: `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`,
`GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_BORDER_COLOR`,
`GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_LOD_BIAS` `GL_TEXTURE_COMPARE_MODE`, or
`GL_TEXTURE_COMPARE_FUNC`.

`param` For the scalar commands, specifies the value of `pname`.

`params` For the vector commands ( `glSamplerParameter*v` ), specifies a pointer to an array
where the value or values of `pname` are stored.
]],
  [[Delete transform feedback objects
---
### Parameters
`n` Specifies the number of transform feedback objects to delete.
`ids` Specifies an array of names of transform feedback objects to delete.
---
### Description
`glDeleteTransformFeedbacks` deletes the `n` transform feedback objects whose names are stored
in the array `ids`. Unused names in `ids` are ignored, as is the name zero. After a transform
feedback object is deleted, its name is again unused and it has no contents. If an active transform
feedback object is deleted, its name immediately becomes unused, but the underlying object is not
deleted until it is no longer active.
---
### Associated Gets
glGet with argument `GL_TRANSFORM_FEEDBACK_BINDING`
---
### Version Support
`glDeleteTransformFeedbacks`
---
### See Also
glGenTransformFeedbacks, glBindTransformFeedback, glIsTransformFeedback,
glBeginTransformFeedback, glPauseTransformFeedback, glResumeTransformFeedback,
`glEndTransformFeedback`
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Delete a sync object
---
### Parameters
`sync` The sync object to be deleted.
---
### Description
`glDeleteSync` deletes the sync object specified by `sync`. If the fence command corresponding
to the specified sync object has completed, or if no glWaitSync or glClientWaitSync commands
are blocking on `sync`, the object is deleted immediately. Otherwise, `sync` is flagged for
deletion and will be deleted when it is no longer associated with any fence command and is no longer
blocking any glWaitSync or glClientWaitSync command. In either case, after `glDeleteSync`
returns, the name `sync` is invalid and can no longer be used to refer to the sync object.

`glDeleteSync` will silently ignore a `sync` value of zero.
---
### Notes
`glSync` is only supported if the GL version is 3.2 or greater, or if the ARB_sync extension is
supported.
---
### Errors
`GL_INVALID_VALUE` is generated if `sync` is neither zero or the name of a sync object.
---
### Version Support
`glDeleteSync`
---
### See Also
glFenceSync, glWaitSync, glClientWaitSync
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Determine if a name corresponds to a sampler object
---
### Parameters
`id` Specifies a value that may be the name of a sampler object.
---
### Description
`glIsSampler` returns `GL_TRUE` if `id` is currently the name of a sampler object. If `id`
is zero, or is a non-zero value that is not currently the name of a sampler object, or if an error
occurs, `glIsSampler` returns `GL_FALSE`.

A name returned by glGenSamplers, is the name of a sampler object.
---
### Notes
`glIsSampler` is available only if the GL version is 3.3 or higher.
---
### Version Support
`glIsSampler`
---
### See Also
glGenSamplers, glBindSampler, glDeleteSamplers
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Delete named sampler objects
---
### Parameters
`n` Specifies the number of sampler objects to be deleted.
`samplers` Specifies an array of sampler objects to be deleted.
---
### Description
`glDeleteSamplers` deletes `n` sampler objects named by the elements of the array `samplers`.

After a sampler object is deleted, its name is again unused. If a sampler object that is currently
bound to a sampler unit is deleted, it is as though glBindSampler is called with unit set to the
unit the sampler is bound to and sampler zero. Unused names in samplers are silently ignored, as is
the reserved name zero.
---
### Notes
`glDeleteSamplers` is available only if the GL version is 3.3 or higher.
---
### Errors
`GL_INVALID_VALUE` is generated if `n` is negative.
---
### Associated Gets
glIsSampler
---
### Version Support
`glDeleteSamplers`
---
### See Also
glGenSamplers, glBindSampler, glDeleteSamplers, glIsSampler
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Determines if a name corresponds to a shader object
---
### Parameters
`shader` Specifies a potential shader object.
---
### Description
`glIsShader` returns `GL_TRUE` if `shader` is the name of a shader object previously created
with glCreateShader and not yet deleted with glDeleteShader. If `shader` is zero or a
non-zero value that is not the name of a shader object, or if an error occurs, `glIsShader `
returns `GL_FALSE`.
---
### Notes
No error is generated if `shader` is not a valid shader object name.

A shader object marked for deletion with glDeleteShader but still attached to a program object
is still considered a shader object and `glIsShader` will return `GL_TRUE`.
---
### Associated Gets
glGetAttachedShaders with a valid program object

glGetShader with arguments `shader` and a parameter to be queried

glGetShaderInfoLog with argument `object`

glGetShaderSource with argument `object`
---
### Version Support
`glIsShader`
---
### See Also
glAttachShader, glCompileShader, glCreateShader, glDeleteShader, glDetachShader,
glLinkProgram, glShaderSource
---
### Copyright
Copyright 2003-2005 3Dlabs Inc. Ltd. Copyright 2010-2014 Khronos Group. This material may be
distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8
June 1999. https://opencontent.org/openpub/.
]],
  [[Specify multisample coverage parameters
---
### Parameters
`value` Specify a single floating-point sample coverage value. The value is clamped to the
range 0 1. The initial value is 1.0.

`invert` Specify a single boolean value representing if the coverage masks should be inverted.
`GL_TRUE` and `GL_FALSE` are accepted. The initial value is `GL_FALSE`.

---
### Description
Multisampling samples a pixel multiple times at various implementation-dependent subpixel
locations to generate antialiasing effects. Multisampling transparently antialiases points, lines,
polygons, and images if it is enabled. `value` is used in constructing a temporary mask used in
determining which samples will be used in resolving the final fragment color. This mask is
bitwise-anded with the coverage mask generated from the multisampling computation. If the `invert`
flag is set, the temporary mask is inverted (all bits flipped) and then the bitwise-and is computed.

If an implementation does not have any multisample buffers available, or multisampling is
disabled, rasterization occurs with only a single sample computing a pixel's final RGB color.

Provided an implementation supports multisample buffers, and multisampling is enabled, then a
pixel's final color is generated by combining several samples per pixel. Each sample contains color,
depth, and stencil information, allowing those operations to be performed on each sample.
---
### Notes
The type of the `value` parameter was changed from GLclampf to GLfloat. This change is
transparent to user code and is described in detail on the removedTypes page.
---
### Associated Gets
glGet with argument `GL_SAMPLE_COVERAGE_VALUE`

glGet with argument `GL_SAMPLE_COVERAGE_INVERT`

glIsEnabled with argument `GL_MULTISAMPLE`

glIsEnabled with argument `GL_SAMPLE_ALPHA_TO_COVERAGE`

glIsEnabled with argument `GL_SAMPLE_ALPHA_TO_ONE`

glIsEnabled with argument `GL_SAMPLE_COVERAGE`
---
### Version Support
`glSampleCoverage`
---
### See Also
glEnable, removedTypes
---
### Copyright
Copyright 1991-2006 Silicon Graphics, Inc. Copyright 2010-2014 Khronos Group. This document
is licensed under the SGI Free Software B License. For details, see
https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.
]],
  [[Determine if a name corresponds to a sync object
---
### Parameters
`sync` Specifies a value that may be the name of a sync object.
---
### Description
`glIsSync` returns `GL_TRUE` if `sync` is currently the name of a sync object. If `sync` is
not the name of a sync object, or if an error occurs, `glIsSync` returns `GL_FALSE`. Note that
zero is not the name of a sync object.
---
### Notes
`glIsSync` is available only if the GL version is 3.2 or greater.
---
### Version Support
`glIsSync`
---
### See Also
glFenceSync, glWaitSync, glClientWaitSync, glDeleteSync
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Establish data storage, format, dimensions and sample count of a renderbuffer object's image
---
### Parameters
`target` Specifies a binding target of the allocation for `glRenderbufferStorageMultisample`
function. Must be `GL_RENDERBUFFER`.

`renderbuffer` Specifies the name of the renderbuffer object for
`glNamedRenderbufferStorageMultisample` function.

`samples` Specifies the number of samples to be used for the renderbuffer object's storage.
`internalformat` Specifies the internal format to use for the renderbuffer object's image.
`width` Specifies the width of the renderbuffer, in pixels.
`height` Specifies the height of the renderbuffer, in pixels.
---
### Description
`glRenderbufferStorageMultisample` and `glNamedRenderbufferStorageMultisample` establish the
data storage, format, dimensions and number of samples of a renderbuffer object's image.

For `glRenderbufferStorageMultisample`, the target of the operation, specified by `target` must
be `GL_RENDERBUFFER`. For `glNamedRenderbufferStorageMultisample`, `renderbuffer` must be an
ID of an existing renderbuffer object. `internalformat` specifies the internal format to be used
for the renderbuffer object's storage and must be a color-renderable, depth-renderable, or
stencil-renderable format. `width` and `height` are the dimensions, in pixels, of the
renderbuffer. Both `width` and `height` must be less than or equal to the value of
`GL_MAX_RENDERBUFFER_SIZE`. `samples` specifies the number of samples to be used for the
renderbuffer object's image, and must be less than or equal to the value of `GL_MAX_SAMPLES`. If
`internalformat` is a signed or unsigned integer format then `samples` must be less than or equal
to the value of `GL_MAX_INTEGER_SAMPLES`.

Upon success, `glRenderbufferStorageMultisample` and `glNamedRenderbufferStorageMultisample`
delete any existing data store for the renderbuffer image and the contents of the data store after
calling either of the functions are undefined.
---
### Errors
`GL_INVALID_ENUM` is generated by `glRenderbufferStorageMultisample` function if `target` is
not `GL_RENDERBUFFER`.

`GL_INVALID_OPERATION` is generated by `glNamedRenderbufferStorageMultisample` function if
`renderbuffer` is not the name of an existing renderbuffer object.

`GL_INVALID_OPERATION` is generated if `samples` is greater than the maximum number of samples
supported for `internalformat`.

`GL_INVALID_ENUM` is generated if `internalformat` is not a color-renderable, depth-renderable,
or stencil-renderable format.

`GL_INVALID_OPERATION` is generated if `internalformat` is a signed or unsigned integer format
and `samples` is greater than the value of `GL_MAX_INTEGER_SAMPLES`

`GL_INVALID_VALUE` is generated if either of `width` or `height` is negative, or greater than
the value of `GL_MAX_RENDERBUFFER_SIZE`.

`GL_OUT_OF_MEMORY` is generated if the GL is unable to create a data store of the requested size.

---
### Version Support
`glNamedRenderbufferStorageMultisample` `glRenderbufferStorageMultisample`
---
### See Also
glGenRenderbuffers, glBindRenderbuffer, `glNamedRenderbufferStorage`,
glRenderbufferStorage, glFramebufferRenderbuffer, glDeleteRenderbuffers
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Determine if a name corresponds to a texture
---
### Parameters
`texture` Specifies a value that may be the name of a texture.
---
### Description
`glIsTexture` returns `GL_TRUE` if `texture` is currently the name of a texture. If
`texture` is zero, or is a non-zero value that is not currently the name of a texture, or if an
error occurs, `glIsTexture` returns `GL_FALSE`.

A name returned by glGenTextures, but not yet associated with a texture by calling
glBindTexture, is not the name of a texture.
---
### Version Support
`glIsTexture`
---
### See Also
glBindTexture, glCopyTexImage1D, glCopyTexImage2D, glDeleteTextures, glGenTextures,
glGet, glGetTexParameter, glTexImage1D, glTexImage2D, glTexImage3D, glTexParameter
---
### Copyright
Copyright 1991-2006 Silicon Graphics, Inc. Copyright 2010-2014 Khronos Group. This document
is licensed under the SGI Free Software B License. For details, see
https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.
]],
  [[Establish data storage, format and dimensions of a renderbuffer object's image
---
### Parameters
`target` Specifies a binding target of the allocation for `glRenderbufferStorage` function.

Must be `GL_RENDERBUFFER`.

`renderbuffer` Specifies the name of the renderbuffer object for `glNamedRenderbufferStorage`
function.

`internalformat` Specifies the internal format to use for the renderbuffer object's image.
`width` Specifies the width of the renderbuffer, in pixels.
`height` Specifies the height of the renderbuffer, in pixels.
---
### Description
`glRenderbufferStorage` is equivalent to calling glRenderbufferStorageMultisample with the
`samples` set to zero, and `glNamedRenderbufferStorage` is equivalent to calling
`glNamedRenderbufferStorageMultisample` with the samples set to zero.

For `glRenderbufferStorage`, the target of the operation, specified by `target` must be
`GL_RENDERBUFFER`. For `glNamedRenderbufferStorage`, `renderbuffer` must be a name of an
existing renderbuffer object. `internalformat` specifies the internal format to be used for the
renderbuffer object's storage and must be a color-renderable, depth-renderable, or
stencil-renderable format. `width` and `height` are the dimensions, in pixels, of the
renderbuffer. Both `width` and `height` must be less than or equal to the value of
`GL_MAX_RENDERBUFFER_SIZE`.

Upon success, `glRenderbufferStorage` and `glNamedRenderbufferStorage` delete any existing data
store for the renderbuffer image and the contents of the data store after calling
`glRenderbufferStorage` are undefined.
---
### Errors
`GL_INVALID_ENUM` is generated by `glRenderbufferStorage` if `target` is not
`GL_RENDERBUFFER`.

`GL_INVALID_OPERATION` is generated by glNamedRenderbufferStorage if `renderbuffer` is not the
name of an existing renderbuffer object.

`GL_INVALID_VALUE` is generated if either of `width` or `height` is negative, or greater than
the value of `GL_MAX_RENDERBUFFER_SIZE`.

`GL_INVALID_ENUM` is generated if `internalformat` is not a color-renderable, depth-renderable,
or stencil-renderable format.

`GL_OUT_OF_MEMORY` is generated if the GL is unable to create a data store of the requested size.

---
### Version Support
`glNamedRenderbufferStorage` `glRenderbufferStorage`
---
### See Also
glGenRenderbuffers, glBindRenderbuffer, `glNamedRenderbufferStorageMultisample`,
glRenderbufferStorageMultisample, glFramebufferRenderbuffer, glDeleteRenderbuffers
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Determine if a name corresponds to a transform feedback object
---
### Parameters
`id` Specifies a value that may be the name of a transform feedback object.
---
### Description
`glIsTransformFeedback` returns `GL_TRUE` if `id` is currently the name of a transform
feedback object. If `id` is zero, or if `id` is not the name of a transform feedback object, or
if an error occurs, `glIsTransformFeedback` returns `GL_FALSE`. If `id` is a name returned by
glGenTransformFeedbacks, but that has not yet been bound through a call to
glBindTransformFeedback, then the name is not a transform feedback object and
`glIsTransformFeedback` returns `GL_FALSE`.
---
### Version Support
`glIsTransformFeedback`
---
### See Also
glGenTransformFeedbacks, glBindTransformFeedback, glDeleteTransformFeedbacks
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Release resources consumed by the implementation's shader compiler
---
### Description
`glReleaseShaderCompiler` provides a hint to the implementation that it may free internal
resources associated with its shader compiler. glCompileShader may subsequently be called and the
implementation may at that time reallocate resources previously freed by the call to
`glReleaseShaderCompiler`.
---
### Version Support
`glReleaseShaderCompiler`
---
### See Also
glCompileShader, glLinkProgram
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Determine if a name corresponds to a vertex array object
---
### Parameters
`array` Specifies a value that may be the name of a vertex array object.
---
### Description
`glIsVertexArray` returns `GL_TRUE` if `array` is currently the name of a vertex array
object. If `array` is zero, or if `array` is not the name of a vertex array object, or if an
error occurs, `glIsVertexArray` returns `GL_FALSE`. If `array` is a name returned by
glGenVertexArrays, by that has not yet been bound through a call to glBindVertexArray, then the
name is not a vertex array object and `glIsVertexArray` returns `GL_FALSE`.
---
### Version Support
`glIsVertexArray`
---
### See Also
glGenVertexArrays, glBindVertexArray, glDeleteVertexArrays
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Read a block of pixels from the frame buffer
---
### Parameters
`x` `y` Specify the window coordinates of the first pixel that is read from the frame buffer.

This location is the lower left corner of a rectangular block of pixels.
`width` `height` Specify the dimensions of the pixel rectangle. `width` and `height` of one
correspond to a single pixel.

`format` Specifies the format of the pixel data. The following symbolic values are accepted:
`GL_STENCIL_INDEX`, `GL_DEPTH_COMPONENT`, `GL_DEPTH_STENCIL`, `GL_RED`, `GL_GREEN`,
`GL_BLUE`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, and `GL_BGRA`.

`type` Specifies the data type of the pixel data. Must be one of `GL_UNSIGNED_BYTE`,
`GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_HALF_FLOAT`,
`GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`,
`GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`,
`GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`,
`GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, `GL_UNSIGNED_INT_2_10_10_10_REV`,
`GL_UNSIGNED_INT_24_8`, `GL_UNSIGNED_INT_10F_11F_11F_REV`, `GL_UNSIGNED_INT_5_9_9_9_REV`, or
`GL_FLOAT_32_UNSIGNED_INT_24_8_REV`.

`bufSize` Specifies the size of the buffer `data` for `glReadnPixels` function.

`data` Returns the pixel data.
]],
  [[Specify the width of rasterized lines
---
### Parameters
`width` Specifies the width of rasterized lines. The initial value is 1.
---
### Description
`glLineWidth` specifies the rasterized width of both aliased and antialiased lines. Using a line
width other than 1 has different effects, depending on whether line antialiasing is enabled. To
enable and disable line antialiasing, call glEnable and `glDisable` with argument
`GL_LINE_SMOOTH`. Line antialiasing is initially disabled.

If line antialiasing is disabled, the actual width is determined by rounding the supplied width to
the nearest integer. (If the rounding results in the value 0, it is as if the line width were 1.) If
Δ x >= Δ y, i pixels are filled in each column that is rasterized, where i is the
rounded value of `width`. Otherwise, i pixels are filled in each row that is rasterized.

If antialiasing is enabled, line rasterization produces a fragment for each pixel square that
intersects the region lying within the rectangle having width equal to the current line width,
length equal to the actual length of the line, and centered on the mathematical line segment. The
coverage value for each fragment is the window coordinate area of the intersection of the
rectangular region with the corresponding pixel square. This value is saved and used in the final
rasterization step. Not all widths can be supported when line antialiasing is enabled. If an
unsupported width is requested, the nearest supported width is used. Only width 1 is guaranteed to
be supported; others depend on the implementation. Likewise, there is a range for aliased line
widths as well. To query the range of supported widths and the size difference between supported
widths within the range, call glGet with arguments `GL_ALIASED_LINE_WIDTH_RANGE`,
`GL_SMOOTH_LINE_WIDTH_RANGE`, and `GL_SMOOTH_LINE_WIDTH_GRANULARITY`.
---
### Notes
The line width specified by `glLineWidth` is always returned when `GL_LINE_WIDTH` is queried.

Clamping and rounding for aliased and antialiased lines have no effect on the specified value.

Nonantialiased line width may be clamped to an implementation-dependent maximum. Call glGet
with `GL_ALIASED_LINE_WIDTH_RANGE` to determine the maximum width.

In OpenGL 1.2, the tokens `GL_LINE_WIDTH_RANGE` and `GL_LINE_WIDTH_GRANULARITY` were replaced
by `GL_ALIASED_LINE_WIDTH_RANGE`, `GL_SMOOTH_LINE_WIDTH_RANGE`, and
`GL_SMOOTH_LINE_WIDTH_GRANULARITY`. The old names are retained for backward compatibility, but
should not be used in new code.
---
### Errors
`GL_INVALID_VALUE` is generated if `width` is less than or equal to 0.
---
### Associated Gets
glGet with argument `GL_LINE_WIDTH`

glGet with argument `GL_ALIASED_LINE_WIDTH_RANGE`

glGet with argument `GL_SMOOTH_LINE_WIDTH_RANGE`

glGet with argument `GL_SMOOTH_LINE_WIDTH_GRANULARITY`

glIsEnabled with argument `GL_LINE_SMOOTH`
---
### Version Support
`glLineWidth`
---
### See Also
glEnable
---
### Copyright
Copyright 1991-2006 Silicon Graphics, Inc. Copyright 2010-2014 Khronos Group. This document
is licensed under the SGI Free Software B License. For details, see
https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.
]],
  [[Select a color buffer source for pixels
---
### Parameters
`framebuffer` Specifies the name of the framebuffer object for `glNamedFramebufferReadBuffer`
function.

`mode` Specifies a color buffer. Accepted values are `GL_FRONT_LEFT`, `GL_FRONT_RIGHT`,
`GL_BACK_LEFT`, `GL_BACK_RIGHT`, `GL_FRONT`, `GL_BACK`, `GL_LEFT`, `GL_RIGHT`, and the
constants `GL_COLOR_ATTACHMENT` i.

---
### Description
`glReadBuffer` specifies a color buffer as the source for subsequent glReadPixels,
glCopyTexImage1D, glCopyTexImage2D, glCopyTexSubImage1D, glCopyTexSubImage2D, and
glCopyTexSubImage3D commands. `mode` accepts one of twelve or more predefined values. In a fully
configured system, `GL_FRONT`, `GL_LEFT`, and `GL_FRONT_LEFT` all name the front left buffer,
`GL_FRONT_RIGHT` and `GL_RIGHT` name the front right buffer, and `GL_BACK_LEFT` and `GL_BACK`
name the back left buffer. Further more, the constants `GL_COLOR_ATTACHMENT` i may be used to
indicate the i th color attachment where i ranges from zero to the value of
`GL_MAX_COLOR_ATTACHMENTS` minus one.

Nonstereo double-buffered configurations have only a front left and a back left buffer.

Single-buffered configurations have a front left and a front right buffer if stereo, and only a
front left buffer if nonstereo. It is an error to specify a nonexistent buffer to `glReadBuffer`.

`mode` is initially `GL_FRONT` in single-buffered configurations and `GL_BACK` in
double-buffered configurations.

For `glReadBuffer`, the target framebuffer object is that bound to `GL_READ_FRAMEBUFFER`. For
`glNamedFramebufferReadBuffer`, `framebuffer` must either be zero or the name of the target
framebuffer object. If `framebuffer` is zero, then the default read framebuffer is affected.
---
### Errors
`GL_INVALID_ENUM` is generated if `mode` is not one of the twelve (or more) accepted values.

`GL_INVALID_OPERATION` is generated if `mode` specifies a buffer that does not exist.

`GL_INVALID_OPERATION` is generated by `glNamedFramebufferReadBuffer` if `framebuffer` is not
zero or the name of an existing framebuffer object.
---
### Associated Gets
glGet with argument `GL_READ_BUFFER`
---
### Version Support
`glNamedFramebufferReadBuffer` `glReadBuffer`
---
### See Also
glCopyTexImage1D, glCopyTexImage2D, glCopyTexSubImage1D, glCopyTexSubImage2D,
glCopyTexSubImage3D, glDrawBuffer, glReadPixels
---
### Copyright
Copyright 1991-2006 Silicon Graphics, Inc. Copyright 2011-2014 Khronos Group. This document
is licensed under the SGI Free Software B License. For details, see
https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.
]],
  [[Links a program object
---
### Parameters
`program` Specifies the handle of the program object to be linked.
---
### Description
`glLinkProgram` links the program object specified by `program`. If any shader objects of type
`GL_VERTEX_SHADER` are attached to `program`, they will be used to create an executable that will
run on the programmable vertex processor. If any shader objects of type `GL_GEOMETRY_SHADER` are
attached to `program`, they will be used to create an executable that will run on the programmable
geometry processor. If any shader objects of type `GL_FRAGMENT_SHADER` are attached to `program`,
they will be used to create an executable that will run on the programmable fragment processor.

The status of the link operation will be stored as part of the program object's state. This value
will be set to `GL_TRUE` if the program object was linked without errors and is ready for use, and
`GL_FALSE` otherwise. It can be queried by calling glGetProgram with arguments `program` and
`GL_LINK_STATUS`.

As a result of a successful link operation, all active user-defined uniform variables belonging to
`program` will be initialized to 0, and each of the program object's active uniform variables will
be assigned a location that can be queried by calling glGetUniformLocation. Also, any active
user-defined attribute variables that have not been bound to a generic vertex attribute index will
be bound to one at this time.

Linking of a program object can fail for a number of reasons as specified in the OpenGL Shading
Language Specification. The following lists some of the conditions that will cause a link error.

The number of active attribute variables supported by the implementation has been exceeded. The
storage limit for uniform variables has been exceeded. The number of active uniform variables
supported by the implementation has been exceeded. The `main` function is missing for the vertex,
geometry or fragment shader.

A varying variable actually used in the fragment shader is not declared in the same way (or is not
declared at all) in the vertex shader, or geometry shader if present. A reference to a function or
variable name is unresolved. A shared global is declared with two different types or two different
initial values. One or more of the attached shader objects has not been successfully compiled.

Binding a generic attribute matrix caused some rows of the matrix to fall outside the allowed
maximum of `GL_MAX_VERTEX_ATTRIBS`.

Not enough contiguous vertex attribute slots could be found to bind attribute matrices. The
program object contains objects to form a fragment shader but does not contain objects to form a
vertex shader. The program object contains objects to form a geometry shader but does not contain
objects to form a vertex shader. The program object contains objects to form a geometry shader and
the input primitive type, output primitive type, or maximum output vertex count is not specified in
any compiled geometry shader object. The program object contains objects to form a geometry shader
and the input primitive type, output primitive type, or maximum output vertex count is specified
differently in multiple geometry shader objects. The number of active outputs in the fragment
shader is greater than the value of `GL_MAX_DRAW_BUFFERS`.

The program has an active output assigned to a location greater than or equal to the value of
`GL_MAX_DUAL_SOURCE_DRAW_BUFFERS` and has an active output assigned an index greater than or equal
to one.

More than one varying out variable is bound to the same number and index. The explicit binding
assigments do not leave enough space for the linker to automatically assign a location for a varying
out array, which requires multiple contiguous locations. The `count` specified by
glTransformFeedbackVaryings is non-zero, but the program object has no vertex or geometry shader.

Any variable name specified to glTransformFeedbackVaryings in the `varyings` array is not
declared as an output in the vertex shader (or the geometry shader, if active).

Any two entries in the `varyings` array given glTransformFeedbackVaryings specify the same
varying variable.

The total number of components to capture in any transform feedback varying variable is greater
than the constant `GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS` and the buffer mode is
`GL_SEPARATE_ATTRIBS`.

When a program object has been successfully linked, the program object can be made part of current
state by calling glUseProgram. Whether or not the link operation was successful, the program
object's information log will be overwritten. The information log can be retrieved by calling
glGetProgramInfoLog.

`glLinkProgram` will also install the generated executables as part of the current rendering
state if the link operation was successful and the specified program object is already currently in
use as a result of a previous call to glUseProgram. If the program object currently in use is
relinked unsuccessfully, its link status will be set to `GL_FALSE`, but the executables and
associated state will remain part of the current state until a subsequent call to `glUseProgram`
removes it from use. After it is removed from use, it cannot be made part of current state until it
has been successfully relinked.

If `program` contains shader objects of type `GL_VERTEX_SHADER`, and optionally of type
`GL_GEOMETRY_SHADER`, but does not contain shader objects of type `GL_FRAGMENT_SHADER`, the
vertex shader executable will be installed on the programmable vertex processor, the geometry shader
executable, if present, will be installed on the programmable geometry processor, but no executable
will be installed on the fragment processor. The results of rasterizing primitives with such a
program will be undefined.

The program object's information log is updated and the program is generated at the time of the
link operation. After the link operation, applications are free to modify attached shader objects,
compile attached shader objects, detach shader objects, delete shader objects, and attach additional
shader objects. None of these operations affects the information log or the program that is part of
the program object.
---
### Notes
If the link operation is unsuccessful, any information about a previous link operation on
`program` is lost (i.e., a failed link does not restore the old state of `program` ). Certain
information can still be retrieved from `program` even after an unsuccessful link operation. See
for instance glGetActiveAttrib and glGetActiveUniform.
---
### Errors
`GL_INVALID_VALUE` is generated if `program` is not a value generated by OpenGL.

`GL_INVALID_OPERATION` is generated if `program` is not a program object.

`GL_INVALID_OPERATION` is generated if `program` is the currently active program object and
transform feedback mode is active.
---
### Associated Gets
glGet with the argument `GL_CURRENT_PROGRAM`

glGetActiveAttrib with argument `program` and the index of an active attribute variable

glGetActiveUniform with argument `program` and the index of an active uniform variable ``

glGetAttachedShaders with argument `program`

glGetAttribLocation with argument `program` and an attribute variable name

glGetProgram with arguments `program` and `GL_LINK_STATUS`

glGetProgramInfoLog with argument `program`

glGetUniform with argument `program` and a uniform variable location

glGetUniformLocation with argument `program` and a uniform variable name

glIsProgram
---
### Version Support
`glLinkProgram`
---
### See Also
glAttachShader, glBindAttribLocation, glCompileShader, glCreateProgram,
glDeleteProgram, glDetachShader, glUniform, glUseProgram, glValidateProgram
---
### Copyright
Copyright 2003-2005 3Dlabs Inc. Ltd. Copyright 2010-2014 Khronos Group. This material may be
distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8
June 1999. https://opencontent.org/openpub/.
]],
  [[Push a named debug group into the command stream
---
### Parameters
`source` The source of the debug message.
`id` The identifier of the message.
`length` The length of the message to be sent to the debug output stream.
`message` The a string containing the message to be sent to the debug output stream.
---
### Description
`glPushDebugGroup` pushes a debug group described by the string `message` into the command
stream. The value of `id` specifies the ID of messages generated. The parameter `length`
contains the number of characters in `message`. If `length` is negative, it is implied that
`message` contains a null terminated string. The message has the specified `source` and `id`,
the `type` `GL_DEBUG_TYPE_PUSH_GROUP`, and `severity` `GL_DEBUG_SEVERITY_NOTIFICATION`. The GL
will put a new debug group on top of the debug group stack which inherits the control of the volume
of debug output of the debug group previously residing on the top of the debug group stack. Because
debug groups are strictly hierarchical, any additional control of the debug output volume will only
apply within the active debug group and the debug groups pushed on top of the active debug group.
---
### Errors
`GL_INVALID_ENUM` is generated if the value of `source` is neither
`GL_DEBUG_SOURCE_APPLICATION` nor `GL_DEBUG_SOURCE_THIRD_PARTY`.

`GL_INVALID_VALUE` is generated if `length` is negative and the number of characters in
`message`, excluding the null-terminator, is not less than the value of
`GL_MAX_DEBUG_MESSAGE_LENGTH`.
---
### Associated Gets
glGet with argument `GL_MAX_DEBUG_MESSAGE_LENGTH`.
---
### Version Support
`glPushDebugGroup`
---
### See Also
glPopDebugGroup, glObjectLabel, glObjectPtrLabel.
---
### Copyright
Copyright 2013-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Specify a logical pixel operation for rendering
---
### Parameters
`opcode` Specifies a symbolic constant that selects a logical operation. The following symbols
are accepted: `GL_CLEAR`, `GL_SET`, `GL_COPY`, `GL_COPY_INVERTED`, `GL_NOOP`, `GL_INVERT`,
`GL_AND`, `GL_NAND`, `GL_OR`, `GL_NOR`, `GL_XOR`, `GL_EQUIV`, `GL_AND_REVERSE`,
`GL_AND_INVERTED`, `GL_OR_REVERSE`, and `GL_OR_INVERTED`. The initial value is `GL_COPY`.

---
### Description
`glLogicOp` specifies a logical operation that, when enabled, is applied between the incoming
RGBA color and the RGBA color at the corresponding location in the frame buffer. To enable or
disable the logical operation, call glEnable and `glDisable` using the symbolic constant
`GL_COLOR_LOGIC_OP`. The initial value is disabled.

Opcode Resulting Operation `GL_CLEAR` 0 `GL_SET` 1 `GL_COPY` s
`GL_COPY_INVERTED` ~s `GL_NOOP` d `GL_INVERT` ~d `GL_AND` s & d `GL_NAND` ~(s & d)
`GL_OR` s | d `GL_NOR` ~(s | d) `GL_XOR` s ^ d `GL_EQUIV` ~(s ^ d)
`GL_AND_REVERSE` s & ~d `GL_AND_INVERTED` ~s & d `GL_OR_REVERSE` s | ~d `GL_OR_INVERTED`
~s | d `opcode` is a symbolic constant chosen from the list above. In the explanation of the
logical operations, s represents the incoming color and d represents the color in the frame
buffer. Standard C-language operators are used. As these bitwise operators suggest, the logical
operation is applied independently to each bit pair of the source and destination colors.
---
### Notes
When more than one RGBA color buffer is enabled for drawing, logical operations are performed
separately for each enabled buffer, using for the destination value the contents of that buffer (see
glDrawBuffer ).

Logic operations have no effect on floating point draw buffers. However, if `GL_COLOR_LOGIC_OP`
is enabled, blending is still disabled in this case.
---
### Errors
`GL_INVALID_ENUM` is generated if `opcode` is not an accepted value.
---
### Associated Gets
glGet with argument `GL_LOGIC_OP_MODE`.

glIsEnabled with argument `GL_COLOR_LOGIC_OP`.
---
### Version Support
`glLogicOp`
---
### See Also
glBlendFunc, glDrawBuffer, glEnable, glStencilOp
---
### Copyright
Copyright 1991-2006 Silicon Graphics, Inc. Copyright 2010-2014 Khronos Group. This document
is licensed under the SGI Free Software B License. For details, see
https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.
]],
  [[GlProgramUniform Specify the value of a uniform variable for a specified program object
---
### Parameters
`program` Specifies the handle of the program containing the uniform variable to be modified.
`location` Specifies the location of the uniform variable to be modified.
`count` For the vector commands ( `glProgramUniform*v` ), specifies the number of elements that
are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more
if it is an array.

For the matrix commands ( `glProgramUniformMatrix*` ), specifies the number of matrices that are
to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1
or more if it is an array of matrices.

`transpose` For the matrix commands, specifies whether to transpose the matrix as the values
are loaded into the uniform variable.
`v0`, `v1`, `v2`, `v3` For the scalar commands, specifies the new values to be used for
the specified uniform variable.
`value` For the vector and matrix commands, specifies a pointer to an array of `count` values
that will be used to update the specified uniform variable.

---
### Description
`glProgramUniform` modifies the value of a uniform variable or a uniform variable array. The
location of the uniform variable to be modified is specified by `location`, which should be a
value returned by glGetUniformLocation. `glProgramUniform` operates on the program object
specified by `program`.

The commands `glProgramUniform{1|2|3|4}{f|i|ui}` are used to change the value of the uniform
variable specified by `location` using the values passed as arguments. The number specified in the
command should match the number of components in the data type of the specified uniform variable
(e.g., `1` for float, int, unsigned int, bool ; `2` for vec2, ivec2, uvec2, bvec2,
etc.). The suffix `f` indicates that floating-point values are being passed; the suffix `i`
indicates that integer values are being passed; the suffix `ui` indicates that unsigned integer
values are being passed, and this type should also match the data type of the specified uniform
variable. The `i` variants of this function should be used to provide values for uniform variables
defined as int, ivec2, ivec3, ivec4, or arrays of these. The `ui` variants of this
function should be used to provide values for uniform variables defined as unsigned int, uvec2,
uvec3, uvec4, or arrays of these. The `f` variants should be used to provide values for uniform
variables of type float, vec2, vec3, vec4, or arrays of these. Either the `i`, `ui` or
`f` variants may be used to provide values for uniform variables of type bool, bvec2, bvec3,
bvec4, or arrays of these. The uniform variable will be set to false if the input value is 0 or
0.0f, and it will be set to true otherwise.

All active uniform variables defined in a program object are initialized to 0 when the program
object is linked successfully. They retain the values assigned to them by a call to
`glProgramUniform` until the next successful link operation occurs on the program object, when they
are once again initialized to 0.

The commands `glProgramUniform{1|2|3|4}{f|i|ui}v` can be used to modify a single uniform variable
or a uniform variable array. These commands pass a count and a pointer to the values to be loaded
into a uniform variable or a uniform variable array. A count of 1 should be used if modifying the
value of a single uniform variable, and a count of 1 or greater can be used to modify an entire
array or part of an array. When loading n elements starting at an arbitrary position m in a
uniform variable array, elements m + n - 1 in the array will be replaced with the new values. If
`m` + `n` - 1 is larger than the size of the uniform variable array, values for all array
elements beyond the end of the array will be ignored. The number specified in the name of the
command indicates the number of components for each element in `value`, and it should match the
number of components in the data type of the specified uniform variable (e.g., `1` for float,
int, bool ; `2` for vec2, ivec2, bvec2, etc.). The data type specified in the name of the
command must match the data type for the specified uniform variable as described previously for
`glProgramUniform{1|2|3|4}{f|i|ui}`.

For uniform variable arrays, each element of the array is considered to be of the type indicated in
the name of the command (e.g., `glProgramUniform3f` or `glProgramUniform3fv` can be used to load
a uniform variable array of type vec3). The number of elements of the uniform variable array to be
modified is specified by `count`

The commands `glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv` are used to modify a
matrix or an array of matrices. The numbers in the command name are interpreted as the
dimensionality of the matrix. The number `2` indicates a 2 × 2 matrix (i.e., 4 values), the
number `3` indicates a 3 × 3 matrix (i.e., 9 values), and the number `4` indicates a 4 × 4
matrix (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number
representing the number of columns and the second number representing the number of rows. For
example, `2x4` indicates a 2 × 4 matrix with 2 columns and 4 rows (i.e., 8 values). If
`transpose` is `GL_FALSE`, each matrix is assumed to be supplied in column major order. If
`transpose` is `GL_TRUE`, each matrix is assumed to be supplied in row major order. The `count`
argument indicates the number of matrices to be passed. A count of 1 should be used if modifying the
value of a single matrix, and a count greater than 1 can be used to modify an array of matrices.
---
### Notes
`glProgramUniform1i` and `glProgramUniform1iv` are the only two functions that may be used to
load uniform variables defined as sampler types. Loading samplers with any other function will
result in a `GL_INVALID_OPERATION` error.

If `count` is greater than 1 and the indicated uniform variable is not an array, a
`GL_INVALID_OPERATION` error is generated and the specified uniform variable will remain unchanged.

Other than the preceding exceptions, if the type and size of the uniform variable as defined in the
shader do not match the type and size specified in the name of the command used to load its value, a
`GL_INVALID_OPERATION` error will be generated and the specified uniform variable will remain
unchanged.

If `location` is a value other than -1 and it does not represent a valid uniform variable
location in within `program`, an error will be generated, and no changes will be made to the
uniform variable storage of `program`. If `location` is equal to -1, the data passed in will be
silently ignored and the specified uniform variable will not be changed.
---
### Errors
`GL_INVALID_OPERATION` is generated if `program` does not refer to a program object owned by
the GL.

`GL_INVALID_OPERATION` is generated if the size of the uniform variable declared in the shader
does not match the size indicated by the `glProgramUniform` command.

`GL_INVALID_OPERATION` is generated if one of the signed or unsigned integer variants of this
function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of
these, or if one of the floating-point variants of this function is used to load a uniform variable
of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of
these.

`GL_INVALID_OPERATION` is generated if one of the signed integer variants of this function is
used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of
these.

`GL_INVALID_OPERATION` is generated if one of the unsigned integer variants of this function is
used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.

`GL_INVALID_OPERATION` is generated if `location` is an invalid uniform location for `program`
and `location` is not equal to -1.

`GL_INVALID_VALUE` is generated if `count` is less than 0.

`GL_INVALID_OPERATION` is generated if `count` is greater than 1 and the indicated uniform
variable is not an array variable.

`GL_INVALID_OPERATION` is generated if a sampler is loaded using a command other than
`glProgramUniform1i` and `glProgramUniform1iv`.
---
### Associated Gets
glGetActiveUniform with the handle of a program object and the index of an active uniform
variable

glGetUniform with the handle of a program object and the location of a uniform variable

glGetUniformLocation with the handle of a program object and the name of a uniform variable
---
### Version Support
`glProgramUniform1f` `glProgramUniform1fv` `glProgramUniform1i`
`glProgramUniform1iv` `glProgramUniform1ui` `glProgramUniform1uiv` `glProgramUniform2f`
`glProgramUniform2fv` `glProgramUniform2i` `glProgramUniform2iv` `glProgramUniform2ui`
`glProgramUniform2uiv` `glProgramUniform3f` `glProgramUniform3fv` `glProgramUniform3i`
`glProgramUniform3iv` `glProgramUniform3ui` `glProgramUniform3uiv` `glProgramUniform4f`
`glProgramUniform4fv` `glProgramUniform4i` `glProgramUniform4iv` `glProgramUniform4ui`
`glProgramUniform4uiv` `glProgramUniformMatrix2fv` `glProgramUniformMatrix2x3fv`
`glProgramUniformMatrix2x4fv` `glProgramUniformMatrix3fv` `glProgramUniformMatrix3x2fv`
`glProgramUniformMatrix3x4fv` `glProgramUniformMatrix4fv` `glProgramUniformMatrix4x2fv`
`glProgramUniformMatrix4x3fv`
---
### See Also
glLinkProgram, glUseProgram
---
### Copyright
Copyright 2003-2005 3Dlabs Inc. Ltd. Copyright 2010-2014 Khronos Group. This material may be
distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8
June 1999. https://opencontent.org/openpub/.
]],
  [[Map all of a buffer object's data store into the client's address space
---
### Parameters
`target` Specifies the target to which the buffer object is bound for `glMapBuffer`, which
must be one of the buffer binding targets in the following table:

`buffer` Specifies the name of the buffer object for `glMapNamedBuffer`.

`access` Specifies the access policy for `glMapBuffer` and `glMapNamedBuffer`, indicating
whether it will be possible to read from, write to, or both read from and write to the buffer
object's mapped data store. The symbolic constant must be `GL_READ_ONLY`, `GL_WRITE_ONLY`, or
`GL_READ_WRITE`.

---
### Description
`glMapBuffer` and `glMapNamedBuffer` map the entire data store of a specified buffer object
into the client's address space. The data can then be directly read and/or written relative to the
returned pointer, depending on the specified `access` policy.

A pointer to the beginning of the mapped range is returned once all pending operations on that
buffer object have completed, and may be used to modify and/or query the corresponding range of the
data store according to the value of `access` : `GL_READ_ONLY` indicates that the returned
pointer may be used to read buffer object data.

`GL_WRITE_ONLY` indicates that the returned pointer may be used to modify buffer object data.

`GL_READ_WRITE` indicates that the returned pointer may be used to read and to modify buffer
object data.


If an error is generated, a NULL pointer is returned.

If no error occurs, the returned pointer will reflect an allocation aligned to the value of
`GL_MIN_MAP_BUFFER_ALIGNMENT` basic machine units.

The returned pointer values may not be passed as parameter values to GL commands. For example,
they may not be used to specify array pointers, or to specify or query pixel or texture image data;
such actions produce undefined results, although implementations may not check for such behavior for
performance reasons. No GL error is generated if the returned pointer is accessed in a way
inconsistent with `access` (e.g. used to read from a mapping made with `access` `GL_WRITE_ONLY`
or write to a mapping made with `access` `GL_READ_ONLY` ), but the result is undefined and system
errors (possibly including program termination) may occur.

Mappings to the data stores of buffer objects may have nonstandard performance characteristics.

For example, such mappings may be marked as uncacheable regions of memory, and in such cases reading
from them may be very slow. To ensure optimal performance, the client should use the mapping in a
fashion consistent with the values of `GL_BUFFER_USAGE` for the buffer object and of `access`.

Using a mapping in a fashion inconsistent with these values is liable to be multiple orders of
magnitude slower than using normal memory.
---
### Notes
Alignment of the returned pointer is guaranteed only if the version of the GL version is 4.2 or
greater. Also, the `GL_ATOMIC_COUNTER_BUFFER` target is accepted only if the GL version is 4.2 or
greater.

The `GL_DISPATCH_INDIRECT_BUFFER` and `GL_SHADER_STORAGE_BUFFER` targets are available only if
the GL version is 4.3 or greater.

The `GL_QUERY_BUFFER` target is available only if the GL version is 4.4 or greater.
---
### Errors
`GL_INVALID_ENUM` is generated by `glMapBuffer` if `target` is not one of the buffer binding
targets listed above.

`GL_INVALID_OPERATION` is generated by `glMapBuffer` if zero is bound to `target`.

`GL_INVALID_OPERATION` is generated by `glMapNamedBuffer` if `buffer` is not the name of an
existing buffer object.

`GL_INVALID_ENUM` is generated if `access` is not `GL_READ_ONLY`, `GL_WRITE_ONLY`, or
`GL_READ_WRITE`.

`GL_OUT_OF_MEMORY` is generated if the GL is unable to map the buffer object's data store. This
may occur for a variety of system-specific reasons, such as the absence of sufficient remaining
virtual memory.

`GL_INVALID_OPERATION` is generated if the buffer object is in a mapped state.
---
### Associated Gets
glGetBufferPointerv with argument `GL_BUFFER_MAP_POINTER`

glGetBufferParameter with argument `GL_BUFFER_MAPPED`, `GL_BUFFER_ACCESS`, or
`GL_BUFFER_USAGE`

glGet with `pname` `GL_MIN_MAP_BUFFER_ALIGNMENT`. The value must be a power of two that is at
least 64.
---
### Version Support
`glMapBuffer` `glMapNamedBuffer`
---
### See Also
glBindBuffer, glBindBufferBase, glBindBufferRange, glBufferData, glBufferSubData,
glDeleteBuffers, glMapBufferRange, glUnmapBuffer
---
### Copyright
Copyright 2005 Addison-Wesley. Copyright 2010-2014 Khronos Group. This material may be
distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8
June 1999. https://opencontent.org/openpub/.
]],
  [[GlGetCompressedTexImage Return a compressed texture image
---
### Parameters
`target` Specifies the target to which the texture is bound for `glGetCompressedTexImage` and
`glGetnCompressedTexImage` functions. `GL_TEXTURE_1D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D`,
`GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_3D`, `GL_TEXTURE_CUBE_MAP_ARRAY`,
`GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`,
`GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`,
`GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, and `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`, `GL_TEXTURE_RECTANGLE`
are accepted.

`texture` Specifies the texture object name for `glGetCompressedTextureImage` function.

`level` Specifies the level-of-detail number of the desired image. Level 0 is the base image
level. Level $n$ is the $n$-th mipmap reduction image.
`bufSize` Specifies the size of the buffer `pixels` for `glGetCompressedTextureImage` and
`glGetnCompressedTexImage` functions.

`pixels` Returns the compressed texture image.
---
### Description
`glGetCompressedTexImage` and `glGetnCompressedTexImage` return the compressed texture image
associated with `target` and `lod` into `pixels`. `glGetCompressedTextureImage` serves the
same purpose, but instead of taking a texture target, it takes the ID of the texture object.
`pixels` should be an array of `bufSize` bytes for `glGetnCompresedTexImage` and
`glGetCompressedTextureImage` functions, and of `GL_TEXTURE_COMPRESSED_IMAGE_SIZE` bytes in case
of `glGetCompressedTexImage`. If the actual data takes less space than `bufSize`, the remaining
bytes will not be touched. `target` specifies the texture target, to which the texture the data
the function should extract the data from is bound to. `lod` specifies the level-of-detail number
of the desired image.

If a non-zero named buffer object is bound to the `GL_PIXEL_PACK_BUFFER` target (see
glBindBuffer ) while a texture image is requested, `pixels` is treated as a byte offset into the
buffer object's data store.

To minimize errors, first verify that the texture is compressed by calling glGetTexLevelParameter
with argument `GL_TEXTURE_COMPRESSED`. If the texture is compressed, you can determine the amount
of memory required to store the compressed texture by calling glGetTexLevelParameter with
argument `GL_TEXTURE_COMPRESSED_IMAGE_SIZE`. Finally, retrieve the internal format of the texture
by calling glGetTexLevelParameter with argument `GL_TEXTURE_INTERNAL_FORMAT`. To store the
texture for later use, associate the internal format and size with the retrieved texture image.

These data can be used by the respective texture or subtexture loading routine used for loading
`target` textures.
---
### Errors
`GL_INVALID_OPERATION` is generated by `glGetCompressedTextureImage` if `texture` is not the
name of an existing texture object.

`GL_INVALID_VALUE` is generated if `level` is less than zero or greater than the maximum number
of LODs permitted by the implementation.

`GL_INVALID_OPERATION` is generated if `glGetCompressedTexImage`, `glGetnCompressedTexImage`,
and `glGetCompressedTextureImage` is used to retrieve a texture that is in an uncompressed
internal format.

`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the
`GL_PIXEL_PACK_BUFFER` target, the buffer storage was not initialized with `glBufferStorage`
using `GL_MAP_PERSISTENT_BIT` flag, and the buffer object's data store is currently mapped.

`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the
`GL_PIXEL_PACK_BUFFER` target and the data would be packed to the buffer object such that the
memory writes required would exceed the data store size.
---
### Associated Gets
glGetTexLevelParameter with argument `GL_TEXTURE_COMPRESSED`

glGetTexLevelParameter with argument `GL_TEXTURE_COMPRESSED_IMAGE_SIZE`

glGetTexLevelParameter with argument `GL_TEXTURE_INTERNAL_FORMAT`

glGet with argument `GL_PIXEL_PACK_BUFFER_BINDING`
---
### Version Support
`glGetCompressedTexImage` `glGetCompressedTextureImage` `glGetnCompressedTexImage`
---
### See Also
glActiveTexture, glCompressedTexImage1D, glCompressedTexImage2D, glCompressedTexImage3D,
glCompressedTexSubImage1D, glCompressedTexSubImage2D, glCompressedTexSubImage3D,
glReadPixels, glTexImage1D, glTexImage2D, glTexImage3D, glTexParameter,
glTexSubImage1D, glTexSubImage2D, glTexSubImage3D
---
### Copyright
Copyright 1991-2006 Silicon Graphics, Inc. Copyright 2010-2014 Khronos Group. This document
is licensed under the SGI Free Software B License. For details, see
https://opencontent.org/openpub/.
]],
  [[Map all or part of a buffer object's data store into the client's address space
---
### Parameters
`target` Specifies the target to which the buffer object is bound for `glMapBufferRange`,
which must be one of the buffer binding targets in the following table:

`buffer` Specifies the name of the buffer object for `glMapNamedBufferRange`.

`offset` Specifies the starting offset within the buffer of the range to be mapped.
`length` Specifies the length of the range to be mapped.
`access` Specifies a combination of access flags indicating the desired access to the mapped
range.
---
### Description
`glMapBufferRange` and `glMapNamedBufferRange` map all or part of the data store of a specified
buffer object into the client's address space. `offset` and `length` indicate the range of data
in the buffer object that is to be mapped, in terms of basic machine units. `access` is a bitfield
containing flags which describe the requested mapping. These flags are described below.

A pointer to the beginning of the mapped range is returned once all pending operations on the
buffer object have completed, and may be used to modify and/or query the corresponding range of the
data store according to the following flag bits set in `access` : `GL_MAP_READ_BIT` indicates
that the returned pointer may be used to read buffer object data. No GL error is generated if the
pointer is used to query a mapping which excludes this flag, but the result is undefined and system
errors (possibly including program termination) may occur.

`GL_MAP_WRITE_BIT` indicates that the returned pointer may be used to modify buffer object data.

No GL error is generated if the pointer is used to modify a mapping which excludes this flag, but
the result is undefined and system errors (possibly including program termination) may occur.

`GL_MAP_PERSISTENT_BIT` indicates that the mapping is to be made in a persistent fashion and
that the client intends to hold and use the returned pointer during subsequent GL operation. It is
not an error to call drawing commands (render) while buffers are mapped using this flag. It is an
error to specify this flag if the buffer's data store was not allocated through a call to the
glBufferStorage command in which the `GL_MAP_PERSISTENT_BIT` was also set.

`GL_MAP_COHERENT_BIT` indicates that a persistent mapping is also to be coherent. Coherent maps
guarantee that the effect of writes to a buffer's data store by either the client or server will
eventually become visible to the other without further intervention from the application. In the
absence of this bit, persistent mappings are not coherent and modified ranges of the buffer store
must be explicitly communicated to the GL, either by unmapping the buffer, or through a call to
glFlushMappedBufferRange or glMemoryBarrier.


The following optional flag bits in `access` may be used to modify the mapping:
`GL_MAP_INVALIDATE_RANGE_BIT` indicates that the previous contents of the specified range may be
discarded. Data within this range are undefined with the exception of subsequently written data. No
GL error is generated if subsequent GL operations access unwritten data, but the result is undefined
and system errors (possibly including program termination) may occur. This flag may not be used in
combination with `GL_MAP_READ_BIT`.

`GL_MAP_INVALIDATE_BUFFER_BIT` indicates that the previous contents of the entire buffer may be
discarded. Data within the entire buffer are undefined with the exception of subsequently written
data. No GL error is generated if subsequent GL operations access unwritten data, but the result is
undefined and system errors (possibly including program termination) may occur. This flag may not be
used in combination with `GL_MAP_READ_BIT`.

`GL_MAP_FLUSH_EXPLICIT_BIT` indicates that one or more discrete subranges of the mapping may be
modified. When this flag is set, modifications to each subrange must be explicitly flushed by
calling glFlushMappedBufferRange. No GL error is set if a subrange of the mapping is modified and
not flushed, but data within the corresponding subrange of the buffer are undefined. This flag may
only be used in conjunction with `GL_MAP_WRITE_BIT`. When this option is selected, flushing is
strictly limited to regions that are explicitly indicated with calls to glFlushMappedBufferRange
prior to unmap; if this option is not selected glUnmapBuffer will automatically flush the entire
mapped range when called.

`GL_MAP_UNSYNCHRONIZED_BIT` indicates that the GL should not attempt to synchronize pending
operations on the buffer prior to returning from `glMapBufferRange` or `glMapNamedBufferRange`.

No GL error is generated if pending operations which source or modify the buffer overlap the mapped
region, but the result of such previous and any subsequent operations is undefined.


If an error occurs, a NULL pointer is returned.

If no error occurs, the returned pointer will reflect an allocation aligned to the value of
`GL_MIN_MAP_BUFFER_ALIGNMENT` basic machine units. Subtracting `offset` from this returned
pointer will always produce a multiple of the value of `GL_MIN_MAP_BUFFER_ALIGNMENT`.

The returned pointer values may not be passed as parameter values to GL commands. For example,
they may not be used to specify array pointers, or to specify or query pixel or texture image data;
such actions produce undefined results, although implementations may not check for such behavior for
performance reasons. Mappings to the data stores of buffer objects may have nonstandard
performance characteristics. For example, such mappings may be marked as uncacheable regions of
memory, and in such cases reading from them may be very slow. To ensure optimal performance, the
client should use the mapping in a fashion consistent with the values of `GL_BUFFER_USAGE` for the
buffer object and of `access`. Using a mapping in a fashion inconsistent with these values is
liable to be multiple orders of magnitude slower than using normal memory.
---
### Notes
Alignment of the returned pointer is guaranteed only if the version of the GL version is 4.2 or
greater. Also, the `GL_ATOMIC_COUNTER_BUFFER` target is accepted only if the GL version is 4.2 or
greater.

The `GL_DISPATCH_INDIRECT_BUFFER` and `GL_SHADER_STORAGE_BUFFER` targets are accepted only if
the GL version is 4.3 or greater.

The `GL_QUERY_BUFFER` target is available only if the GL version is 4.4 or greater.

The `GL_MAP_PERSISTENT_BIT` and `GL_MAP_COHERENT_BIT` flags are available only if the GL
version is 4.4 or greater.
---
### Errors
`GL_INVALID_ENUM` is generated by `glMapBufferRange` if `target` is not one of the buffer
binding targets listed above.

`GL_INVALID_OPERATION` is generated by `glMapBufferRange` if zero is bound to `target`.

`GL_INVALID_OPERATION` is generated by `glMapNamedBufferRange` if `buffer` is not the name of
an existing buffer object.

`GL_INVALID_VALUE` is generated if `offset` or `length` is negative, if $offset + length$ is
greater than the value of `GL_BUFFER_SIZE` for the buffer object, or if `access` has any bits
set other than those defined above.

`GL_INVALID_OPERATION` is generated for any of the following conditions: `length` is zero.

The buffer object is already in a mapped state. Neither `GL_MAP_READ_BIT` nor
`GL_MAP_WRITE_BIT` is set.

`GL_MAP_READ_BIT` is set and any of `GL_MAP_INVALIDATE_RANGE_BIT`,
`GL_MAP_INVALIDATE_BUFFER_BIT` or `GL_MAP_UNSYNCHRONIZED_BIT` is set.

`GL_MAP_FLUSH_EXPLICIT_BIT` is set and `GL_MAP_WRITE_BIT` is not set.

Any of `GL_MAP_READ_BIT`, `GL_MAP_WRITE_BIT`, `GL_MAP_PERSISTENT_BIT`, or
`GL_MAP_COHERENT_BIT` are set, but the same bit is not included in the buffer's storage flags.


No error is generated if memory outside the mapped range is modified or queried, but the result is
undefined and system errors (possibly including program termination) may occur.
---
### Associated Gets
glGet with `pname` `GL_MIN_MAP_BUFFER_ALIGNMENT`. The value must be a power of two that is at
least 64.
---
### Version Support
`glMapBufferRange` `glMapNamedBufferRange`
---
### See Also
glMapBuffer, glUnmapBuffer, glFlushMappedBufferRange, glBindBuffer, glBufferStorage
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Load pre-compiled shader binaries
---
### Parameters
`count` Specifies the number of shader object handles contained in `shaders`.

`shaders` Specifies the address of an array of shader handles into which to load pre-compiled
shader binaries.
`binaryFormat` Specifies the format of the shader binaries contained in `binary`.

`binary` Specifies the address of an array of bytes containing pre-compiled binary shader code.

`length` Specifies the length of the array whose address is given in `binary`.

---
### Description
`glShaderBinary` loads pre-compiled shader binary code into the `count` shader objects whose
handles are given in `shaders`. `binary` points to `length` bytes of binary shader code stored
in client memory. `binaryFormat` specifies the format of the pre-compiled code.

The binary image contained in `binary` will be decoded according to the extension specification
defining the specified `binaryFormat` token. OpenGL does not define any specific binary formats,
but it does provide a mechanism to obtain token vaues for such formats provided by such extensions.

Depending on the types of the shader objects in `shaders`, `glShaderBinary` will individually
load binary vertex or fragment shaders, or load an executable binary that contains an optimized pair
of vertex and fragment shaders stored in the same binary.
---
### Errors
`GL_INVALID_OPERATION` is generated if more than one of the handles in `shaders` refers to the
same shader object.

`GL_INVALID_ENUM` is generated if `binaryFormat` is not an accepted value.

`GL_INVALID_VALUE` is generated if the data pointed to by `binary` does not match the format
specified by `binaryFormat`.
---
### Associated Gets
glGet with parameter `GL_NUM_SHADER_BINARY_FORMATS`.

glGet with parameter `GL_SHADER_BINARY_FORMATS`.
---
### Version Support
`glShaderBinary`
---
### See Also
glGetProgram, glGetProgramBinary, glProgramBinary
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Defines a barrier ordering memory transactions
---
### Parameters
`barriers` Specifies the barriers to insert. For `glMemoryBarrier`, must be a bitwise
combination of any of `GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT`, `GL_ELEMENT_ARRAY_BARRIER_BIT`,
`GL_UNIFORM_BARRIER_BIT`, `GL_TEXTURE_FETCH_BARRIER_BIT`, `GL_SHADER_IMAGE_ACCESS_BARRIER_BIT`,
`GL_COMMAND_BARRIER_BIT`, `GL_PIXEL_BUFFER_BARRIER_BIT`, `GL_TEXTURE_UPDATE_BARRIER_BIT`,
`GL_BUFFER_UPDATE_BARRIER_BIT`, `GL_FRAMEBUFFER_BARRIER_BIT`,
`GL_TRANSFORM_FEEDBACK_BARRIER_BIT`, `GL_ATOMIC_COUNTER_BARRIER_BIT`, or
`GL_SHADER_STORAGE_BARRIER_BIT`.

For `glMemoryBarrier`, must be a bitwise combination of any of `GL_ATOMIC_COUNTER_BARRIER_BIT`,
or `GL_FRAMEBUFFER_BARRIER_BIT`, `GL_SHADER_IMAGE_ACCESS_BARRIER_BIT`,
`GL_SHADER_STORAGE_BARRIER_BIT`. `GL_TEXTURE_FETCH_BARRIER_BIT`, or `GL_UNIFORM_BARRIER_BIT`.

If the special value `GL_ALL_BARRIER_BITS` is specified, all supported barriers for the
corresponding command will be inserted.

---
### Description for
`glMemoryBarrier` `glMemoryBarrier` defines a barrier ordering the memory transactions issued
prior to the command relative to those issued after the barrier. For the purposes of this ordering,
memory transactions performed by shaders are considered to be issued by the rendering command that
triggered the execution of the shader. `barriers` is a bitfield indicating the set of operations
that are synchronized with shader stores; the bits used in `barriers` are as follows:

`GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT` If set, vertex data sourced from buffer objects after
the barrier will reflect data written by shaders prior to the barrier. The set of buffer objects
affected by this bit is derived from the buffer object bindings used for generic vertex attributes
derived from the `GL_VERTEX_ATTRIB_ARRAY_BUFFER` bindings.

`GL_ELEMENT_ARRAY_BARRIER_BIT` If set, vertex array indices sourced from buffer objects after
the barrier will reflect data written by shaders prior to the barrier. The buffer objects affected
by this bit are derived from the `GL_ELEMENT_ARRAY_BUFFER` binding.

`GL_UNIFORM_BARRIER_BIT` Shader uniforms sourced from buffer objects after the barrier will
reflect data written by shaders prior to the barrier.
`GL_TEXTURE_FETCH_BARRIER_BIT` Texture fetches from shaders, including fetches from buffer
object memory via buffer textures, after the barrier will reflect data written by shaders prior to
the barrier.
`GL_SHADER_IMAGE_ACCESS_BARRIER_BIT` Memory accesses using shader image load, store, and atomic
built-in functions issued after the barrier will reflect data written by shaders prior to the
barrier. Additionally, image stores and atomics issued after the barrier will not execute until all
memory accesses (e.g., loads, stores, texture fetches, vertex fetches) initiated prior to the
barrier complete.
`GL_COMMAND_BARRIER_BIT` Command data sourced from buffer objects by Draw*Indirect commands
after the barrier will reflect data written by shaders prior to the barrier. The buffer objects
affected by this bit are derived from the `GL_DRAW_INDIRECT_BUFFER` binding.

`GL_PIXEL_BUFFER_BARRIER_BIT` Reads and writes of buffer objects via the
`GL_PIXEL_PACK_BUFFER` and `GL_PIXEL_UNPACK_BUFFER` bindings (via glReadPixels,
glTexSubImage1D, etc.) after the barrier will reflect data written by shaders prior to the barrier.

Additionally, buffer object writes issued after the barrier will wait on the completion of all
shader writes initiated prior to the barrier.

`GL_TEXTURE_UPDATE_BARRIER_BIT` Writes to a texture via `glTex(Sub)Image*`,
`glCopyTex(Sub)Image*`, `glCompressedTex(Sub)Image*`, and reads via glGetTexImage after the
barrier will reflect data written by shaders prior to the barrier. Additionally, texture writes from
these commands issued after the barrier will not execute until all shader writes initiated prior to
the barrier complete.

`GL_BUFFER_UPDATE_BARRIER_BIT` Reads or writes via glBufferSubData, glCopyBufferSubData,
or glGetBufferSubData, or to buffer object memory mapped by glMapBuffer or glMapBufferRange
after the barrier will reflect data written by shaders prior to the barrier. Additionally, writes
via these commands issued after the barrier will wait on the completion of any shader writes to the
same memory initiated prior to the barrier.

`GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT` Access by the client to persistent mapped regions of
buffer objects will reflect data written by shaders prior to the barrier. Note that this may cause
additional synchronization operations.
`GL_FRAMEBUFFER_BARRIER_BIT` Reads and writes via framebuffer object attachments after the
barrier will reflect data written by shaders prior to the barrier. Additionally, framebuffer writes
issued after the barrier will wait on the completion of all shader writes issued prior to the
barrier.
`GL_TRANSFORM_FEEDBACK_BARRIER_BIT` Writes via transform feedback bindings after the barrier
will reflect data written by shaders prior to the barrier. Additionally, transform feedback writes
issued after the barrier will wait on the completion of all shader writes issued prior to the
barrier.
`GL_ATOMIC_COUNTER_BARRIER_BIT` Accesses to atomic counters after the barrier will reflect
writes prior to the barrier.
`GL_SHADER_STORAGE_BARRIER_BIT` Accesses to shader storage blocks after the barrier will
reflect writes prior to the barrier.
`GL_QUERY_BUFFER_BARRIER_BIT` Writes of buffer objects via the `GL_QUERY_BUFFER` binding
after the barrier will reflect data written by shaders prior to the barrier. Additionally, buffer
object writes issued after the barrier will wait on the completion of all shader writes initiated
prior to the barrier.


If `barriers` is `GL_ALL_BARRIER_BITS`, shader memory accesses will be synchronized relative
to all the operations described above.

Implementations may cache buffer object and texture image memory that could be written by shaders
in multiple caches; for example, there may be separate caches for texture, vertex fetching, and one
or more caches for shader memory accesses. Implementations are not required to keep these caches
coherent with shader memory writes. Stores issued by one invocation may not be immediately
observable by other pipeline stages or other shader invocations because the value stored may remain
in a cache local to the processor executing the store, or because data overwritten by the store is
still in a cache elsewhere in the system. When `glMemoryBarrier` is called, the GL flushes and/or
invalidates any caches relevant to the operations specified by the `barriers` parameter to ensure
consistent ordering of operations across the barrier.

To allow for independent shader invocations to communicate by reads and writes to a common memory
address, image variables in the OpenGL Shading Language may be declared as "coherent". Buffer object
or texture image memory accessed through such variables may be cached only if caches are
automatically updated due to stores issued by any other shader invocation. If the same address is
accessed using both coherent and non-coherent variables, the accesses using variables declared as
coherent will observe the results stored using coherent variables in other invocations. Using
variables declared as "coherent" guarantees only that the results of stores will be immediately
visible to shader invocations using similarly-declared variables; calling `glMemoryBarrier` is
required to ensure that the stores are visible to other operations.

The following guidelines may be helpful in choosing when to use coherent memory accesses and when
to use barriers. Data that are read-only or constant may be accessed without using coherent
variables or calling `MemoryBarrier` (). Updates to the read-only data via API calls such as
`glBufferSubData` will invalidate shader caches implicitly as required.

Data that are shared between shader invocations at a fine granularity (e.g., written by one
invocation, consumed by another invocation) should use coherent variables to read and write the
shared data. Data written by one shader invocation and consumed by other shader invocations
launched as a result of its execution ("dependent invocations") should use coherent variables in the
producing shader invocation and call `memoryBarrier` () after the last write. The consuming shader
invocation should also use coherent variables.

Data written to image variables in one rendering pass and read by the shader in a later pass need
not use coherent variables or memoryBarrier(). Calling `glMemoryBarrier` with the
SHADER_IMAGE_ACCESS_BARRIER_BIT set in `barriers` between passes is necessary.

Data written by the shader in one rendering pass and read by another mechanism (e.g., vertex or
index buffer pulling) in a later pass need not use coherent variables or `memoryBarrier` ().

Calling `glMemoryBarrier` with the appropriate bits set in `barriers` between passes is
necessary.

---
### Description for
`glMemoryBarrierByRegion` `glMemoryBarrierByRegion` behaves as described above for
`glMemoryBarrier`, with two differences:

First, it narrows the region under consideration so that only reads and writes of prior fragment
shaders that are invoked for a smaller region of the framebuffer will be completed/reflected prior
to subsequent reads and writes of following fragment shaders. The size of the region is
implementation-dependent and may be as small as one framebuffer pixel. Second, it only applies to
memory transactions that may be read by or written by a fragment shader. Therefore, only the barrier
bits `GL_ATOMIC_COUNTER_BARRIER_BIT`

`GL_FRAMEBUFFER_BARRIER_BIT`

`GL_SHADER_IMAGE_ACCESS_BARRIER_BIT`

`GL_SHADER_STORAGE_BARRIER_BIT`

`GL_TEXTURE_FETCH_BARRIER_BIT`

`GL_UNIFORM_BARRIER_BIT`

are supported.

When `barriers` is `GL_ALL_BARRIER_BITS`, shader memory accesses will be synchronized relative
to all these barrier bits, but not to other barrier bits specific to `glMemoryBarrier`. This
implies that reads and writes for scatter/gather-like algorithms may or may not be
completed/reflected after a `glMemoryBarrierByRegion` command. However, for uses such as deferred
shading, where a linked list of visible surfaces with the head at a framebuffer address may be
constructed, and the entirety of the list is only dependent on previous executions at that
framebuffer address, `glMemoryBarrierByRegion` may be significantly more efficient than
`glMemoryBarrier`.
---
### Notes
`GL_SHADER_STORAGE_BARRIER_BIT` is available only if the GL version is 4.3 or higher.

`GL_QUERY_BUFFER_BARRIER_BIT` is available only if the GL version is 4.4 or higher.
---
### Errors
`GL_INVALID_VALUE` is generated if `barriers` is not the special value `GL_ALL_BARRIER_BITS`,
and has any bits set other than those described above for `glMemoryBarrier` or
`glMemoryBarrierByRegion` respectively.
---
### Version Support
`glMemoryBarrier` `glMemoryBarrierByRegion`
---
### See Also
glBindImageTexture, glBufferData, glMapBuffer, glMapBufferRange,
glFlushMappedBufferRange, memoryBarrier
---
### Copyright
Copyright 2011-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Retrieve messages from the debug message log
---
### Parameters
`count` The number of debug messages to retrieve from the log.
`bufSize` The size of the buffer whose address is given by `messageLog`.

`sources` The address of an array of variables to receive the sources of the retrieved
messages.
`types` The address of an array of variables to receive the types of the retrieved messages.
`ids` The address of an array of unsigned integers to receive the ids of the retrieved
messages.
`severities` The address of an array of variables to receive the severites of the retrieved
messages.
`lengths` The address of an array of variables to receive the lengths of the received messages.

`messageLog` The address of an array of characters that will receive the messages.
---
### Description
`glGetDebugMessageLog` retrieves messages from the debug message log. A maximum of `count`
messages are retrieved from the log. If `sources` is not NULL then the source of each message is
written into up to `count` elements of the array. If `types` is not NULL then the type of each
message is written into up to `count` elements of the array. If `id` is not NULL then the
identifier of each message is written into up to `count` elements of the array. If `severities`
is not NULL then the severity of each message is written into up to `count` elements of the array.

If `lengths` is not NULL then the length of each message is written into up to `count` elements
of the array.

`messageLog` specifies the address of a character array into which the debug messages will be
written. Each message will be concatenated onto the array starting at the first element of
`messageLog`. `bufSize` specifies the size of the array `messageLog`. If a message will not fit
into the remaining space in `messageLog` then the function terminates and returns the number of
messages written so far, which may be zero.

If `glGetDebugMessageLog` returns zero then no messages are present in the debug log, or there
was not enough space in `messageLog` to retrieve the first message in the queue. If `messageLog`
is NULL then no messages are written and the value of `bufSize` is ignored.
---
### Notes
Although debug messages may be enabled in a non-debug context, the quantity and detail of such
messages may be substantially inferior to those in a debug context. In particular, a valid
implementation of the debug message queue in a non-debug context may produce no messages at all.
---
### Errors
`GL_INVALID_VALUE` is generated if `count` or `bufSize` is negative.
---
### Associated Gets
glGet with argument `GL_DEBUG_LOGGED_MESSAGES`

glGet with argument `GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH`

glGet with argument `GL_MAX_DEBUG_MESSAGE_LENGTH`

glGet with argument `GL_MAX_DEBUG_LOGGED_MESSAGES`
---
### Version Support
`glGetDebugMessageLog`
---
### See Also
glDebugMessageInsert, glDebugMessageCallback, glDebugMessageControl.
---
### Copyright
Copyright 2013-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Define the scissor box
---
### Parameters
`x` `y` Specify the lower left corner of the scissor box. Initially (0, 0).
`width` `height` Specify the width and height of the scissor box. When a GL context is first
attached to a window, `width` and `height` are set to the dimensions of that window.

---
### Description
`glScissor` defines a rectangle, called the scissor box, in window coordinates. The first two
arguments, `x` and `y`, specify the lower left corner of the box. `width` and `height`
specify the width and height of the box.

To enable and disable the scissor test, call glEnable and `glDisable` with argument
`GL_SCISSOR_TEST`. The test is initially disabled. While the test is enabled, only pixels that lie
within the scissor box can be modified by drawing commands. Window coordinates have integer values
at the shared corners of frame buffer pixels. glScissor(0,0,1,1) allows modification of only the
lower left pixel in the window, and glScissor(0,0,0,0) doesn't allow modification of any pixels in
the window.

When the scissor test is disabled, it is as though the scissor box includes the entire window.
---
### Errors
`GL_INVALID_VALUE` is generated if either `width` or `height` is negative.
---
### Associated Gets
glGet with argument `GL_SCISSOR_BOX`

glIsEnabled with argument `GL_SCISSOR_TEST`
---
### Version Support
`glScissor`
---
### See Also
glEnable, glViewport
---
### Copyright
Copyright 1991-2006 Silicon Graphics, Inc. Copyright 2010-2014 Khronos Group. This document
is licensed under the SGI Free Software B License. For details, see
https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.
]],
  [[Specifies minimum rate at which sample shading takes place
---
### Parameters
`value` Specifies the rate at which samples are shaded within each covered pixel.
---
### Description
`glMinSampleShading` specifies the rate at which samples are shaded within a covered pixel.

Sample-rate shading is enabled by calling glEnable with the parameter `GL_SAMPLE_SHADING`. If
`GL_MULTISAMPLE` or `GL_SAMPLE_SHADING` is disabled, sample shading has no effect. Otherwise, an
implementation must provide at least as many unique color values for each covered fragment as
specified by `value` times `samples` where `samples` is the value of `GL_SAMPLES` for the
current framebuffer. At least 1 sample for each covered fragment is generated.

A `value` of 1.0 indicates that each sample in the framebuffer should be independently shaded. A
`value` of 0.0 effectively allows the GL to ignore sample rate shading. Any value between 0.0 and
1.0 allows the GL to shade only a subset of the total samples within each covered fragment. Which
samples are shaded and the algorithm used to select that subset of the fragment's samples is
implementation dependent.
---
### Notes
The type of the `value` parameter was changed from GLclampf to GLfloat. This change is
transparent to user code and is described in detail on the removedTypes page.
---
### Errors
None.
---
### Associated Gets
glGet with argument `GL_MIN_SAMPLE_SHADING`.

glGet with argument `GL_SAMPLES`.
---
### Version Support
`glMinSampleShading`
---
### See Also
removedTypes
---
### Copyright
Copyright 2011-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Query the bindings of color indices to user-defined varying out variables
---
### Parameters
`program` The name of the program containing varying out variable whose binding to query
`name` The name of the user-defined varying out variable whose index to query
---
### Description
`glGetFragDataIndex` returns the index of the fragment color to which the variable `name` was
bound when the program object `program` was last linked. If `name` is not a varying out variable
of `program`, or if an error occurs, -1 will be returned.
---
### Notes
`glGetFragDataIndex` is available only if the GL version is 3.3 or greater.
---
### Errors
`GL_INVALID_OPERATION` is generated if `program` is not the name of a program object.
---
### Version Support
`glGetFragDataIndex`
---
### See Also
glCreateProgram, glBindFragDataLocation, glBindFragDataLocationIndexed,
glGetFragDataLocation
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Render multiple sets of primitives from array data
---
### Parameters
`mode` Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`,
`GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`,
`GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`,
`GL_TRIANGLES_ADJACENCY` and `GL_PATCHES` are accepted.

`first` Points to an array of starting indices in the enabled arrays.
`count` Points to an array of the number of indices to be rendered.
`drawcount` Specifies the size of the first and count
---
### Description
`glMultiDrawArrays` specifies multiple sets of geometric primitives with very few subroutine
calls. Instead of calling a GL procedure to pass each individual vertex, normal, texture coordinate,
edge flag, or color, you can prespecify separate arrays of vertices, normals, and colors and use
them to construct a sequence of primitives with a single call to `glMultiDrawArrays`.

`glMultiDrawArrays` behaves identically to glDrawArrays except that `drawcount` separate
ranges of elements are specified instead.

When `glMultiDrawArrays` is called, it uses `count` sequential elements from each enabled
array to construct a sequence of geometric primitives, beginning with element `first`. `mode`
specifies what kind of primitives are constructed, and how the array elements construct those
primitives.

Vertex attributes that are modified by `glMultiDrawArrays` have an unspecified value after
`glMultiDrawArrays` returns. Attributes that aren't modified remain well defined.
---
### Notes
`GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP_ADJACENCY` and
`GL_TRIANGLES_ADJACENCY` are available only if the GL version is 3.2 or greater.
---
### Errors
`GL_INVALID_ENUM` is generated if `mode` is not an accepted value.

`GL_INVALID_VALUE` is generated if `drawcount` is negative.

`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array
and the buffer object's data store is currently mapped.
---
### Version Support
`glMultiDrawArrays`
---
### See Also
glDrawElements, glDrawRangeElements
---
### Copyright
Copyright 1991-2006 Silicon Graphics, Inc. Copyright 2010-2014 Khronos Group. This document
is licensed under the SGI Free Software B License. For details, see
https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.
]],
  [[Specify mapping of depth values from normalized device coordinates to window coordinates for a
specified viewport
---
### Parameters
`index` Specifies the index of the viewport whose depth range to update.
`nearVal` Specifies the mapping of the near clipping plane to window coordinates. The initial
value is 0.
`farVal` Specifies the mapping of the far clipping plane to window coordinates. The initial
value is 1.
---
### Description
After clipping and division by w, depth coordinates range from -1 to 1, corresponding to the
near and far clipping planes. Each viewport has an independent depth range specified as a linear
mapping of the normalized depth coordinates in this range to window depth coordinates. Regardless of
the actual depth buffer implementation, window coordinate depth values are treated as though they
range from 0 through 1 (like color components). `glDepthRangeIndexed` specifies a linear mapping
of the normalized depth coordinates in this range to window depth coordinates for a specified
viewport. Thus, the values accepted by `glDepthRangeIndexed` are both clamped to this range before
they are accepted.

The `index` parameter specifies the index of first viewport whose depth range to modify and must
be less than the value of `GL_MAX_VIEWPORTS`. `nearVal` and `farVal` specify near and far
values of the depth range for the specified viewport, respectively.

The setting of (0,1) maps the near plane to 0 and the far plane to 1. With this mapping, the depth
buffer range is fully utilized.
---
### Notes
It is not necessary that the near plane distance be less than the far plane distance. Reverse
mappings such as nearVal = 1, and farVal = 0 are acceptable.

The type of the `nearVal` and `farVal` parameters was changed from GLclampd to GLdouble. This
change is transparent to user code and is described in detail on the removedTypes page.
---
### Errors
`GL_INVALID_VALUE` is generated if `index` is greater than or equal to the value of
`GL_MAX_VIEWPORTS`.
---
### Associated Gets
glGet with argument `GL_DEPTH_RANGE`
---
### Version Support
`glDepthRangeIndexed`
---
### See Also
glDepthFunc, glDepthRange, glDepthRangeArray, glPolygonOffset, glViewportArray,
glViewport, removedTypes
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Render multiple sets of primitives from array data, taking parameters from memory
---
### Parameters
`mode` Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`,
`GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`,
`GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`,
`GL_TRIANGLES_ADJACENCY`, and `GL_PATCHES` are accepted.

`indirect` Specifies the address of an array of structures containing the draw parameters.
`drawcount` Specifies the number of elements in the array of draw parameter structures.
`stride` Specifies the distance in basic machine units between elements of the draw parameter
array.
---
### Description
`glMultiDrawArraysIndirect` specifies multiple geometric primitives with very few subroutine
calls. `glMultiDrawArraysIndirect` behaves similarly to a multitude of calls to
glDrawArraysInstancedBaseInstance, execept that the parameters to each call to
glDrawArraysInstancedBaseInstance are stored in an array in memory at the address given by
`indirect`, separated by the stride, in basic machine units, specified by `stride`. If `stride`
is zero, then the array is assumed to be tightly packed in memory.

The parameters addressed by `indirect` are packed into an array of structures, each element of
which takes the form (in C): typedef struct { uint count; uint instanceCount; uint first; uint
baseInstance; } DrawArraysIndirectCommand;

A single call to `glMultiDrawArraysIndirect` is equivalent, assuming no errors are generated to:
GLsizei n; for (n = 0; n < drawcount; n++) { const DrawArraysIndirectCommand *cmd; if (stride !=
0) { cmd = (const DrawArraysIndirectCommand *)((uintptr)indirect + n * stride); } else { cmd =
(const DrawArraysIndirectCommand *)indirect + n; } glDrawArraysInstancedBaseInstance(mode,
cmd->first, cmd->count, cmd->instanceCount, cmd->baseInstance); }

If a buffer is bound to the `GL_DRAW_INDIRECT_BUFFER` binding at the time of a call to
`glMultiDrawArraysIndirect`, `indirect` is interpreted as an offset, in basic machine units, into
that buffer and the parameter data is read from the buffer rather than from client memory.

In contrast to glDrawArraysInstancedBaseInstance, the first member of the parameter structure
is unsigned, and out-of-range indices do not generate an error.

Vertex attributes that are modified by `glMultiDrawArraysIndirect` have an unspecified value
after `glMultiDrawArraysIndirect` returns. Attributes that aren't modified remain well defined.
---
### Notes
The `baseInstance` member of the `DrawArraysIndirectCommand` structure is defined only if the
GL version is 4.2 or greater. For versions of the GL less than 4.2, this parameter is present but is
reserved and should be set to zero. On earlier versions of the GL, behavior is undefined if it is
non-zero.

`glMultiDrawArraysIndirect` is available only if the GL version is 4.3 or greater.
---
### Errors
`GL_INVALID_ENUM` is generated if `mode` is not an accepted value.

`GL_INVALID_VALUE` is generated if `stride` is not a multiple of four.

`GL_INVALID_VALUE` is generated if `drawcount` is negative.

`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array
or to the `GL_DRAW_INDIRECT_BUFFER` binding and the buffer object's data store is currently
mapped.

`GL_INVALID_OPERATION` is generated if a geometry shader is active and `mode` is incompatible
with the input primitive type of the geometry shader in the currently installed program object.

`GL_INVALID_OPERATION` is generated if `mode` is `GL_PATCHES` and no tessellation control
shader is active.
---
### Version Support
`glMultiDrawArraysIndirect`
---
### See Also
glDrawArrays, glDrawArraysInstanced, glDrawElements, glDrawRangeElements,
glDrawArraysIndirect, glMultiDrawElementsIndirect
---
### Copyright
Copyright 2012-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Render multiple sets of primitives by specifying indices of array data elements
---
### Parameters
`mode` Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`,
`GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`,
`GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`,
`GL_TRIANGLES_ADJACENCY` and `GL_PATCHES` are accepted.

`count` Points to an array of the elements counts.
`type` Specifies the type of the values in `indices`. Must be one of `GL_UNSIGNED_BYTE`,
`GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`.

`indices` Specifies a pointer to the location where the indices are stored.
`drawcount` Specifies the size of the `count` and `indices` arrays.

---
### Description
`glMultiDrawElements` specifies multiple sets of geometric primitives with very few subroutine
calls. Instead of calling a GL function to pass each individual vertex, normal, texture coordinate,
edge flag, or color, you can prespecify separate arrays of vertices, normals, and so on, and use
them to construct a sequence of primitives with a single call to `glMultiDrawElements`.

`glMultiDrawElements` is identical in operation to glDrawElements except that `drawcount`
separate lists of elements are specified.

Vertex attributes that are modified by `glMultiDrawElements` have an unspecified value after
`glMultiDrawElements` returns. Attributes that aren't modified maintain their previous values.
---
### Notes
`GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP_ADJACENCY` and
`GL_TRIANGLES_ADJACENCY` are available only if the GL version is 3.2 or greater.
---
### Errors
`GL_INVALID_ENUM` is generated if `mode` is not an accepted value.

`GL_INVALID_VALUE` is generated if `drawcount` is negative.

`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array
or the element array and the buffer object's data store is currently mapped.
---
### Version Support
`glMultiDrawElements`
---
### See Also
glDrawArrays, glDrawRangeElements
---
### Copyright
Copyright 1991-2006 Silicon Graphics, Inc. Copyright 2010-2014 Khronos Group. This document
is licensed under the SGI Free Software B License. For details, see
https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.
]],
  [[Launch one or more compute work groups
---
### Parameters
`num_groups_x` The number of work groups to be launched in the X dimension.
`num_groups_y` The number of work groups to be launched in the Y dimension.
`num_groups_z` The number of work groups to be launched in the Z dimension.
---
### Description
`glDispatchCompute` launches one or more compute work groups. Each work group is processed by the
active program object for the compute shader stage. While the individual shader invocations within a
work group are executed as a unit, work groups are executed completely independently and in
unspecified order. `num_groups_x`, `num_groups_y` and `num_groups_z` specify the number of
local work groups that will be dispatched in the X, Y and Z dimensions, respectively.
---
### Errors
`GL_INVALID_OPERATION` is generated if there is no active program for the compute shader stage.

`GL_INVALID_VALUE` is generated if any of `num_groups_x`, `num_groups_y`, or `num_groups_z`
is greater than or equal to the maximum work-group count for the corresponding dimension.
---
### Associated Gets
glGet with argument `GL_MAX_COMPUTE_WORK_GROUP_COUNT`
---
### Version Support
`glDispatchCompute`
---
### See Also
glDispatchComputeIndirect.
---
### Copyright
Copyright 2013-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Render multiple sets of primitives by specifying indices of array data elements and an index to
apply to each index
---
### Parameters
`mode` Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`,
`GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`,
`GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`,
`GL_TRIANGLES_ADJACENCY` and `GL_PATCHES` are accepted.

`count` Points to an array of the elements counts.
`type` Specifies the type of the values in `indices`. Must be one of `GL_UNSIGNED_BYTE`,
`GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`.

`indices` Specifies a pointer to the location where the indices are stored.
`drawcount` Specifies the size of the `count`, `indices` and `basevertex` arrays.

`basevertex` Specifies a pointer to the location where the base vertices are stored.
---
### Description
`glMultiDrawElementsBaseVertex` behaves identically to glDrawElementsBaseVertex, except that
`drawcount` separate lists of elements are specifried instead.

It has the same effect as: for (int i = 0; i < `drawcount` ; i++) if ( `count` [i] > 0)
glDrawElementsBaseVertex( `mode`, `count` [i], `type`, `indices[i]`, `basevertex[i]` );
---
### Notes
`glMultiDrawElementsBaseVertex` is available only if the GL version is 3.1 or greater.

`GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP_ADJACENCY` and
`GL_TRIANGLES_ADJACENCY` are available only if the GL version is 3.2 or greater.
---
### Errors
`GL_INVALID_ENUM` is generated if `mode` is not an accepted value.

`GL_INVALID_VALUE` is generated if `drawcount` is negative.

`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array
or the element array and the buffer object's data store is currently mapped.
---
### Version Support
`glMultiDrawElementsBaseVertex`
---
### See Also
glMultiDrawElements, glDrawElementsBaseVertex, glDrawArrays, glVertexAttribPointer
---
### Copyright
Copyright 2010 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Render primitives from array data
---
### Parameters
`mode` Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`,
`GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`,
`GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`,
`GL_TRIANGLES_ADJACENCY` and `GL_PATCHES` are accepted.

`first` Specifies the starting index in the enabled arrays.
`count` Specifies the number of indices to be rendered.
---
### Description
`glDrawArrays` specifies multiple geometric primitives with very few subroutine calls. Instead of
calling a GL procedure to pass each individual vertex, normal, texture coordinate, edge flag, or
color, you can prespecify separate arrays of vertices, normals, and colors and use them to construct
a sequence of primitives with a single call to `glDrawArrays`.

When `glDrawArrays` is called, it uses `count` sequential elements from each enabled array to
construct a sequence of geometric primitives, beginning with element `first`. `mode` specifies
what kind of primitives are constructed and how the array elements construct those primitives.

Vertex attributes that are modified by `glDrawArrays` have an unspecified value after
`glDrawArrays` returns. Attributes that aren't modified remain well defined.
---
### Notes
`GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP_ADJACENCY` and
`GL_TRIANGLES_ADJACENCY` are available only if the GL version is 3.2 or greater.
---
### Errors
`GL_INVALID_ENUM` is generated if `mode` is not an accepted value.

`GL_INVALID_VALUE` is generated if `count` is negative.

`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array
and the buffer object's data store is currently mapped.

`GL_INVALID_OPERATION` is generated if a geometry shader is active and `mode` is incompatible
with the input primitive type of the geometry shader in the currently installed program object.
---
### Version Support
`glDrawArrays`
---
### See Also
glDrawArraysInstanced, glDrawElements, glDrawRangeElements,
---
### Copyright
Copyright 1991-2006 Silicon Graphics, Inc. Copyright 2010-2014 Khronos Group. This document
is licensed under the SGI Free Software B License. For details, see
https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.
]],
  [[Render indexed primitives from array data, taking parameters from memory
---
### Parameters
`mode` Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`,
`GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`,
`GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`,
`GL_TRIANGLES_ADJACENCY`, and `GL_PATCHES` are accepted.

`type` Specifies the type of data in the buffer bound to the `GL_ELEMENT_ARRAY_BUFFER`
binding.

`indirect` Specifies the address of a structure containing an array of draw parameters.
`drawcount` Specifies the number of elements in the array addressed by `indirect`.

`stride` Specifies the distance in basic machine units between elements of the draw parameter
array.
---
### Description
`glMultiDrawElementsIndirect` specifies multiple indexed geometric primitives with very few
subroutine calls. `glMultiDrawElementsIndirect` behaves similarly to a multitude of calls to
glDrawElementsInstancedBaseVertexBaseInstance, execpt that the parameters to
glDrawElementsInstancedBaseVertexBaseInstance are stored in an array in memory at the address given
by `indirect`, separated by the stride, in basic machine units, specified by `stride`. If
`stride` is zero, then the array is assumed to be tightly packed in memory.

The parameters addressed by `indirect` are packed into a structure that takes the form (in C):
typedef struct { uint count; uint instanceCount; uint firstIndex; int baseVertex; uint baseInstance;
} DrawElementsIndirectCommand;

A single call to `glMultiDrawElementsIndirect` is equivalent, assuming no errors are generated
to: GLsizei n; for (n = 0; n < drawcount; n++) { const DrawElementsIndirectCommand *cmd; if
(stride != 0) { cmd = (const DrawElementsIndirectCommand *)((uintptr)indirect + n * stride); } else
{ cmd = (const DrawElementsIndirectCommand *)indirect + n; }
glDrawElementsInstancedBaseVertexBaseInstance(mode, cmd->count, type, cmd->firstIndex *
size-of-type, cmd->instanceCount, cmd->baseVertex, cmd->baseInstance); }

If a buffer is bound to the `GL_DRAW_INDIRECT_BUFFER` binding at the time of a call to
`glDrawElementsIndirect`, `indirect` is interpreted as an offset, in basic machine units, into
that buffer and the parameter data is read from the buffer rather than from client memory.

Note that indices stored in client memory are not supported. If no buffer is bound to the
`GL_ELEMENT_ARRAY_BUFFER` binding, an error will be generated.

The results of the operation are undefined if the reservedMustBeZero member of the parameter
structure is non-zero. However, no error is generated in this case.

Vertex attributes that are modified by `glDrawElementsIndirect` have an unspecified value after
`glDrawElementsIndirect` returns. Attributes that aren't modified remain well defined.
---
### Notes
The `baseInstance` member of the `DrawElementsIndirectCommand` structure is defined only if
the GL version is 4.2 or greater. For versions of the GL less than 4.2, this parameter is present
but is reserved and should be set to zero. On earlier versions of the GL, behavior is undefined if
it is non-zero.
---
### Errors
`GL_INVALID_ENUM` is generated if `mode` is not an accepted value.

`GL_INVALID_VALUE` is generated if `stride` is not a multiple of four.

`GL_INVALID_VALUE` is generated if `drawcount` is negative.

`GL_INVALID_OPERATION` is generated if no buffer is bound to the `GL_ELEMENT_ARRAY_BUFFER`
binding, or if such a buffer's data store is currently mapped.

`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array
or to the `GL_DRAW_INDIRECT_BUFFER` binding and the buffer object's data store is currently
mapped.

`GL_INVALID_OPERATION` is generated if a geometry shader is active and `mode` is incompatible
with the input primitive type of the geometry shader in the currently installed program object.

`GL_INVALID_OPERATION` is generated if `mode` is `GL_PATCHES` and no tessellation control
shader is active.
---
### Version Support
`glMultiDrawElementsIndirect`
---
### See Also
glDrawArrays, glDrawArraysInstanced, glDrawArraysIndirect, glDrawElements,
glDrawRangeElements, glDrawElementsIndirect, glMultiDrawArraysIndirect
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Delete named textures
---
### Parameters
`n` Specifies the number of textures to be deleted.
`textures` Specifies an array of textures to be deleted.
---
### Description
`glDeleteTextures` deletes `n` textures named by the elements of the array `textures`. After
a texture is deleted, it has no contents or dimensionality, and its name is free for reuse (for
example by glGenTextures ). If a texture that is currently bound is deleted, the binding reverts
to 0 (the default texture).

`glDeleteTextures` silently ignores 0's and names that do not correspond to existing textures.
---
### Errors
`GL_INVALID_VALUE` is generated if `n` is negative.
---
### Associated Gets
glIsTexture
---
### Version Support
`glDeleteTextures`
---
### See Also
glBindTexture, glCopyTexImage1D, glCopyTexImage2D, glGenTextures, glGet,
glGetTexParameter, glTexImage1D, glTexImage2D, glTexParameter
---
### Copyright
Copyright 1991-2006 Silicon Graphics, Inc. Copyright 2010-2014 Khronos Group. This document
is licensed under the SGI Free Software B License. For details, see
https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.
]],
  [[Label a named object identified within a namespace
---
### Parameters
`identifier` The namespace from which the name of the object is allocated.
`name` The name of the object to label.
`length` The length of the label to be used for the object.
`label` The address of a string containing the label to assign to the object.
---
### Description
`glObjectLabel` labels the object identified by `name` within the namespace given by
`identifier`. `identifier` must be one of `GL_BUFFER`, `GL_SHADER`, `GL_PROGRAM`,
`GL_VERTEX_ARRAY`, `GL_QUERY`, `GL_PROGRAM_PIPELINE`, `GL_TRANSFORM_FEEDBACK`, `GL_SAMPLER`,
`GL_TEXTURE`, `GL_RENDERBUFFER`, `GL_FRAMEBUFFER`, to indicate the namespace containing the
names of buffers, shaders, programs, vertex array objects, query objects, program pipelines,
transform feedback objects, samplers, textures, renderbuffers and frame buffers, respectively.

`label` is the address of a string that will be used to label an object. `length` contains the
number of characters in `label`. If `length` is negative, it is implied that `label` contains
a null-terminated string. If `label` is NULL, any debug label is effectively removed from the
object.
---
### Errors
`GL_INVALID_ENUM` is generated if `identifier` is not one of the accepted object types.

`GL_INVALID_OPERATION` is generated if `name` is not the name of an existing object of the type
specified by `identifier`.

`GL_INVALID_VALUE` is generated if the number of characters in `label`, excluding the null
terminator when `length` is negative, is greater than the value of `GL_MAX_LABEL_LENGTH`.
---
### Associated Gets
glGet with argument `GL_MAX_LABEL_LENGTH`.
---
### Version Support
`glObjectLabel`
---
### See Also
glPushDebugGroup, glPopDebugGroup, glObjectPtrLabel.
---
### Copyright
Copyright 2013-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Draw multiple instances of a range of elements
---
### Parameters
`mode` Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`,
`GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`,
`GL_TRIANGLES` `GL_LINES_ADJACENCY`, `GL_LINE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY`,
`GL_TRIANGLE_STRIP_ADJACENCY` and `GL_PATCHES` are accepted.

`first` Specifies the starting index in the enabled arrays.
`count` Specifies the number of indices to be rendered.
`instancecount` Specifies the number of instances of the specified range of indices to be
rendered.
---
### Description
`glDrawArraysInstanced` behaves identically to glDrawArrays except that `instancecount`
instances of the range of elements are executed and the value of the internal counter `instanceID`
advances for each iteration. `instanceID` is an internal 32-bit integer counter that may be read
by a vertex shader as `gl_InstanceID`.

`glDrawArraysInstanced` has the same effect as: if ( mode or count is invalid ) generate
appropriate error else { for (int i = 0; i < instancecount ; i++) { instanceID = i;
glDrawArrays(mode, first, count); } instanceID = 0; }
---
### Errors
`GL_INVALID_ENUM` is generated if `mode` is not one of the accepted values.

`GL_INVALID_OPERATION` is generated if a geometry shader is active and `mode` is incompatible
with the input primitive type of the geometry shader in the currently installed program object.

`GL_INVALID_VALUE` is generated if `count` or `instancecount` is negative.

`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array
and the buffer object's data store is currently mapped.
---
### Version Support
`glDrawArraysInstanced`
---
### See Also
glDrawArrays, glDrawElementsInstanced
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Label a sync object identified by a pointer
---
### Parameters
`ptr` A pointer identifying a sync object.
`length` The length of the label to be used for the object.
`label` The address of a string containing the label to assign to the object.
---
### Description
`glObjectPtrLabel` labels the sync object identified by `ptr`.

`label` is the address of a string that will be used to label the object. `length` contains the
number of characters in `label`. If `length` is negative, it is implied that `label` contains
a null-terminated string. If `label` is NULL, any debug label is effectively removed from the
object.
---
### Errors
`GL_INVALID_VALUE` is generated if `ptr` is not a valid sync object.

`GL_INVALID_VALUE` is generated if the number of characters in `label`, excluding the null
terminator when `length` is negative, is greater than the value of `GL_MAX_LABEL_LENGTH`.
---
### Associated Gets
glGet with argument `GL_MAX_LABEL_LENGTH`.
---
### Version Support
`glObjectPtrLabel`
---
### See Also
glPushDebugGroup, glPopDebugGroup, glObjectLabel.
---
### Copyright
Copyright 2013-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Delete renderbuffer objects
---
### Parameters
`n` Specifies the number of renderbuffer objects to be deleted.
`renderbuffers` A pointer to an array containing `n` renderbuffer objects to be deleted.

---
### Description
`glDeleteRenderbuffers` deletes the `n` renderbuffer objects whose names are stored in the
array addressed by `renderbuffers`. The name zero is reserved by the GL and is silently ignored,
should it occur in `renderbuffers`, as are other unused names. Once a renderbuffer object is
deleted, its name is again unused and it has no contents. If a renderbuffer that is currently bound
to the target `GL_RENDERBUFFER` is deleted, it is as though glBindRenderbuffer had been
executed with a `target` of `GL_RENDERBUFFER` and a `name` of zero.

If a renderbuffer object is attached to one or more attachment points in the currently bound
framebuffer, then it as if glFramebufferRenderbuffer had been called, with a `renderbuffer` of
zero for each attachment point to which this image was attached in the currently bound framebuffer.

In other words, this renderbuffer object is first detached from all attachment ponits in the
currently bound framebuffer. Note that the renderbuffer image is specifically not detached from
any non-bound framebuffers.
---
### Errors
`GL_INVALID_VALUE` is generated if `n` is negative.
---
### Version Support
`glDeleteRenderbuffers`
---
### See Also
glGenRenderbuffers, glFramebufferRenderbuffer, glRenderbufferStorage,
glRenderbufferStorageMultisample
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Specifies the parameters for patch primitives
---
### Parameters
`pname` Specifies the name of the parameter to set. The symbolc constants `GL_PATCH_VERTICES`,
`GL_PATCH_DEFAULT_OUTER_LEVEL`, and `GL_PATCH_DEFAULT_INNER_LEVEL` are accepted.

`value` Specifies the new value for the parameter given by `pname`.

`values` Specifies the address of an array containing the new values for the parameter given by
`pname`.

---
### Description
`glPatchParameter` specifies the parameters that will be used for patch primitives. `pname`
specifies the parameter to modify and must be either `GL_PATCH_VERTICES`,
`GL_PATCH_DEFAULT_OUTER_LEVEL` or `GL_PATCH_DEFAULT_INNER_LEVEL`. For `glPatchParameteri`,
`value` specifies the new value for the parameter specified by `pname`. For `glPatchParameterfv`,
`values` specifies the address of an array containing the new values for the parameter specified
by `pname`.

When `pname` is `GL_PATCH_VERTICES`, `value` specifies the number of vertices that will be
used to make up a single patch primitive. Patch primitives are consumed by the tessellation control
shader (if present) and subsequently used for tessellation. When primitives are specified using
glDrawArrays or a similar function, each patch will be made from `parameter` control points, each
represented by a vertex taken from the enabeld vertex arrays. `parameter` must be greater than
zero, and less than or equal to the value of `GL_MAX_PATCH_VERTICES`.

When `pname` is `GL_PATCH_DEFAULT_OUTER_LEVEL` or `GL_PATCH_DEFAULT_INNER_LEVEL`, `values`
contains the address of an array contiaining the default outer or inner tessellation levels,
respectively, to be used when no tessellation control shader is present.
---
### Errors
`GL_INVALID_ENUM` is generated if `pname` is not an accepted value.

`GL_INVALID_VALUE` is generated if `pname` is `GL_PATCH_VERTICES` and `value` is less than
or equal to zero, or greater than the value of `GL_MAX_PATCH_VERTICES`.
---
### Version Support
`glPatchParameterfv` `glPatchParameteri`
---
### See Also
glDrawArrays, glDrawArraysInstanced, glDrawElements, glDrawRangeElements,
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Specify which color buffers are to be drawn into
---
### Parameters
`framebuffer` Specifies the name of the framebuffer object for `glNamedFramebufferDrawBuffer`
function. Must be zero or the name of a framebuffer object.

`buf` For default framebuffer, the argument specifies up to four color buffers to be drawn into.

Symbolic constants `GL_NONE`, `GL_FRONT_LEFT`, `GL_FRONT_RIGHT`, `GL_BACK_LEFT`,
`GL_BACK_RIGHT`, `GL_FRONT`, `GL_BACK`, `GL_LEFT`, `GL_RIGHT`, and `GL_FRONT_AND_BACK`
are accepted. The initial value is `GL_FRONT` for single-buffered contexts, and `GL_BACK` for
double-buffered contexts. For framebuffer objects, `GL_COLOR_ATTACHMENT$m$` and `GL_NONE` enums
are accepted, where `$m$` is a value between 0 and `GL_MAX_COLOR_ATTACHMENTS`.

---
### Description
When colors are written to the frame buffer, they are written into the color buffers specified by
`glDrawBuffer`. One of the following values can be used for default framebuffer:

`GL_NONE` No color buffers are written.
`GL_FRONT_LEFT` Only the front left color buffer is written.
`GL_FRONT_RIGHT` Only the front right color buffer is written.
`GL_BACK_LEFT` Only the back left color buffer is written.
`GL_BACK_RIGHT` Only the back right color buffer is written.
`GL_FRONT` Only the front left and front right color buffers are written. If there is no front
right color buffer, only the front left color buffer is written.
`GL_BACK` Only the back left and back right color buffers are written. If there is no back right
color buffer, only the back left color buffer is written.
`GL_LEFT` Only the front left and back left color buffers are written. If there is no back left
color buffer, only the front left color buffer is written.
`GL_RIGHT` Only the front right and back right color buffers are written. If there is no back
right color buffer, only the front right color buffer is written.
`GL_FRONT_AND_BACK` All the front and back color buffers (front left, front right, back left,
back right) are written. If there are no back color buffers, only the front left and front right
color buffers are written. If there are no right color buffers, only the front left and back left
color buffers are written. If there are no right or back color buffers, only the front left color
buffer is written.

If more than one color buffer is selected for drawing, then blending or logical operations are
computed and applied independently for each color buffer and can produce different results in each
buffer. Monoscopic contexts include only left buffers, and stereoscopic contexts include both
left and right buffers. Likewise, single-buffered contexts include only front buffers, and
double-buffered contexts include both front and back buffers. The context is selected at GL
initialization.

For framebuffer objects, `GL_COLOR_ATTACHMENT$m$` and `GL_NONE` enums are accepted, where
`$m$` is a value between 0 and `GL_MAX_COLOR_ATTACHMENTS`. glDrawBuffer will set the draw buffer
for fragment colors other than zero to `GL_NONE`.
---
### Errors
`GL_INVALID_OPERATION` error is generated by `glNamedFramebufferDrawBuffer` if `framebuffer`
is not zero or the name of an existing framebuffer object.

`GL_INVALID_ENUM` is generated if `buf` is not an accepted value.

`GL_INVALID_OPERATION` is generated if the default framebuffer is affected and none of the
buffers indicated by `buf` exists.

`GL_INVALID_OPERATION` is generated if a framebuffer object is affected and `buf` is not equal
to `GL_NONE` or `GL_COLOR_ATTACHMENT$m$`, where `$m$` is a value between 0 and
`GL_MAX_COLOR_ATTACHMENTS`.
---
### Associated Gets
glGet with argument `GL_DRAW_BUFFER`
---
### Version Support
`glDrawBuffer` `glNamedFramebufferDrawBuffer`
---
### See Also
glBlendFunc, glColorMask, glDrawBuffers, glLogicOp, glReadBuffer
---
### Copyright
Copyright 1991-2006 Silicon Graphics, Inc. Copyright 2010-2014 Khronos Group. This document
is licensed under the SGI Free Software B License. For details, see
https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.
]],
  [[Specifies a list of color buffers to be drawn into
---
### Parameters
`framebuffer` Specifies the name of the framebuffer object for `glNamedFramebufferDrawBuffers`.

`n` Specifies the number of buffers in `bufs`.

`bufs` Points to an array of symbolic constants specifying the buffers into which fragment
colors or data values will be written.
---
### Description
`glDrawBuffers` and `glNamedFramebufferDrawBuffers` define an array of buffers into which
outputs from the fragment shader data will be written. If a fragment shader writes a value to one or
more user defined output variables, then the value of each variable will be written into the buffer
specified at a location within `bufs` corresponding to the location assigned to that user defined
output. The draw buffer used for user defined outputs assigned to locations greater than or equal to
`n` is implicitly set to `GL_NONE` and any data written to such an output is discarded.

For `glDrawBuffers`, the framebuffer object that is bound to the `GL_DRAW_FRAMEBUFFER` binding
will be used. For `glNamedFramebufferDrawBuffers`, `framebuffer` is the name of the framebuffer
object. If `framebuffer` is zero, then the default framebuffer is affected.

The symbolic constants contained in `bufs` may be any of the following:

`GL_NONE` The fragment shader output value is not written into any color buffer.
`GL_FRONT_LEFT` The fragment shader output value is written into the front left color buffer.
`GL_FRONT_RIGHT` The fragment shader output value is written into the front right color buffer.
`GL_BACK_LEFT` The fragment shader output value is written into the back left color buffer.
`GL_BACK_RIGHT` The fragment shader output value is written into the back right color buffer.
`GL_COLOR_ATTACHMENT` n The fragment shader output value is written into the n th color
attachment of the current framebuffer. n may range from zero to the value of
`GL_MAX_COLOR_ATTACHMENTS`.

Except for `GL_NONE`, the preceding symbolic constants may not appear more than once in `bufs`.

The maximum number of draw buffers supported is implementation dependent and can be queried by
calling glGet with the argument `GL_MAX_DRAW_BUFFERS`.
---
### Notes
The symbolic constants `GL_FRONT`, `GL_BACK`, `GL_LEFT`, `GL_RIGHT`, and
`GL_FRONT_AND_BACK` are not allowed in the `bufs` array since they may refer to multiple buffers.

If a fragment shader does not write to a user defined output variable, the values of the fragment
colors following shader execution are undefined. For each fragment generated in this situation, a
different value may be written into each of the buffers specified by `bufs`.
---
### Errors
`GL_INVALID_OPERATION` error is generated by `glNamedFramebufferDrawBuffers` if `framebuffer`
is not zero or the name of an existing framebuffer object.

`GL_INVALID_ENUM` is generated if one of the values in `bufs` is not an accepted value.

`GL_INVALID_ENUM` is generated if the API call refers to the default framebuffer and one or more
of the values in `bufs` is one of the `GL_COLOR_ATTACHMENT` n tokens.

`GL_INVALID_ENUM` is generated if the API call refers to a framebuffer object and one or more of
the values in `bufs` is anything other than `GL_NONE` or one of the `GL_COLOR_ATTACHMENT` n
tokens.

`GL_INVALID_ENUM` is generated if `n` is less than 0.

`GL_INVALID_OPERATION` is generated if a symbolic constant other than `GL_NONE` appears more
than once in `bufs`.

`GL_INVALID_OPERATION` is generated if any of the entries in `bufs` (other than `GL_NONE` )
indicates a color buffer that does not exist in the current GL context.

`GL_INVALID_OPERATION` is generated if any value in `bufs` is `GL_BACK`, and `n` is not
one.

`GL_INVALID_VALUE` is generated if `n` is greater than `GL_MAX_DRAW_BUFFERS`.
---
### Associated Gets
glGet with argument `GL_MAX_DRAW_BUFFERS`

glGet with argument `GL_DRAW_BUFFER` i where i indicates the number of the draw buffer
whose value is to be queried.
---
### Version Support
`glDrawBuffers` `glNamedFramebufferDrawBuffers`
---
### See Also
glBlendFunc, glColorMask, glDrawBuffers, glLogicOp, glReadBuffer
---
### Copyright
Copyright 2003-2005 3Dlabs Inc. Ltd. Copyright 2010-2014 Khronos Group. This material may be
distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8
June 1999. https://opencontent.org/openpub/.
]],
  [[Pause transform feedback operations
---
### Description
`glPauseTransformFeedback` pauses transform feedback operations on the currently active transform
feedback object. When transform feedback operations are paused, transform feedback is still
considered active and changing most transform feedback state related to the object results in an
error. However, a new transform feedback object may be bound while transform feedback is paused.
---
### Errors
`GL_INVALID_OPERATION` is generated if the currently bound transform feedback object is not
active or is paused.
---
### Version Support
`glPauseTransformFeedback`
---
### See Also
glGenTransformFeedbacks, glBindTransformFeedback, glBeginTransformFeedback,
glResumeTransformFeedback, `glEndTransformFeedback`, glDeleteTransformFeedbacks
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Render primitives from array data
---
### Parameters
`mode` Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`,
`GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`,
`GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`,
`GL_TRIANGLES_ADJACENCY` and `GL_PATCHES` are accepted.

`count` Specifies the number of elements to be rendered.
`type` Specifies the type of the values in `indices`. Must be one of `GL_UNSIGNED_BYTE`,
`GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`.

`indices` Specifies a pointer to the location where the indices are stored.
---
### Description
`glDrawElements` specifies multiple geometric primitives with very few subroutine calls. Instead
of calling a GL function to pass each individual vertex, normal, texture coordinate, edge flag, or
color, you can prespecify separate arrays of vertices, normals, and so on, and use them to construct
a sequence of primitives with a single call to `glDrawElements`.

When `glDrawElements` is called, it uses `count` sequential elements from an enabled array,
starting at `indices` to construct a sequence of geometric primitives. `mode` specifies what
kind of primitives are constructed and how the array elements construct these primitives. If more
than one array is enabled, each is used.

Vertex attributes that are modified by `glDrawElements` have an unspecified value after
`glDrawElements` returns. Attributes that aren't modified maintain their previous values.
---
### Notes
`GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP_ADJACENCY` and
`GL_TRIANGLES_ADJACENCY` are available only if the GL version is 3.2 or greater.
---
### Errors
`GL_INVALID_ENUM` is generated if `mode` is not an accepted value.

`GL_INVALID_VALUE` is generated if `count` is negative.

`GL_INVALID_OPERATION` is generated if a geometry shader is active and `mode` is incompatible
with the input primitive type of the geometry shader in the currently installed program object.

`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array
or the element array and the buffer object's data store is currently mapped.
---
### Version Support
`glDrawElements`
---
### See Also
glDrawArrays, glDrawElementsInstanced, glDrawElementsBaseVertex, glDrawRangeElements
---
### Copyright
Copyright 1991-2006 Silicon Graphics, Inc. Copyright 2010-2014 Khronos Group. This document
is licensed under the SGI Free Software B License. For details, see
https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.
]],
  [[Set pixel storage modes
---
### Parameters
`pname` Specifies the symbolic name of the parameter to be set. Six values affect the packing
of pixel data into memory: `GL_PACK_SWAP_BYTES`, `GL_PACK_LSB_FIRST`, `GL_PACK_ROW_LENGTH`,
`GL_PACK_IMAGE_HEIGHT`, `GL_PACK_SKIP_PIXELS`, `GL_PACK_SKIP_ROWS`, `GL_PACK_SKIP_IMAGES`,
and `GL_PACK_ALIGNMENT`. Six more affect the unpacking of pixel data from memory:
`GL_UNPACK_SWAP_BYTES`, `GL_UNPACK_LSB_FIRST`, `GL_UNPACK_ROW_LENGTH`,
`GL_UNPACK_IMAGE_HEIGHT`, `GL_UNPACK_SKIP_PIXELS`, `GL_UNPACK_SKIP_ROWS`,
`GL_UNPACK_SKIP_IMAGES`, and `GL_UNPACK_ALIGNMENT`.

`param` Specifies the value that `pname` is set to.
]],
  [[Render indexed primitives from array data, taking parameters from memory
---
### Parameters
`mode` Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`,
`GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`,
`GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`,
`GL_TRIANGLES_ADJACENCY`, and `GL_PATCHES` are accepted.

`type` Specifies the type of data in the buffer bound to the `GL_ELEMENT_ARRAY_BUFFER`
binding.

`indirect` Specifies the address of a structure containing the draw parameters.
---
### Description
`glDrawElementsIndirect` specifies multiple indexed geometric primitives with very few subroutine
calls. `glDrawElementsIndirect` behaves similarly to
glDrawElementsInstancedBaseVertexBaseInstance, execpt that the parameters to
glDrawElementsInstancedBaseVertexBaseInstance are stored in memory at the address given by
`indirect`.

The parameters addressed by `indirect` are packed into a structure that takes the form (in C):

typedef struct { uint count; uint instanceCount; uint firstIndex; int baseVertex; uint
baseInstance; } DrawElementsIndirectCommand; `glDrawElementsIndirect` is equivalent to:

void glDrawElementsIndirect(GLenum mode, GLenum type, const void * indirect) { const
DrawElementsIndirectCommand *cmd = (const DrawElementsIndirectCommand *)indirect;
glDrawElementsInstancedBaseVertexBaseInstance(mode, cmd->count, type, cmd->firstIndex *
size-of-type, cmd->instanceCount, cmd->baseVertex, cmd->baseInstance); }

If a buffer is bound to the `GL_DRAW_INDIRECT_BUFFER` binding at the time of a call to
`glDrawElementsIndirect`, `indirect` is interpreted as an offset, in basic machine units, into
that buffer and the parameter data is read from the buffer rather than from client memory.

Note that indices stored in client memory are not supported. If no buffer is bound to the
`GL_ELEMENT_ARRAY_BUFFER` binding, an error will be generated.

The results of the operation are undefined if the reservedMustBeZero member of the parameter
structure is non-zero. However, no error is generated in this case.

Vertex attributes that are modified by `glDrawElementsIndirect` have an unspecified value after
`glDrawElementsIndirect` returns. Attributes that aren't modified remain well defined.
---
### Notes
The `baseInstance` member of the `DrawElementsIndirectCommand` structure is defined only if
the GL version is 4.2 or greater. For versions of the GL less than 4.2, this parameter is present
but is reserved and should be set to zero. On earlier versions of the GL, behavior is undefined if
it is non-zero.
---
### Errors
`GL_INVALID_ENUM` is generated if `mode` is not an accepted value.

`GL_INVALID_OPERATION` is generated if zero is bound to the `GL_ELEMENT_ARRAY_BUFFER` binding,
or if such a buffer's data store is currently mapped.

`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array
or to the `GL_DRAW_INDIRECT_BUFFER` binding and the buffer object's data store is currently
mapped.

`GL_INVALID_OPERATION` is generated if a geometry shader is active and `mode` is incompatible
with the input primitive type of the geometry shader in the currently installed program object.

`GL_INVALID_OPERATION` is generated if `mode` is `GL_PATCHES` and no tessellation control
shader is active.
---
### Version Support
`glDrawElementsIndirect`
---
### See Also
glDrawArrays, glDrawArraysInstanced, glDrawArraysIndirect, glDrawElements,
glDrawRangeElements,
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Specify point parameters
---
### Parameters
`pname` Specifies a single-valued point parameter. `GL_POINT_FADE_THRESHOLD_SIZE`, and
`GL_POINT_SPRITE_COORD_ORIGIN` are accepted.

`param` For `glPointParameterf` and `glPointParameteri`, specifies the value that `pname`
will be set to.

`params` For `glPointParameterfv` and `glPointParameteriv`, specifies a pointer to an array
where the value or values to be assigned to `pname` are stored.

---
### Description
The following values are accepted for `pname` :

`GL_POINT_FADE_THRESHOLD_SIZE` `params` is a single floating-point value that specifies the
threshold value to which point sizes are clamped if they exceed the specified value. The default
value is 1.0.

`GL_POINT_SPRITE_COORD_ORIGIN` `params` is a single enum specifying the point sprite texture
coordinate origin, either `GL_LOWER_LEFT` or `GL_UPPER_LEFT`. The default value is
`GL_UPPER_LEFT`.

---
### Errors
`GL_INVALID_VALUE` is generated if the value specified for `GL_POINT_FADE_THRESHOLD_SIZE` is
less than zero.

`GL_INVALID_ENUM` is generated If the value specified for `GL_POINT_SPRITE_COORD_ORIGIN` is not
`GL_LOWER_LEFT` or `GL_UPPER_LEFT`.
---
### Associated Gets
glGet with argument `GL_POINT_FADE_THRESHOLD_SIZE`

glGet with argument `GL_POINT_SPRITE_COORD_ORIGIN`
---
### Version Support
`glPointParameterf` `glPointParameterfv` `glPointParameteri` `glPointParameteriv`
---
### See Also
glPointSize
---
### Copyright
Copyright 1991-2006 Silicon Graphics, Inc. Copyright 2010-2014 Khronos Group. This document
is licensed under the SGI Free Software B License. For details, see
https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.
]],
  [[Deletes a shader object
---
### Parameters
`shader` Specifies the shader object to be deleted.
---
### Description
`glDeleteShader` frees the memory and invalidates the name associated with the shader object
specified by `shader`. This command effectively undoes the effects of a call to glCreateShader.

If a shader object to be deleted is attached to a program object, it will be flagged for deletion,
but it will not be deleted until it is no longer attached to any program object, for any rendering
context (i.e., it must be detached from wherever it was attached before it will be deleted). A value
of 0 for `shader` will be silently ignored.

To determine whether an object has been flagged for deletion, call glGetShader with arguments
`shader` and `GL_DELETE_STATUS`.
---
### Errors
`GL_INVALID_VALUE` is generated if `shader` is not a value generated by OpenGL.
---
### Associated Gets
glGetAttachedShaders with the program object to be queried

glGetShader with arguments `shader` and `GL_DELETE_STATUS`

glIsShader
---
### Version Support
`glDeleteShader`
---
### See Also
glCreateProgram, glCreateShader, glDetachShader, glUseProgram
---
### Copyright
Copyright 2003-2005 3Dlabs Inc. Ltd. Copyright 2010-2014 Khronos Group. This material may be
distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8
June 1999. https://opencontent.org/openpub/.
]],
  [[Return error information
---
### Description
`glGetError` returns the value of the error flag. Each detectable error is assigned a numeric
code and symbolic name. When an error occurs, the error flag is set to the appropriate error code
value. No other errors are recorded until `glGetError` is called, the error code is returned, and
the flag is reset to `GL_NO_ERROR`. If a call to `glGetError` returns `GL_NO_ERROR`, there has
been no detectable error since the last call to `glGetError`, or since the GL was initialized.

To allow for distributed implementations, there may be several error flags. If any single error
flag has recorded an error, the value of that flag is returned and that flag is reset to
`GL_NO_ERROR` when `glGetError` is called. If more than one flag has recorded an error,
`glGetError` returns and clears an arbitrary error flag value. Thus, `glGetError` should always
be called in a loop, until it returns `GL_NO_ERROR`, if all error flags are to be reset.

Initially, all error flags are set to `GL_NO_ERROR`.

The following errors are currently defined: `GL_NO_ERROR` No error has been recorded. The
value of this symbolic constant is guaranteed to be 0.
`GL_INVALID_ENUM` An unacceptable value is specified for an enumerated argument. The offending
command is ignored and has no other side effect than to set the error flag.
`GL_INVALID_VALUE` A numeric argument is out of range. The offending command is ignored and has
no other side effect than to set the error flag.
`GL_INVALID_OPERATION` The specified operation is not allowed in the current state. The
offending command is ignored and has no other side effect than to set the error flag.
`GL_INVALID_FRAMEBUFFER_OPERATION` The framebuffer object is not complete. The offending
command is ignored and has no other side effect than to set the error flag.
`GL_OUT_OF_MEMORY` There is not enough memory left to execute the command. The state of the GL
is undefined, except for the state of the error flags, after this error is recorded.
`GL_STACK_UNDERFLOW` An attempt has been made to perform an operation that would cause an
internal stack to underflow.
`GL_STACK_OVERFLOW` An attempt has been made to perform an operation that would cause an
internal stack to overflow.

When an error flag is set, results of a GL operation are undefined only if `GL_OUT_OF_MEMORY`
has occurred. In all other cases, the command generating the error is ignored and has no effect on
the GL state or frame buffer contents. If the generating command returns a value, it returns 0. If
`glGetError` itself generates an error, it returns 0.
---
### Version Support
`glGetError`
---
### See Also
---
### Copyright
Copyright 1991-2006 Silicon Graphics, Inc. Copyright 2010-2014 Khronos Group. This document
is licensed under the SGI This document is licensed under the SGI Free Software B License. For
details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.
]],
  [[Retrieve a sub-region of a compressed texture image from a compressed texture object
---
### Parameters
`texture` Specifies the name of the source texture object. Must be `GL_TEXTURE_1D`,
`GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_3D`,
`GL_TEXTURE_CUBE_MAP`, `GL_TEXTURE_CUBE_MAP_ARRAY` or `GL_TEXTURE_RECTANGLE`. In specific,
buffer and multisample textures are not permitted.

`level` Specifies the level-of-detail number. Level 0 is the base image level. Level $n$ is the
$n$th mipmap reduction image.
`xoffset` Specifies a texel offset in the x direction within the texture array.
`yoffset` Specifies a texel offset in the y direction within the texture array.
`zoffset` Specifies a texel offset in the z direction within the texture array.
`width` Specifies the width of the texture subimage. Must be a multiple of the compressed
block's width, unless the `offset` is zero and the size equals the texture image size.

`height` Specifies the height of the texture subimage. Must be a multiple of the compressed
block's height, unless the `offset` is zero and the size equals the texture image size.

`depth` Specifies the depth of the texture subimage. Must be a multiple of the compressed
block's depth, unless the `offset` is zero and the size equals the texture image size.

`bufSize` Specifies the size of the buffer to receive the retrieved pixel data.
`pixels` Returns the texture subimage. Should be a pointer to an array of the type specified by
type.
---
### Description
`glGetCompressedTextureSubImage` can be used to obtain a sub-region of a compressed texture image
instead of the whole image, as long as the compressed data are arranged into fixed-size blocks of
texels. `texture` is the name of the texture object, and must not be a buffer or multisample
texture. The effective `target` is the value of `GL_TEXTURE_TARGET` for texture. `level` and
`pixels` have the same meaning as the corresponding arguments of `glCompressedTexSubImage3D`.
`bufSize` indicates the size of the buffer to receive the retrieved pixel data.

For cube map textures, the behavior is as though `glGetCompressedTexImage` were called once for
each requested face (selected by `zoffset` and `depth`, as described below) with target
corresponding to the requested texture cube map face as indicated by the table presented below.
`pixels` is offset appropriately for each successive image.

Layer number Cube Map Face 0 `GL_TEXTURE_CUBE_MAP_POSITIVE_X` 1
`GL_TEXTURE_CUBE_MAP_NEGATIVE_X` 2 `GL_TEXTURE_CUBE_MAP_POSITIVE_Y` 3
`GL_TEXTURE_CUBE_MAP_NEGATIVE_Y` 4 `GL_TEXTURE_CUBE_MAP_POSITIVE_Z` 5
`GL_TEXTURE_CUBE_MAP_NEGATIVE_Z` `xoffset`, `yoffset` and `zoffset` indicate the position of
the subregion to return. `width`, `height` and `depth` indicate the size of the region to
return. These arguments have the same meaning as for `glCompressedTexSubImage3D`, though there are
extra restrictions, described in the errors section below.

The mapping between the `xoffset`, `yoffset`, `zoffset`, `width`, `height` and `depth`
parameters and the faces, layers, and layer-faces for cube map, array, and cube map array textures
is the same as for glGetTextureSubImage.

The `xoffset`, `yoffset`, `zoffset` offsets and `width`, `height` and `depth` sizes
must be multiples of the values of `GL_PACK_COMPRESSED_BLOCK_WIDTH`,
`GL_PACK_COMPRESSED_BLOCK_HEIGHT`, and `GL_PACK_COMPRESSED_BLOCK_DEPTH` respectively, unless
`offset` is zero and the corresponding `size` is the same as the texture size in that dimension.

Pixel storage modes are treated as for `glGetCompressedTexSubImage`. The texel at ( `xoffset`,
`yoffset`, `zoffset` ) will be stored at the location indicated by `pixels` and the current
pixel packing parameters.
---
### Errors
`GL_INVALID_OPERATION` error is generated if `texture` is the name of a buffer or multisample
texture.

`GL_INVALID_OPERATION` error is generated if the buffer size required to store the requested data
is greater than `bufSize`.

`GL_INVALID_OPERATION` error is generated if the texture compression format is not based on
fixed-size blocks.

`GL_INVALID_VALUE` error is generated if `texture` is not the name of an existing texture
object.

`GL_INVALID_VALUE` is generated if `xoffset`, `yoffset` or `zoffset` are negative.

`GL_INVALID_VALUE` is generated if `xoffset` + `width` is greater than the texture's width,
`yoffset` + `height` is greater than the texture's height, or `zoffset` + `depth` is greater
than the texture's depth.

`GL_INVALID_VALUE` error is generated if the effective target is `GL_TEXTURE_1D` and either
`yoffset` is not zero, or `height` is not one.

`GL_INVALID_VALUE` error is generated if the effective target is `GL_TEXTURE_1D`,
`GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D` or `GL_TEXTURE_RECTANGLE` and either `zoffset` is not
zero, or `depth` is not one.

`GL_INVALID_VALUE` error is generated if `xoffset`, `yoffset` or `zoffset` is not a
multiple of the compressed block width, height or depth respectively.

`GL_INVALID_VALUE` error is generated if `width`, `height` or `depth` is not a multiple of
the compressed block width, height or depth respectively, unless the `offset` is zero and the
`size` equals the texture image size.
---
### Version Support
`glGetCompressedTextureSubImage`
---
### See Also
glCompressedTexImage1D, glCompressedTexImage2D, glCompressedTexImage3D,
glCompressedTexSubImage1D, glCompressedTexSubImage2D, glCompressedTexSubImage3D,
glGetCompressedTexImage, `glGetCompressedTextureImage`, glReadPixels
---
### Copyright
Copyright 2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Specify the diameter of rasterized points
---
### Parameters
`size` Specifies the diameter of rasterized points. The initial value is 1.
---
### Description
`glPointSize` specifies the rasterized diameter of points. If point size mode is disabled (see
glEnable with parameter `GL_PROGRAM_POINT_SIZE` ), this value will be used to rasterize points.

Otherwise, the value written to the shading language built-in variable gl_PointSize will be used.

---
### Notes
The point size specified by `glPointSize` is always returned when `GL_POINT_SIZE` is queried.

Clamping and rounding for points have no effect on the specified value.
---
### Errors
`GL_INVALID_VALUE` is generated if `size` is less than or equal to 0.
---
### Associated Gets
glGet with argument `GL_POINT_SIZE_RANGE`

glGet with argument `GL_POINT_SIZE_GRANULARITY`

glGet with argument `GL_POINT_SIZE`

glGet with argument `GL_POINT_FADE_THRESHOLD_SIZE`

glIsEnabled with argument `GL_PROGRAM_POINT_SIZE`
---
### Version Support
`glPointSize`
---
### See Also
glEnable, glPointParameter
---
### Copyright
Copyright 1991-2006 Silicon Graphics, Inc. Copyright 2010-2014 Khronos Group. This document
is licensed under the SGI Free Software B License. For details, see
https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.
]],
  [[Select a polygon rasterization mode
---
### Parameters
`face` Specifies the polygons that `mode` applies to. Must be `GL_FRONT_AND_BACK` for
front- and back-facing polygons.

`mode` Specifies how polygons will be rasterized. Accepted values are `GL_POINT`, `GL_LINE`,
and `GL_FILL`. The initial value is `GL_FILL` for both front- and back-facing polygons.

---
### Description
`glPolygonMode` controls the interpretation of polygons for rasterization. `face` describes
which polygons `mode` applies to: both front and back-facing polygons ( `GL_FRONT_AND_BACK` ). The
polygon mode affects only the final rasterization of polygons. In particular, a polygon's vertices
are lit and the polygon is clipped and possibly culled before these modes are applied.

Three modes are defined and can be specified in `mode` :

`GL_POINT` Polygon vertices that are marked as the start of a boundary edge are drawn as
points. Point attributes such as `GL_POINT_SIZE` and `GL_POINT_SMOOTH` control the rasterization
of the points. Polygon rasterization attributes other than `GL_POLYGON_MODE` have no effect.

`GL_LINE` Boundary edges of the polygon are drawn as line segments. Line attributes such as
`GL_LINE_WIDTH` and `GL_LINE_SMOOTH` control the rasterization of the lines. Polygon
rasterization attributes other than `GL_POLYGON_MODE` have no effect.

`GL_FILL` The interior of the polygon is filled. Polygon attributes such as
`GL_POLYGON_SMOOTH` control the rasterization of the polygon.

---
### Examples
To draw a surface with outlined polygons, call glPolygonMode( `GL_FRONT_AND_BACK`, `GL_LINE`
);
---
### Notes
Vertices are marked as boundary or nonboundary with an edge flag. Edge flags are generated
internally by the GL when it decomposes triangle stips and fans.
---
### Errors
`GL_INVALID_ENUM` is generated if either `face` or `mode` is not an accepted value.
---
### Associated Gets
glGet with argument `GL_POLYGON_MODE`
---
### Version Support
`glPolygonMode`
---
### See Also
glLineWidth, glPointSize
---
### Copyright
Copyright 1991-2006 Silicon Graphics, Inc. Copyright 2010-2014 Khronos Group. This document
is licensed under the SGI Free Software B License. For details, see
https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.
]],
  [[Retrieve the value of a subroutine uniform of a given shader stage of the current program
---
### Parameters
`shadertype` Specifies the shader stage from which to query for subroutine uniform index.
`shadertype` must be one of `GL_VERTEX_SHADER`, `GL_TESS_CONTROL_SHADER`,
`GL_TESS_EVALUATION_SHADER`, `GL_GEOMETRY_SHADER` or `GL_FRAGMENT_SHADER`.

`location` Specifies the location of the subroutine uniform.
`values` Specifies the address of a variable to receive the value or values of the subroutine
uniform.
---
### Description
`glGetUniformSubroutine` retrieves the value of the subroutine uniform at location `location`
for shader stage `shadertype` of the current program. `location` must be less than the value of
`GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS` for the shader currently in use at shader stage
`shadertype`. The value of the subroutine uniform is returned in `values`.
---
### Errors
`GL_INVALID_ENUM` is generated if `shadertype` is not one of the accepted values.

`GL_INVALID_VALUE` is generated if `location` is greater than or equal to the value of
`GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS` for the shader currently in use at shader stage
`shadertype`.

`GL_INVALID_OPERATION` is generated if no program is active.
---
### Version Support
`glGetUniformSubroutineuiv`
---
### See Also
glGetProgram, glGetActiveSubroutineUniform, glGetActiveSubroutineUniformName,
glGetUniformLocation
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Set the scale and units used to calculate depth values
---
### Parameters
`factor` Specifies a scale factor that is used to create a variable depth offset for each
polygon. The initial value is 0.
`units` Is multiplied by an implementation-specific value to create a constant depth offset.

The initial value is 0.
]],
  [[Retrieve the index of a named uniform block
---
### Parameters
`program` Specifies the name of a program containing the uniform block.
`uniformBlockName` Specifies the address an array of characters to containing the name of the
uniform block whose index to retrieve.
---
### Description
`glGetUniformBlockIndex` retrieves the index of a uniform block within `program`.

`program` must be the name of a program object for which the command glLinkProgram must have
been called in the past, although it is not required that glLinkProgram must have succeeded. The
link could have failed because the number of active uniforms exceeded the limit.

`uniformBlockName` must contain a nul-terminated string specifying the name of the uniform block.

`glGetUniformBlockIndex` returns the uniform block index for the uniform block named
`uniformBlockName` of `program`. If `uniformBlockName` does not identify an active uniform
block of `program`, `glGetUniformBlockIndex` returns the special identifier, `GL_INVALID_INDEX`.
Indices of the active uniform blocks of a program are assigned in consecutive order, beginning
with zero.
---
### Errors
`GL_INVALID_OPERATION` is generated if `program` is not the name of a program object for which
glLinkProgram has been called in the past.
---
### Notes
`glGetUniformBlockIndex` is available only if the GL version is 3.1 or greater.
---
### Version Support
`glGetUniformBlockIndex`
---
### See Also
glGetActiveUniformBlockName, glGetActiveUniformBlock, glLinkProgram
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Pop the active debug group
---
### Description
`glPopDebugGroup` pops the active debug group. After popping a debug group, the GL will also
generate a debug output message describing its cause based on the `message` string, the source
`source`, and an ID `id` submitted to the corresponding glPushDebugGroup command.
`GL_DEBUG_TYPE_PUSH_GROUP` and `GL_DEBUG_TYPE_POP_GROUP` share a single namespace for message
`id`. `severity` has the value `GL_DEBUG_SEVERITY_NOTIFICATION`. The `type` has the value
`GL_DEBUG_TYPE_POP_GROUP`. Popping a debug group restores the debug output volume control of the
parent debug group.
---
### Errors
`GL_STACK_UNDERFLOW` is generated if an attempt is made to pop the default debug group from the
stack.
---
### Associated Gets
glGet with argument `GL_MAX_DEBUG_MESSAGE_LENGTH`.
---
### Version Support
`glPopDebugGroup`
---
### See Also
glPushDebugGroup, glObjectLabel, glObjectPtrLabel.
---
### Copyright
Copyright 2013-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Retrieve parameters of a vertex array object
---
### Parameters
`vaobj` specifies the name of the vertex array object to use for the query.
`pname` Name of the property to use for the query. Must be `GL_ELEMENT_ARRAY_BUFFER_BINDING`.

`param` Returns the requested value.
---
### Description
This function provides a mean of querying properties of an existing vertex array object. The vertex
array object does not have to be bound to the rendering context at the time of the call, but must
have been bound at least once prior to this call. `glGetVertexArrayiv` can be used to retrieve ID
of a buffer object that will be bound to the `GL_ELEMENT_ARRAY_BUFFER` binding point whenever the
queried vertex array object is bound to the rendering context. The binding can be changed for an
active vertex array object with a `glBindBuffer` call.
---
### Errors
`GL_INVALID_OPERATION` error is generated if `vaobj` is not the name of an existing vertex
array object.

`GL_INVALID_ENUM` error is generated if `pname` is not `GL_ELEMENT_ARRAY_BUFFER_BINDING`.
---
### Version Support
`glGetVertexArrayiv`
---
### See Also
glBindBuffer, glBindVertexArray, glGet
---
### Copyright
Copyright 2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Specify the primitive restart index
---
### Parameters
`index` Specifies the value to be interpreted as the primitive restart index.
---
### Description
`glPrimitiveRestartIndex` specifies a vertex array element that is treated specially when
primitive restarting is enabled. This is known as the primitive restart index.

When one of the `Draw*` commands transfers a set of generic attribute array elements to the GL,
if the index within the vertex arrays corresponding to that set is equal to the primitive restart
index, then the GL does not process those elements as a vertex. Instead, it is as if the drawing
command ended with the immediately preceding transfer, and another drawing command is immediately
started with the same parameters, but only transferring the immediately following element through
the end of the originally specified elements.

When either glDrawElementsBaseVertex, glDrawElementsInstancedBaseVertex or
glMultiDrawElementsBaseVertex is used, the primitive restart comparison occurs before the
basevertex offset is added to the array index.
---
### Notes
`glPrimitiveRestartIndex` is available only if the GL version is 3.1 or greater.
---
### Version Support
`glPrimitiveRestartIndex`
---
### See Also
glDrawArrays, glDrawElements, glDrawElementsBaseVertex,
glDrawElementsInstancedBaseVertex
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Returns the location of a uniform variable
---
### Parameters
`program` Specifies the program object to be queried.
`name` Points to a null terminated string containing the name of the uniform variable whose
location is to be queried.
---
### Description
`glGetUniformLocation ` returns an integer that represents the location of a specific uniform
variable within a program object. `name` must be a null terminated string that contains no white
space. `name` must be an active uniform variable name in `program` that is not a structure, an
array of structures, or a subcomponent of a vector or a matrix. This function returns -1 if `name`
does not correspond to an active uniform variable in `program`, if `name` starts with the
reserved prefix "gl_", or if `name` is associated with an atomic counter or a named uniform block.

Uniform variables that are structures or arrays of structures may be queried by calling
`glGetUniformLocation` for each field within the structure. The array element operator "[]" and the
structure field operator "." may be used in `name` in order to select elements within an array or
fields within a structure. The result of using these operators is not allowed to be another
structure, an array of structures, or a subcomponent of a vector or a matrix. Except if the last
part of `name` indicates a uniform variable array, the location of the first element of an array
can be retrieved by using the name of the array, or by using the name appended by "[0]".

The actual locations assigned to uniform variables are not known until the program object is linked
successfully. After linking has occurred, the command `glGetUniformLocation` can be used to obtain
the location of a uniform variable. This location value can then be passed to glUniform to set
the value of the uniform variable or to glGetUniform in order to query the current value of the
uniform variable. After a program object has been linked successfully, the index values for uniform
variables remain fixed until the next link command occurs. Uniform variable locations and values can
only be queried after a link if the link was successful.
---
### Errors
`GL_INVALID_VALUE` is generated if `program` is not a value generated by OpenGL.

`GL_INVALID_OPERATION` is generated if `program` is not a program object.

`GL_INVALID_OPERATION` is generated if `program` has not been successfully linked.
---
### Associated Gets
glGetActiveUniform with arguments `program` and the index of an active uniform variable

glGetProgram with arguments `program` and `GL_ACTIVE_UNIFORMS` or
`GL_ACTIVE_UNIFORM_MAX_LENGTH`

glGetUniform with arguments `program` and the name of a uniform variable

glIsProgram
---
### Version Support
`glGetUniformLocation`
---
### See Also
glLinkProgram, glUniform
---
### Copyright
Copyright 2003-2005 3Dlabs Inc. Ltd. Copyright 2010-2014 Khronos Group. This material may be
distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8
June 1999. https://opencontent.org/openpub/.
]],
  [[Load a program object with a program binary
---
### Parameters
`program` Specifies the name of a program object into which to load a program binary.
`binaryFormat` Specifies the format of the binary data in binary.
`binary` Specifies the address an array containing the binary to be loaded into `program`.

`length` Specifies the number of bytes contained in `binary`.

---
### Description
`glProgramBinary` loads a program object with a program binary previously returned from
glGetProgramBinary. `binaryFormat` and `binary` must be those returned by a previous call to
glGetProgramBinary, and `length` must be the length returned by glGetProgramBinary, or by
glGetProgram when called with `pname` set to `GL_PROGRAM_BINARY_LENGTH`. If these conditions
are not met, loading the program binary will fail and `program` 's `GL_LINK_STATUS` will be set
to `GL_FALSE`.

A program object's program binary is replaced by calls to glLinkProgram or `glProgramBinary`.

When linking success or failure is concerned, `glProgramBinary` can be considered to perform an
implicit linking operation. glLinkProgram and `glProgramBinary` both set the program object's
`GL_LINK_STATUS` to `GL_TRUE` or `GL_FALSE`.

A successful call to `glProgramBinary` will reset all uniform variables to their initial values.

The initial value is either the value of the variable's initializer as specified in the original
shader source, or zero if no initializer was present. Additionally, all vertex shader input and
fragment shader output assignments that were in effect when the program was linked before saving are
restored with `glProgramBinary` is called.
---
### Errors
`GL_INVALID_OPERATION` is generated if `program` is not the name of an existing program object.

`GL_INVALID_ENUM` is generated if `binaryFormat` is not a value recognized by the
implementation.
---
### Notes
A program binary may fail to load if the implementation determines that there has been a change in
hardware or software configuration from when the program binary was produced such as having been
compiled with an incompatible or outdated version of the compiler.
---
### Associated Gets
glGetProgram with argument `GL_PROGRAM_BINARY_LENGTH`

glGet with argument `GL_NUM_PROGRAM_BINARY_FORMATS`

glGet with argument `GL_PROGRAM_BINARY_FORMATS`
---
### Version Support
`glProgramBinary`
---
### See Also
glGetProgram, glGetProgramBinary
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Retrieve parameters of an attribute of a vertex array object
---
### Parameters
`vaobj` Specifies the name of a vertex array object.
`index` Specifies the index of the vertex array object attribute. Must be a number between 0 and
( `GL_MAX_VERTEX_ATTRIBS` - 1).

`pname` Specifies the property to be used for the query. For `glGetVertexArrayIndexediv`, it
must be one of the following values: `GL_VERTEX_ATTRIB_ARRAY_ENABLED`,
`GL_VERTEX_ATTRIB_ARRAY_SIZE`, `GL_VERTEX_ATTRIB_ARRAY_STRIDE`, `GL_VERTEX_ATTRIB_ARRAY_TYPE`,
`GL_VERTEX_ATTRIB_ARRAY_NORMALIZED`, `GL_VERTEX_ATTRIB_ARRAY_INTEGER`,
`GL_VERTEX_ATTRIB_ARRAY_LONG`, `GL_VERTEX_ATTRIB_ARRAY_DIVISOR`, or
`GL_VERTEX_ATTRIB_RELATIVE_OFFSET`. For `glGetVertexArrayIndexed64v`, it must be equal to
`GL_VERTEX_BINDING_OFFSET`.

`param` Returns the requested value.
---
### Description
`glGetVertexArrayIndexediv` and `glGetVertexArrayIndexed64iv` provide a way of querying
parameters of an attribute at an user-specified index of a vertex array object. The vertex array
object does not have to be bound to the rendering context at the time of the call, but must have
been bound at least once prior to this call.

The following parameter values can be retrieved with `glGetVertexArrayIndexediv` for each of the
attributes defined for a vertex array object:

`GL_VERTEX_ATTRIB_ARRAY_ENABLED` : `param` returns a value that is non-zero (true) if the
vertex attribute array for index is enabled and 0 (false) if it is disabled. The initial value is
`GL_FALSE`.

`GL_VERTEX_ATTRIB_ARRAY_SIZE` : `param` returns a single value, the size of the vertex
attribute array for index. The size is the number of values for each element of the vertex attribute
array, and it will be 1, 2, 3 or 4. The initial value is 4.

`GL_VERTEX_ATTRIB_ARRAY_STRIDE` : `param` returns a single value, the array stride for (number
of bytes between successive elements in) the vertex attribute array for index. A value of 0
indicates the array elements are stored sequentially in memory. The initial value is 0.

`GL_VERTEX_ATTRIB_ARRAY_TYPE` : `param` returns a single value, a symbolic constant indicating
the array type for the vertex attribute array for index. Possible values are `GL_BYTE`,
`GL_DOUBLE`, `GL_FIXED`, `GL_FLOAT`, `GL_HALF_FLOAT`, `GL_INT`, `GL_INT_2_10_10_10_REV`,
`GL_SHORT`, `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT`, `GL_UNSIGNED_INT`,
`GL_UNSIGNED_INT_2_10_10_10_REV`, and `GL_UNSIGNED_INT_10F_11F_11F_REV`. The initial value is
`GL_FLOAT`.

`GL_VERTEX_ATTRIB_ARRAY_NORMALIZED` : `param` returns a single value that is non-zero (true) if
fixed-point data types for the vertex attribute array indicated by index are normalized when they
are converted to floating-point, and 0 (false) otherwise. The initial value is `GL_FALSE`.

`GL_VERTEX_ATTRIB_ARRAY_INTEGER` : `param` returns a single value that is non-zero (true) if
fixed-point data types for the vertex attribute array indicated by index have integer data type, and
0 (false) otherwise. The initial value is 0 ( `GL_FALSE` ).

`GL_VERTEX_ATTRIB_ARRAY_LONG` : `param` returns a single value that is non-zero (true) if a
vertex attribute is stored as an unconverted double, and 0 (false) otherwise. The initial value is 0
( `GL_FALSE` ).

`GL_VERTEX_ATTRIB_ARRAY_DIVISOR` : `param` returns a single value that is the frequency divisor
used for instanced rendering. See glVertexAttribDivisor. The initial value is 0.

`GL_VERTEX_ATTRIB_RELATIVE_OFFSET` : `param` returns a single value that is the byte offset of
the first element relative to the start of the vertex buffer binding specified attribute fetches
from. The initial value is 0.

`glGetVertexArrayIndexed64iv` can be used to retrieve `GL_VERTEX_BINDING_OFFSET` parameter value
for any of the attributes defined for a vertex array object. When `pname` is set to
`GL_VERTEX_BINDING_OFFSET`, `param` returns a single value that is the byte offset of the first
element in the bound buffer's data store. The initial value for this parameter is 0.
---
### Errors
`GL_INVALID_OPERATION` error is generated if `vaobj` is not the name of an existing vertex
array object.

`GL_INVALID_VALUE` error is generated if index is greater than or equal to the value of
`GL_MAX_VERTEX_ATTRIBS`.

`GL_INVALID_ENUM` error is generated if `pname` is not one of the valid values. For more
details, please see above.
---
### Version Support
`glGetVertexArrayIndexed64iv` `glGetVertexArrayIndexediv`
---
### See Also
glGetVertexAttrib, glVertexAttribBinding, `glVertexAttribIPointer`,
`glVertexAttribLPointer`, glVertexAttribPointer
---
### Copyright
Copyright 2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Specify a parameter for a program object
---
### Parameters
`program` Specifies the name of a program object whose parameter to modify.
`pname` Specifies the name of the parameter to modify.
`value` Specifies the new value of the parameter specified by `pname` for `program`.

---
### Description
`glProgramParameter` specifies a new value for the parameter nameed by `pname` for the program
object `program`.

If `pname` is `GL_PROGRAM_BINARY_RETRIEVABLE_HINT`, `value` should be `GL_FALSE` or
`GL_TRUE` to indicate to the implementation the intention of the application to retrieve the
program's binary representation with glGetProgramBinary. The implementation may use this
information to store information that may be useful for a future query of the program's binary. It
is recommended to set `GL_PROGRAM_BINARY_RETRIEVABLE_HINT` for the program to `GL_TRUE` before
calling glLinkProgram, and using the program at run-time if the binary is to be retrieved later.

If `pname` is `GL_PROGRAM_SEPARABLE`, `value` must be `GL_TRUE` or `GL_FALSE` and
indicates whether `program` can be bound to individual pipeline stages via glUseProgramStages.

A program's `GL_PROGRAM_SEPARABLE` parameter must be set to `GL_TRUE` before glLinkProgram is
called in order for it to be usable with a program pipeline object. The initial state of
`GL_PROGRAM_SEPARABLE` is `GL_FALSE`.
---
### Errors
`GL_INVALID_OPERATION` is generated if `program` is not the name of an existing program object.

`GL_INVALID_ENUM` is generated if `pname` is not one of the accepted values.

`GL_INVALID_VALUE` is generated if `value` is not a valid value for the parameter named by
`pname`.
---
### Associated Gets
glGetProgram.
---
### Version Support
`glProgramParameteri`
---
### See Also
glGetProgram, glGetProgramBinary, glProgramBinary
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Retrieve the index of a named uniform block
---
### Parameters
`program` Specifies the name of a program containing uniforms whose indices to query.
`uniformCount` Specifies the number of uniforms whose indices to query.
`uniformNames` Specifies the address of an array of pointers to buffers containing the names of
the queried uniforms.
`uniformIndices` Specifies the address of an array that will receive the indices of the
uniforms.
---
### Description
`glGetUniformIndices` retrieves the indices of a number of uniforms within `program`.

`program` must be the name of a program object for which the command glLinkProgram must have
been called in the past, although it is not required that glLinkProgram must have succeeded. The
link could have failed because the number of active uniforms exceeded the limit.

`uniformCount` indicates both the number of elements in the array of names `uniformNames` and
the number of indices that may be written to `uniformIndices`.

`uniformNames` contains a list of `uniformCount` name strings identifying the uniform names to
be queried for indices. For each name string in `uniformNames`, the index assigned to the active
uniform of that name will be written to the corresponding element of `uniformIndices`. If a string
in `uniformNames` is not the name of an active uniform, the special value `GL_INVALID_INDEX`
will be written to the corresponding element of `uniformIndices`.

If an error occurs, nothing is written to `uniformIndices`.
---
### Errors
`GL_INVALID_OPERATION` is generated if `program` is not the name of a program object for which
glLinkProgram has been called in the past.
---
### Notes
`glGetUniformIndices` is available only if the GL version is 3.1 or greater.
---
### Version Support
`glGetUniformIndices`
---
### See Also
glGetActiveUniform, glGetActiveUniformName, glLinkProgram
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Query the bindings of color numbers to user-defined varying out variables
---
### Parameters
`program` The name of the program containing varying out variable whose binding to query
`name` The name of the user-defined varying out variable whose binding to query
---
### Description
`glGetFragDataLocation` retrieves the assigned color number binding for the user-defined varying
out variable `name` for program `program`. `program` must have previously been linked. `name`
must be a null-terminated string. If `name` is not the name of an active user-defined varying out
fragment shader variable within `program`, -1 will be returned.
---
### Errors
`GL_INVALID_OPERATION` is generated if `program` is not the name of a program object.
---
### Version Support
`glGetFragDataLocation`
---
### See Also
glCreateProgram, glBindFragDataLocation
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Returns a subset of a buffer object's data store
---
### Parameters
`target` Specifies the target to which the buffer object is bound for `glGetBufferSubData`,
which must be one of the buffer binding targets in the following table:

`buffer` Specifies the name of the buffer object for `glGetNamedBufferSubData`.

`offset` Specifies the offset into the buffer object's data store from which data will be
returned, measured in bytes.
`size` Specifies the size in bytes of the data store region being returned.
`data` Specifies a pointer to the location where buffer object data is returned.
---
### Description
`glGetBufferSubData` and `glGetNamedBufferSubData` return some or all of the data contents of
the data store of the specified buffer object. Data starting at byte offset `offset` and extending
for `size` bytes is copied from the buffer object's data store to the memory pointed to by `data`.
An error is thrown if the buffer object is currently mapped, or if `offset` and `size`
together define a range beyond the bounds of the buffer object's data store.
---
### Notes
If an error is generated, no change is made to the contents of `data`.

The `GL_ATOMIC_COUNTER_BUFFER` target is available only if the GL version is 4.2 or greater.

The `GL_DISPATCH_INDIRECT_BUFFER` and `GL_SHADER_STORAGE_BUFFER` targets are available only if
the GL version is 4.3 or greater.

The `GL_QUERY_BUFFER` target is available only if the GL version is 4.4 or greater.
---
### Errors
`GL_INVALID_ENUM` is generated by `glGetBufferSubData` if `target` is not one of the generic
buffer binding targets.

`GL_INVALID_OPERATION` is generated by `glGetBufferSubData` if zero is bound to `target`.

`GL_INVALID_OPERATION` is generated by `glGetNamedBufferSubData` if `buffer` is not the name
of an existing buffer object.

`GL_INVALID_VALUE` is generated if `offset` or `size` is negative, or if $offset + size$ is
greater than the value of `GL_BUFFER_SIZE` for the buffer object.

`GL_INVALID_OPERATION` is generated if the buffer object is mapped with glMapBufferRange or
glMapBuffer, unless it was mapped with the `GL_MAP_PERSISTENT_BIT` bit set in the
`glMapBufferRange` `access` flags.
---
### Version Support
`glGetBufferSubData` `glGetNamedBufferSubData`
---
### See Also
glBindBuffer, glBufferData, glBufferSubData, glMapBuffer, glUnmapBuffer
---
### Copyright
Copyright 2005 Addison-Wesley. Copyright 2011-2014 Khronos Group. This material may be
distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8
June 1999. https://opencontent.org/openpub/.
]],
  [[Draw multiple instances of a set of elements
---
### Parameters
`mode` Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`,
`GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`,
`GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`,
`GL_TRIANGLES_ADJACENCY` and `GL_PATCHES` are accepted.

`count` Specifies the number of elements to be rendered.
`type` Specifies the type of the values in `indices`. Must be one of `GL_UNSIGNED_BYTE`,
`GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`.

`indices` Specifies a pointer to the location where the indices are stored.
`instancecount` Specifies the number of instances of the specified range of indices to be
rendered.
---
### Description
`glDrawElementsInstanced` behaves identically to glDrawElements except that `instancecount`
instances of the set of elements are executed and the value of the internal counter `instanceID`
advances for each iteration. `instanceID` is an internal 32-bit integer counter that may be read
by a vertex shader as `gl_InstanceID`.

`glDrawElementsInstanced` has the same effect as: if (mode, count, or type is invalid )
generate appropriate error else { for (int i = 0; i < instancecount ; i++) { instanceID = i;
glDrawElements(mode, count, type, indices); } instanceID = 0; }
---
### Notes
`glDrawElementsInstanced` is available only if the GL version is 3.1 or greater.

`GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP_ADJACENCY` and
`GL_TRIANGLES_ADJACENCY` are available only if the GL version is 3.2 or greater.
---
### Errors
`GL_INVALID_ENUM` is generated if `mode` is not one of `GL_POINTS`, `GL_LINE_STRIP`,
`GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, or `GL_TRIANGLES`.

`GL_INVALID_VALUE` is generated if `count` or `instancecount` is negative.

`GL_INVALID_OPERATION` is generated if a geometry shader is active and `mode` is incompatible
with the input primitive type of the geometry shader in the currently installed program object.

`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array
and the buffer object's data store is currently mapped.
---
### Version Support
`glDrawElementsInstanced`
---
### See Also
glDrawElements, glDrawArraysInstanced
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Render primitives from array data with a per-element offset
---
### Parameters
`mode` Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`,
`GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`,
`GL_TRIANGLES`, `GL_LINES_ADJACENCY`, `GL_LINE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY`,
`GL_TRIANGLE_STRIP_ADJACENCY` and `GL_PATCHES` are accepted.

`count` Specifies the number of elements to be rendered.
`type` Specifies the type of the values in indices. Must be one of `GL_UNSIGNED_BYTE`,
`GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`.

`indices` Specifies a pointer to the location where the indices are stored.
`basevertex` Specifies a constant that should be added to each element of `indices` when
chosing elements from the enabled vertex arrays.

---
### Description
`glDrawElementsBaseVertex` behaves identically to glDrawElements except that the i th element
transferred by the corresponding draw call will be taken from element `indices` [i] + `basevertex`
of each enabled array. If the resulting value is larger than the maximum value representable by
`type`, it is as if the calculation were upconverted to 32-bit unsigned integers (with wrapping on
overflow conditions). The operation is undefined if the sum would be negative.
---
### Notes
`glDrawElementsBaseVertex` is only supported if the GL version is 3.2 or greater, or if the
ARB_draw_elements_base_vertex extension is supported.
---
### Errors
`GL_INVALID_ENUM` is generated if `mode` is not an accepted value.

`GL_INVALID_VALUE` is generated if `count` is negative.

`GL_INVALID_OPERATION` is generated if a geometry shader is active and `mode` is incompatible
with the input primitive type of the geometry shader in the currently installed program object.

`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array
or the element array and the buffer object's data store is currently mapped.
---
### Version Support
`glDrawElementsBaseVertex`
---
### See Also
glDrawElements, glDrawRangeElements, glDrawRangeElementsBaseVertex,
glDrawElementsInstanced, glDrawElementsInstancedBaseVertex
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Draw multiple instances of a range of elements with offset applied to instanced attributes
---
### Parameters
`mode` Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`,
`GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`,
`GL_TRIANGLES` `GL_LINES_ADJACENCY`, `GL_LINE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY`,
`GL_TRIANGLE_STRIP_ADJACENCY` and `GL_PATCHES` are accepted.

`first` Specifies the starting index in the enabled arrays.
`count` Specifies the number of indices to be rendered.
`instancecount` Specifies the number of instances of the specified range of indices to be
rendered.
`baseinstance` Specifies the base instance for use in fetching instanced vertex attributes.
]],
  [[Render primitives from array data, taking parameters from memory
---
### Parameters
`mode` Specifies what kind of primitives to render. Symbolic constants `GL_POINTS`,
`GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`,
`GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`,
`GL_TRIANGLES_ADJACENCY`, and `GL_PATCHES` are accepted.

`indirect` Specifies the address of a structure containing the draw parameters.
---
### Description
`glDrawArraysIndirect` specifies multiple geometric primitives with very few subroutine calls.
`glDrawArraysIndirect` behaves similarly to glDrawArraysInstancedBaseInstance, execept that the
parameters to glDrawArraysInstancedBaseInstance are stored in memory at the address given by
`indirect`.

The parameters addressed by `indirect` are packed into a structure that takes the form (in C):
typedef struct { uint count; uint instanceCount; uint first; uint baseInstance; }
DrawArraysIndirectCommand; const DrawArraysIndirectCommand *cmd = (const DrawArraysIndirectCommand
*)indirect; glDrawArraysInstancedBaseInstance(mode, cmd->first, cmd->count, cmd->instanceCount,
cmd->baseInstance);

If a buffer is bound to the `GL_DRAW_INDIRECT_BUFFER` binding at the time of a call to
`glDrawArraysIndirect`, `indirect` is interpreted as an offset, in basic machine units, into that
buffer and the parameter data is read from the buffer rather than from client memory.

In contrast to glDrawArraysInstancedBaseInstance, the first member of the parameter structure
is unsigned, and out-of-range indices do not generate an error.

Vertex attributes that are modified by `glDrawArraysIndirect` have an unspecified value after
`glDrawArraysIndirect` returns. Attributes that aren't modified remain well defined.
---
### Notes
The `baseInstance` member of the `DrawArraysIndirectCommand` structure is defined only if the
GL version is 4.2 or greater. For versions of the GL less than 4.2, this parameter is present but is
reserved and should be set to zero. On earlier versions of the GL, behavior is undefined if it is
non-zero.
---
### Errors
`GL_INVALID_ENUM` is generated if `mode` is not an accepted value.

`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array
or to the `GL_DRAW_INDIRECT_BUFFER` binding and the buffer object's data store is currently
mapped.

`GL_INVALID_OPERATION` is generated if a geometry shader is active and `mode` is incompatible
with the input primitive type of the geometry shader in the currently installed program object.

`GL_INVALID_OPERATION` is generated if `mode` is `GL_PATCHES` and no tessellation control
shader is active.
---
### Version Support
`glDrawArraysIndirect`
---
### See Also
glDrawArrays, glDrawArraysInstanced, glDrawElements, glDrawRangeElements,
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Launch one or more compute work groups using parameters stored in a buffer
---
### Parameters
`indirect` The offset into the buffer object currently bound to the
`GL_DISPATCH_INDIRECT_BUFFER` buffer target at which the dispatch parameters are stored.

---
### Description
`glDispatchComputeIndirect` launches one or more compute work groups using parameters stored in
the buffer object currently bound to the `GL_DISPATCH_INDIRECT_BUFFER` target. Each work group is
processed by the active program object for the compute shader stage. While the individual shader
invocations within a work group are executed as a unit, work groups are executed completely
independently and in unspecified order. `indirect` contains the offset into the data store of the
buffer object bound to the `GL_DISPATCH_INDIRECT_BUFFER` target at which the parameters are
stored.

The parameters addressed by `indirect` are packed a structure, which takes the form (in C):
typedef struct { uint num_groups_x; uint num_groups_y; uint num_groups_z; } DispatchIndirectCommand;

A call to `glDispatchComputeIndirect` is equivalent, assuming no errors are generated, to: cmd
= (const DispatchIndirectCommand *)indirect; glDispatchCompute(cmd->num_groups_x, cmd->num_groups_y,
cmd->num_groups_z);

Unlike glDispatchCompute, no error is generated if any of the num_groups_x, num_groups_y or
num_groups_z members of the DispatchIndirectCommand is larger than the value of
`GL_MAX_COMPUTE_WORK_GROUP_COUNT` for the corresponding dimension. In such circumstances, behavior
is undefined and may lead to application termination.
---
### Errors
`GL_INVALID_OPERATION` is generated if there is no active program for the compute shader stage.

`GL_INVALID_VALUE` is generated if `indirect` is less than zero or not a multiple of four.

`GL_INVALID_OPERATION` is generated if no buffer is bound to the `GL_DISPATCH_INDIRECT_BUFFER`
target or if the command would source data beyond the end of the buffer object's data store.
---
### Associated Gets
glGet with argument `GL_MAX_COMPUTE_WORK_GROUP_COUNT`
---
### Version Support
`glDispatchComputeIndirect`
---
### See Also
glDispatchCompute.
---
### Copyright
Copyright 2013-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Detaches a shader object from a program object to which it is attached
---
### Parameters
`program` Specifies the program object from which to detach the shader object.
`shader` Specifies the shader object to be detached.
---
### Description
`glDetachShader` detaches the shader object specified by `shader` from the program object
specified by `program`. This command can be used to undo the effect of the command
glAttachShader.

If `shader` has already been flagged for deletion by a call to glDeleteShader and it is not
attached to any other program object, it will be deleted after it has been detached.
---
### Errors
`GL_INVALID_VALUE` is generated if either `program` or `shader` is a value that was not
generated by OpenGL.

`GL_INVALID_OPERATION` is generated if `program` is not a program object.

`GL_INVALID_OPERATION` is generated if `shader` is not a shader object.

`GL_INVALID_OPERATION` is generated if `shader` is not attached to `program`.
---
### Associated Gets
glGetAttachedShaders with the handle of a valid program object

glGetShader with arguments `shader` and `GL_DELETE_STATUS`

glIsProgram

glIsShader
---
### Version Support
`glDetachShader`
---
### See Also
glAttachShader
---
### Copyright
Copyright 2003-2005 3Dlabs Inc. Ltd. Copyright 2010-2014 Khronos Group. This material may be
distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8
June 1999. https://opencontent.org/openpub/.
]],
  [[Specify mapping of depth values from normalized device coordinates to window coordinates for a
specified set of viewports
---
### Parameters
`first` Specifies the index of the first viewport whose depth range to update.
`count` Specifies the number of viewports whose depth range to update.
`v` Specifies the address of an array containing the near and far values for the depth range of
each modified viewport.
---
### Description
After clipping and division by w, depth coordinates range from -1 to 1, corresponding to the
near and far clipping planes. Each viewport has an independent depth range specified as a linear
mapping of the normalized depth coordinates in this range to window depth coordinates. Regardless of
the actual depth buffer implementation, window coordinate depth values are treated as though they
range from 0 through 1 (like color components). `glDepthRangeArray` specifies a linear mapping of
the normalized depth coordinates in this range to window depth coordinates for each viewport in the
range [ `first`, `first` + `count` ). Thus, the values accepted by `glDepthRangeArray` are
both clamped to this range before they are accepted.

The `first` parameter specifies the index of the first viewport whose depth range to modify and
must be less than the value of `GL_MAX_VIEWPORTS`. `count` specifies the number of viewports
whose depth range to modify. `first` + `count` must be less than or equal to the value of
`GL_MAX_VIEWPORTS`. `v` specifies the address of an array of pairs of double precision floating
point values representing the near and far values of the depth range for each viewport, in that
order.

The setting of (0,1) maps the near plane to 0 and the far plane to 1. With this mapping, the depth
buffer range is fully utilized.
---
### Notes
It is not necessary that the near plane distance be less than the far plane distance. Reverse
mappings such as near = 1, and far = 0 are acceptable.

The type of the `v` parameter was changed from GLclampd to GLdouble. This change is transparent
to user code and is described in detail on the removedTypes page.
---
### Errors
`GL_INVALID_VALUE` is generated if `first` is greater than or equal to the value of
`GL_MAX_VIEWPORTS`.

`GL_INVALID_VALUE` is generated if `first` + `count` is greater than or equal to the value of
`GL_MAX_VIEWPORTS`.
---
### Associated Gets
glGet with argument `GL_DEPTH_RANGE`
---
### Version Support
`glDepthRangeArrayv`
---
### See Also
glDepthFunc, glDepthRange, glDepthRangeIndexed, glPolygonOffset, glViewportArray,
glViewport, removedTypes
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Define the scissor box for a specific viewport
---
### Parameters
`index` Specifies the index of the viewport whose scissor box to modify.
`left` `bottom` Specify the coordinate of the bottom left corner of the scissor box, in
pixels.
`width` `height` Specify ths dimensions of the scissor box, in pixels.
`v` For `glScissorIndexedv`, specifies the address of an array containing the left, bottom,
width and height of each scissor box, in that order.

---
### Description
`glScissorIndexed` defines the scissor box for a specified viewport. `index` specifies the
index of scissor box to modify. `index` must be less than the value of `GL_MAX_VIEWPORTS`. For
`glScissorIndexed`, `left`, `bottom`, `width` and `height` specify the left, bottom, width
and height of the scissor box, in pixels, respectively. For `glScissorIndexedv`, `v` specifies
the address of an array containing integers specifying the lower left corner of the scissor box, and
the width and height of the scissor box, in that order.

To enable and disable the scissor test, call glEnable and `glDisable` with argument
`GL_SCISSOR_TEST`. The test is initially disabled for all viewports. While the test is enabled,
only pixels that lie within the scissor box can be modified by drawing commands. Window coordinates
have integer values at the shared corners of frame buffer pixels. glScissor(0,0,1,1) allows
modification of only the lower left pixel in the window, and glScissor(0,0,0,0) doesn't allow
modification of any pixels in the window.

When the scissor test is disabled, it is as though the scissor box includes the entire window.
---
### Errors
`GL_INVALID_VALUE` is generated if `index` is greater than or equal to the value of
`GL_MAX_VIEWPORTS`.

`GL_INVALID_VALUE` is generated if any width or height specified in the array `v` is negative.

---
### Associated Gets
glGet with argument `GL_SCISSOR_BOX`

glIsEnabled with argument `GL_SCISSOR_TEST`
---
### Version Support
`glScissorIndexed` `glScissorIndexedv`
---
### See Also
glEnable, glScissor, glScissorArray
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Specifiy the vertex to be used as the source of data for flat shaded varyings
---
### Parameters
`provokeMode` Specifies the vertex to be used as the source of data for flat shaded varyings.
---
### Description
Flatshading a vertex shader varying output means to assign all vetices of the primitive the same
value for that output. The vertex from which these values is derived is known as the provoking
vertex and `glProvokingVertex` specifies which vertex is to be used as the source of data for
flat shaded varyings.

`provokeMode` must be either `GL_FIRST_VERTEX_CONVENTION` or `GL_LAST_VERTEX_CONVENTION`, and
controls the selection of the vertex whose values are assigned to flatshaded varying outputs. The
interpretation of these values for the supported primitive types is: Primitive Type of
Polygon i First Vertex Convention Last Vertex Convention point i i independent line
2 i - 1 2 i line loop i i + 1, if i < n

1, if i = n

line strip i i + 1 independent triangle 3 i - 2 3 i triangle strip i i + 2
triangle fan i + 1 i + 2 line adjacency 4 i - 2 4 i - 1 line strip adjacency i
+ 1 i + 2 triangle adjacency 6 i - 5 6 i - 1 triangle strip adjacency 2 i - 1 2
i + 3

If a vertex or geometry shader is active, user-defined varying outputs may be flatshaded by using
the flat qualifier when declaring the output.
---
### Notes
`glProvokingVertex` is available only if the GL version is 3.2 or greater.
---
### Errors
`GL_INVALID_ENUM` is generated if `provokeMode` is not an accepted value.
---
### Version Support
`glProvokingVertex`
---
### See Also
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Record the GL time into a query object after all previous commands have reached the GL server but
have not yet necessarily executed.
---
### Parameters
`id` Specify the name of a query object into which to record the GL time.
`target` Specify the counter to query. `target` must be `GL_TIMESTAMP`.

---
### Description
`glQueryCounter` causes the GL to record the current time into the query object named `id`.
`target` must be `GL_TIMESTAMP`. The time is recorded after all previous commands on the GL
client and server state and the framebuffer have been fully realized. When the time is recorded, the
query result for that object is marked available. `glQueryCounter` timer queries can be used
within a glBeginQuery / `glEndQuery` block where the target is `GL_TIME_ELAPSED` and it does
not affect the result of that query object.
---
### Notes
`glQueryCounter` is available only if the GL version is 3.3 or higher.
---
### Errors
`GL_INVALID_OPERATION` is generated if `id` is the name of a query object that is already in
use within a glBeginQuery / `glEndQuery` block.

`GL_INVALID_VALUE` is generated if `id` is not the name of a query object returned from a
previous call to glGenQueries.

`GL_INVALID_ENUM` is generated if `target` is not `GL_TIMESTAMP`.
---
### Version Support
`glQueryCounter`
---
### See Also
glGenQueries, glBeginQuery, `glEndQuery`, glDeleteQueries, glGetQueryObject,
glGetQueryiv, glGet
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Resume transform feedback operations
---
### Description
`glResumeTransformFeedback` resumes transform feedback operations on the currently active
transform feedback object. When transform feedback operations are paused, transform feedback is
still considered active and changing most transform feedback state related to the object results in
an error. However, a new transform feedback object may be bound while transform feedback is paused.

---
### Errors
`GL_INVALID_OPERATION` is generated if the currently bound transform feedback object is not
active or is not paused.
---
### Version Support
`glResumeTransformFeedback`
---
### See Also
glGenTransformFeedbacks, glBindTransformFeedback, glBeginTransformFeedback,
glPauseTransformFeedback, `glEndTransformFeedback`, glDeleteTransformFeedbacks
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Set the value of a sub-word of the sample mask
---
### Parameters
`maskNumber` Specifies which 32-bit sub-word of the sample mask to update.
`mask` Specifies the new value of the mask sub-word.
---
### Description
`glSampleMaski` sets one 32-bit sub-word of the multi-word sample mask, `GL_SAMPLE_MASK_VALUE`.

`maskIndex` specifies which 32-bit sub-word of the sample mask to update, and `mask` specifies
the new value to use for that sub-word. `maskIndex` must be less than the value of
`GL_MAX_SAMPLE_MASK_WORDS`. Bit B of mask word M corresponds to sample 32 x M + B.
---
### Notes
`glSampleMaski` is available only if the GL version is 3.2 or greater, or if the
ARB_texture_multisample extension is supported.
---
### Errors
`GL_INVALID_VALUE` is generated if `maskIndex` is greater than or equal to the value of
`GL_MAX_SAMPLE_MASK_WORDS`.
---
### Version Support
`glSampleMaski`
---
### See Also
glGenRenderbuffers, glBindRenderbuffer, glRenderbufferStorageMultisample,
glFramebufferRenderbuffer, glDeleteRenderbuffers
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Define the scissor box for multiple viewports
---
### Parameters
`first` Specifies the index of the first viewport whose scissor box to modify.
`count` Specifies the number of scissor boxes to modify.
`v` Specifies the address of an array containing the left, bottom, width and height of each
scissor box, in that order.
---
### Description
`glScissorArrayv` defines rectangles, called scissor boxes, in window coordinates for each
viewport. `first` specifies the index of the first scissor box to modify and `count` specifies
the number of scissor boxes to modify. `first` must be less than the value of `GL_MAX_VIEWPORTS`,
and `first` + `count` must be less than or equal to the value of `GL_MAX_VIEWPORTS`. `v`
specifies the address of an array containing integers specifying the lower left corner of the
scissor boxes, and the width and height of the scissor boxes, in that order.

To enable and disable the scissor test, call glEnable and `glDisable` with argument
`GL_SCISSOR_TEST`. The test is initially disabled for all viewports. While the test is enabled,
only pixels that lie within the scissor box can be modified by drawing commands. Window coordinates
have integer values at the shared corners of frame buffer pixels. glScissor(0,0,1,1) allows
modification of only the lower left pixel in the window, and glScissor(0,0,0,0) doesn't allow
modification of any pixels in the window.

When the scissor test is disabled, it is as though the scissor box includes the entire window.
---
### Errors
`GL_INVALID_VALUE` is generated if `first` is greater than or equal to the value of
`GL_MAX_VIEWPORTS`.

`GL_INVALID_VALUE` is generated if `first` + `count` is greater than or equal to the value of
`GL_MAX_VIEWPORTS`.

`GL_INVALID_VALUE` is generated if any width or height specified in the array `v` is negative.

---
### Associated Gets
glGet with argument `GL_SCISSOR_BOX`

glIsEnabled with argument `GL_SCISSOR_TEST`
---
### Version Support
`glScissorArrayv`
---
### See Also
glEnable, glViewport, glViewportIndexed, glViewportArray
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Replaces the source code in a shader object
---
### Parameters
`shader` Specifies the handle of the shader object whose source code is to be replaced.
`count` Specifies the number of elements in the `string` and `length` arrays.

`string` Specifies an array of pointers to strings containing the source code to be loaded into
the shader.
`length` Specifies an array of string lengths.
---
### Description
`glShaderSource` sets the source code in `shader` to the source code in the array of strings
specified by `string`. Any source code previously stored in the shader object is completely
replaced. The number of strings in the array is specified by `count`. If `length` is `NULL`,
each string is assumed to be null terminated. If `length` is a value other than `NULL`, it
points to an array containing a string length for each of the corresponding elements of `string`.

Each element in the `length` array may contain the length of the corresponding string (the null
character is not counted as part of the string length) or a value less than 0 to indicate that the
string is null terminated. The source code strings are not scanned or parsed at this time; they are
simply copied into the specified shader object.
---
### Notes
OpenGL copies the shader source code strings when `glShaderSource` is called, so an application
may free its copy of the source code strings immediately after the function returns.
---
### Errors
`GL_INVALID_VALUE` is generated if `shader` is not a value generated by OpenGL.

`GL_INVALID_OPERATION` is generated if `shader` is not a shader object.

`GL_INVALID_VALUE` is generated if `count` is less than 0.
---
### Associated Gets
glGetShader with arguments `shader` and `GL_SHADER_SOURCE_LENGTH`

glGetShaderSource with argument `shader`

glIsShader
---
### Version Support
`glShaderSource`
---
### See Also
glCompileShader, glCreateShader, glDeleteShader
---
### Copyright
Copyright 2003-2005 3Dlabs Inc. Ltd. Copyright 2010-2014 Khronos Group. This material may be
distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8
June 1999. https://opencontent.org/openpub/.
]],
  [[Set front and back function and reference value for stencil testing
---
### Parameters
`func` Specifies the test function. Eight symbolic constants are valid: `GL_NEVER`,
`GL_LESS`, `GL_LEQUAL`, `GL_GREATER`, `GL_GEQUAL`, `GL_EQUAL`, `GL_NOTEQUAL`, and
`GL_ALWAYS`. The initial value is `GL_ALWAYS`.

`ref` Specifies the reference value for the stencil test. `ref` is clamped to the range 0
2 n - 1, where n is the number of bitplanes in the stencil buffer. The initial value is 0.

`mask` Specifies a mask that is ANDed with both the reference value and the stored stencil
value when the test is done. The initial value is all 1's.
---
### Description
Stenciling, like depth-buffering, enables and disables drawing on a per-pixel basis. Stencil
planes are first drawn into using GL drawing primitives, then geometry and images are rendered using
the stencil planes to mask out portions of the screen. Stenciling is typically used in multipass
rendering algorithms to achieve special effects, such as decals, outlining, and constructive solid
geometry rendering. The stencil test conditionally eliminates a pixel based on the outcome of a
comparison between the reference value and the value in the stencil buffer. To enable and disable
the test, call glEnable and `glDisable` with argument `GL_STENCIL_TEST`. To specify actions
based on the outcome of the stencil test, call glStencilOp or glStencilOpSeparate.

There can be two separate sets of `func`, `ref`, and `mask` parameters; one affects
back-facing polygons, and the other affects front-facing polygons as well as other non-polygon
primitives. glStencilFunc sets both front and back stencil state to the same values. Use
glStencilFuncSeparate to set front and back stencil state to different values.

`func` is a symbolic constant that determines the stencil comparison function. It accepts one of
eight values, shown in the following list. `ref` is an integer reference value that is used in the
stencil comparison. It is clamped to the range 0 2 n - 1, where n is the number of
bitplanes in the stencil buffer. `mask` is bitwise ANDed with both the reference value and the
stored stencil value, with the ANDed values participating in the comparison.

If stencil represents the value stored in the corresponding stencil buffer location, the
following list shows the effect of each comparison function that can be specified by `func`. Only
if the comparison succeeds is the pixel passed through to the next stage in the rasterization
process (see glStencilOp ). All tests treat stencil values as unsigned integers in the range
0 2 n - 1, where n is the number of bitplanes in the stencil buffer.

The following values are accepted by `func` :

`GL_NEVER` Always fails.
`GL_LESS` Passes if ( `ref` & `mask` ) < ( stencil & `mask` ).

`GL_LEQUAL` Passes if ( `ref` & `mask` ) <= ( stencil & `mask` ).

`GL_GREATER` Passes if ( `ref` & `mask` ) > ( stencil & `mask` ).

`GL_GEQUAL` Passes if ( `ref` & `mask` ) >= ( stencil & `mask` ).

`GL_EQUAL` Passes if ( `ref` & `mask` ) = ( stencil & `mask` ).

`GL_NOTEQUAL` Passes if ( `ref` & `mask` ) != ( stencil & `mask` ).

`GL_ALWAYS` Always passes.
---
### Notes
Initially, the stencil test is disabled. If there is no stencil buffer, no stencil modification
can occur and it is as if the stencil test always passes. glStencilFunc is the same as calling
glStencilFuncSeparate with `face` set to `GL_FRONT_AND_BACK`.
---
### Errors
`GL_INVALID_ENUM` is generated if `func` is not one of the eight accepted values.
---
### Associated Gets
glGet with argument `GL_STENCIL_FUNC`, `GL_STENCIL_VALUE_MASK`, `GL_STENCIL_REF`,
`GL_STENCIL_BACK_FUNC`, `GL_STENCIL_BACK_VALUE_MASK`, `GL_STENCIL_BACK_REF`, or
`GL_STENCIL_BITS`

glIsEnabled with argument `GL_STENCIL_TEST`
---
### Version Support
`glStencilFunc`
---
### See Also
glBlendFunc, glDepthFunc, glEnable, glLogicOp, glStencilFuncSeparate,
glStencilMask, glStencilMaskSeparate, glStencilOp, glStencilOpSeparate
---
### Copyright
Copyright 1991-2006 Silicon Graphics, Inc. Copyright 2010-2014 Khronos Group. This document
is licensed under the SGI Free Software B License. For details, see
https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.
]],
  [[Change an active shader storage block binding
---
### Parameters
`program` The name of the program containing the block whose binding to change.
`storageBlockIndex` The index storage block within the program.
`storageBlockBinding` The index storage block binding to associate with the specified storage
block.
---
### Description
`glShaderStorageBlockBinding`, changes the active shader storage block with an assigned index of
`storageBlockIndex` in program object `program`. `storageBlockIndex` must be an active shader
storage block index in `program`. `storageBlockBinding` must be less than the value of
`GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS`. If successful, `glShaderStorageBlockBinding` specifies
that `program` will use the data store of the buffer object bound to the binding point
`storageBlockBinding` to read and write the values of the buffer variables in the shader storage
block identified by `storageBlockIndex`.
---
### Errors
`GL_INVALID_VALUE` is generated if `program` is not the name of either a program or shader
object.

`GL_INVALID_OPERATION` is generated if `program` is the name of a shader object.

`GL_INVALID_VALUE` is generated if `storageBlockIndex` is not an active shader storage block
index in `program`, or if `storageBlockBinding` is greater than or equal to the value of
`MAX_SHADER_STORAGE_BUFFER_BINDINGS`.
---
### Associated Gets
glGet with arguments `GL_SHADER_STORAGE_BUFFER_BINDING`,
`GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS`, `GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS`,
`GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS`, `GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS`,
`GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS`, `GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS`,
`GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS` or `GL_MAX_COMBINED_SHADER_STORAGE_BLOCKS`,
`GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS`, or `GL_MAX_COMBINED_SHADER_OUTPUT_RESOURCES`.
---
### Version Support
`glShaderStorageBlockBinding`
---
### See Also
---
### Copyright
Copyright 2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Set front and/or back function and reference value for stencil testing
---
### Parameters
`face` Specifies whether front and/or back stencil state is updated. Three symbolic constants
are valid: `GL_FRONT`, `GL_BACK`, and `GL_FRONT_AND_BACK`.

`func` Specifies the test function. Eight symbolic constants are valid: `GL_NEVER`,
`GL_LESS`, `GL_LEQUAL`, `GL_GREATER`, `GL_GEQUAL`, `GL_EQUAL`, `GL_NOTEQUAL`, and
`GL_ALWAYS`. The initial value is `GL_ALWAYS`.

`ref` Specifies the reference value for the stencil test. `ref` is clamped to the range 0
2 n - 1, where n is the number of bitplanes in the stencil buffer. The initial value is 0.

`mask` Specifies a mask that is ANDed with both the reference value and the stored stencil
value when the test is done. The initial value is all 1's.
---
### Description
Stenciling, like depth-buffering, enables and disables drawing on a per-pixel basis. You draw into
the stencil planes using GL drawing primitives, then render geometry and images, using the stencil
planes to mask out portions of the screen. Stenciling is typically used in multipass rendering
algorithms to achieve special effects, such as decals, outlining, and constructive solid geometry
rendering. The stencil test conditionally eliminates a pixel based on the outcome of a comparison
between the reference value and the value in the stencil buffer. To enable and disable the test,
call glEnable and `glDisable` with argument `GL_STENCIL_TEST`. To specify actions based on
the outcome of the stencil test, call glStencilOp or glStencilOpSeparate.

There can be two separate sets of `func`, `ref`, and `mask` parameters; one affects
back-facing polygons, and the other affects front-facing polygons as well as other non-polygon
primitives. glStencilFunc sets both front and back stencil state to the same values, as if
glStencilFuncSeparate were called with `face` set to `GL_FRONT_AND_BACK`.

`func` is a symbolic constant that determines the stencil comparison function. It accepts one of
eight values, shown in the following list. `ref` is an integer reference value that is used in the
stencil comparison. It is clamped to the range 0 2 n - 1, where n is the number of
bitplanes in the stencil buffer. `mask` is bitwise ANDed with both the reference value and the
stored stencil value, with the ANDed values participating in the comparison.

If stencil represents the value stored in the corresponding stencil buffer location, the
following list shows the effect of each comparison function that can be specified by `func`. Only
if the comparison succeeds is the pixel passed through to the next stage in the rasterization
process (see glStencilOp ). All tests treat stencil values as unsigned integers in the range
0 2 n - 1, where n is the number of bitplanes in the stencil buffer.

The following values are accepted by `func` :

`GL_NEVER` Always fails.
`GL_LESS` Passes if ( `ref` & `mask` ) < ( stencil & `mask` ).

`GL_LEQUAL` Passes if ( `ref` & `mask` ) <= ( stencil & `mask` ).

`GL_GREATER` Passes if ( `ref` & `mask` ) > ( stencil & `mask` ).

`GL_GEQUAL` Passes if ( `ref` & `mask` ) >= ( stencil & `mask` ).

`GL_EQUAL` Passes if ( `ref` & `mask` ) = ( stencil & `mask` ).

`GL_NOTEQUAL` Passes if ( `ref` & `mask` ) != ( stencil & `mask` ).

`GL_ALWAYS` Always passes.
---
### Notes
Initially, the stencil test is disabled. If there is no stencil buffer, no stencil modification
can occur and it is as if the stencil test always passes.
---
### Errors
`GL_INVALID_ENUM` is generated if `func` is not one of the eight accepted values.
---
### Associated Gets
glGet with argument `GL_STENCIL_FUNC`, `GL_STENCIL_VALUE_MASK`, `GL_STENCIL_REF`,
`GL_STENCIL_BACK_FUNC`, `GL_STENCIL_BACK_VALUE_MASK`, `GL_STENCIL_BACK_REF`, or
`GL_STENCIL_BITS`

glIsEnabled with argument `GL_STENCIL_TEST`
---
### Version Support
`glStencilFuncSeparate`
---
### See Also
glBlendFunc, glDepthFunc, glEnable, glLogicOp, glStencilFunc, glStencilMask,
glStencilMaskSeparate, glStencilOp, glStencilOpSeparate
---
### Copyright
Copyright 2006 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Attach a range of a buffer object's data store to a buffer texture object
---
### Parameters
`target` Specifies the target to which the texture object is bound for `glTexBufferRange`.

Must be `GL_TEXTURE_BUFFER`.

`texture` Specifies the texture object name for `glTextureBufferRange`.

`internalformat` Specifies the internal format of the data in the store belonging to `buffer`.

`buffer` Specifies the name of the buffer object whose storage to attach to the active buffer
texture.
`offset` Specifies the offset of the start of the range of the buffer's data store to attach.
`size` Specifies the size of the range of the buffer's data store to attach.
---
### Description
`glTexBufferRange` and `glTextureBufferRange` attach a range of the data store of a specified
buffer object to a specified texture object, and specify the storage format for the texture image
found in the buffer object. The texture object must be a buffer texture.

If `buffer` is zero, any buffer object attached to the buffer texture is detached and no new
buffer object is attached. If `buffer` is non-zero, it must be the name of an existing buffer
object.

The start and size of the range are specified by `offset` and `size` respectively, both
measured in basic machine units. `offset` must be greater than or equal to zero, `size` must be
greater than zero, and the sum of `offset` and `size` must not exceed the value of
`GL_BUFFER_SIZE` for `buffer`. Furthermore, `offset` must be an integer multiple of the value
of `GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT`.

`internalformat` specifies the storage format, and must be one of the following sized internal
formats:

When a range of a buffer object is attached to a buffer texture, the specified range of the
buffer object's data store is taken as the texture's texel array. The number of texels in the buffer
texture's texel array is given by $$ \\\\left\\\\lfloor { size \\\\over { components \\\\times
sizeof(base\\\\_type) } } \\\\right\\\\rfloor $$ where $components$ and $base\\\\_type$ are the element count
and base data type for elements, as specified in the table above. The number of texels in the texel
array is then clamped to the value of the implementation-dependent limit
`GL_MAX_TEXTURE_BUFFER_SIZE`. When a buffer texture is accessed in a shader, the results of a texel
fetch are undefined if the specified texel coordinate is negative, or greater than or equal to the
clamped number of texels in the texel array.
---
### Errors
`GL_INVALID_ENUM` is generated by `glTexBufferRange` if `target` is not `GL_TEXTURE_BUFFER`.

`GL_INVALID_OPERATION` is generated by `glTextureBufferRange` if `texture` is not the name of
an existing texture object.

`GL_INVALID_ENUM` is generated by `glTextureBufferRange` if the effective target of `texture`
is not `GL_TEXTURE_BUFFER`.

`GL_INVALID_ENUM` is generated if `internalformat` is not one of the sized internal formats
described above.

`GL_INVALID_OPERATION` is generated if `buffer` is not zero and is not the name of an existing
buffer object.

`GL_INVALID_VALUE` is generated if `offset` is negative, if `size` is less than or equal to
zero, or if `offset` + `size` is greater than the value of `GL_BUFFER_SIZE` for `buffer`.

`GL_INVALID_VALUE` is generated if `offset` is not an integer multiple of the value of
`GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT`.
---
### Associated Gets
glGet with argument `GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT`

glGetTexLevelParameter with arguments `GL_TEXTURE_BUFFER_OFFSET` or `GL_TEXTURE_BUFFER_SIZE`.
---
### Version Support
`glTexBufferRange` `glTextureBufferRange`
---
### See Also
glTexBuffer.
---
### Copyright
Copyright 2012-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Control the front and back writing of individual bits in the stencil planes
---
### Parameters
`mask` Specifies a bit mask to enable and disable writing of individual bits in the stencil
planes. Initially, the mask is all 1's.
---
### Description
`glStencilMask` controls the writing of individual bits in the stencil planes. The least
significant n bits of `mask`, where n is the number of bits in the stencil buffer, specify
a mask. Where a 1 appears in the mask, it's possible to write to the corresponding bit in the
stencil buffer. Where a 0 appears, the corresponding bit is write-protected. Initially, all bits are
enabled for writing.

There can be two separate `mask` writemasks; one affects back-facing polygons, and the other
affects front-facing polygons as well as other non-polygon primitives. glStencilMask sets both
front and back stencil writemasks to the same values. Use glStencilMaskSeparate to set front and
back stencil writemasks to different values.
---
### Notes
glStencilMask is the same as calling glStencilMaskSeparate with `face` set to
`GL_FRONT_AND_BACK`.
---
### Associated Gets
glGet with argument `GL_STENCIL_WRITEMASK`, `GL_STENCIL_BACK_WRITEMASK`, or
`GL_STENCIL_BITS`
---
### Version Support
`glStencilMask`
---
### See Also
glColorMask, glDepthMask, glStencilFunc, glStencilFuncSeparate, glStencilMaskSeparate,
glStencilOp, glStencilOpSeparate
---
### Copyright
Copyright 1991-2006 Silicon Graphics, Inc. Copyright 2010-2014 Khronos Group. This document
is licensed under the SGI Free Software B License. For details, see
https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.
]],
  [[Control the front and/or back writing of individual bits in the stencil planes
---
### Parameters
`face` Specifies whether the front and/or back stencil writemask is updated. Three symbolic
constants are valid: `GL_FRONT`, `GL_BACK`, and `GL_FRONT_AND_BACK`.

`mask` Specifies a bit mask to enable and disable writing of individual bits in the stencil
planes. Initially, the mask is all 1's.
---
### Description
`glStencilMaskSeparate` controls the writing of individual bits in the stencil planes. The least
significant n bits of `mask`, where n is the number of bits in the stencil buffer, specify
a mask. Where a 1 appears in the mask, it's possible to write to the corresponding bit in the
stencil buffer. Where a 0 appears, the corresponding bit is write-protected. Initially, all bits are
enabled for writing.

There can be two separate `mask` writemasks; one affects back-facing polygons, and the other
affects front-facing polygons as well as other non-polygon primitives. glStencilMask sets both
front and back stencil writemasks to the same values, as if glStencilMaskSeparate were called
with `face` set to `GL_FRONT_AND_BACK`.
---
### Errors
`GL_INVALID_ENUM` is generated if `face` is not one of the accepted tokens.
---
### Associated Gets
glGet with argument `GL_STENCIL_WRITEMASK`, `GL_STENCIL_BACK_WRITEMASK`, or
`GL_STENCIL_BITS`
---
### Version Support
`glStencilMaskSeparate`
---
### See Also
glColorMask, glDepthMask, glStencilFunc, glStencilFuncSeparate, glStencilMask,
glStencilOp, glStencilOpSeparate
---
### Copyright
Copyright 2006 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Set front and back stencil test actions
---
### Parameters
`sfail` Specifies the action to take when the stencil test fails. Eight symbolic constants are
accepted: `GL_KEEP`, `GL_ZERO`, `GL_REPLACE`, `GL_INCR`, `GL_INCR_WRAP`, `GL_DECR`,
`GL_DECR_WRAP`, and `GL_INVERT`. The initial value is `GL_KEEP`.

`dpfail` Specifies the stencil action when the stencil test passes, but the depth test fails.
`dpfail` accepts the same symbolic constants as `sfail`. The initial value is `GL_KEEP`.

`dppass` Specifies the stencil action when both the stencil test and the depth test pass, or
when the stencil test passes and either there is no depth buffer or depth testing is not enabled.
`dppass` accepts the same symbolic constants as `sfail`. The initial value is `GL_KEEP`.

---
### Description
Stenciling, like depth-buffering, enables and disables drawing on a per-pixel basis. You draw into
the stencil planes using GL drawing primitives, then render geometry and images, using the stencil
planes to mask out portions of the screen. Stenciling is typically used in multipass rendering
algorithms to achieve special effects, such as decals, outlining, and constructive solid geometry
rendering. The stencil test conditionally eliminates a pixel based on the outcome of a comparison
between the value in the stencil buffer and a reference value. To enable and disable the test, call
glEnable and `glDisable` with argument `GL_STENCIL_TEST` ; to control it, call glStencilFunc
or glStencilFuncSeparate.

There can be two separate sets of `sfail`, `dpfail`, and `dppass` parameters; one affects
back-facing polygons, and the other affects front-facing polygons as well as other non-polygon
primitives. glStencilOp sets both front and back stencil state to the same values. Use
glStencilOpSeparate to set front and back stencil state to different values.

`glStencilOp` takes three arguments that indicate what happens to the stored stencil value while
stenciling is enabled. If the stencil test fails, no change is made to the pixel's color or depth
buffers, and `sfail` specifies what happens to the stencil buffer contents. The following eight
actions are possible.

`GL_KEEP` Keeps the current value.
`GL_ZERO` Sets the stencil buffer value to 0.
`GL_REPLACE` Sets the stencil buffer value to ref, as specified by glStencilFunc.

`GL_INCR` Increments the current stencil buffer value. Clamps to the maximum representable
unsigned value.
`GL_INCR_WRAP` Increments the current stencil buffer value. Wraps stencil buffer value to zero
when incrementing the maximum representable unsigned value.
`GL_DECR` Decrements the current stencil buffer value. Clamps to 0.
`GL_DECR_WRAP` Decrements the current stencil buffer value. Wraps stencil buffer value to the
maximum representable unsigned value when decrementing a stencil buffer value of zero.
`GL_INVERT` Bitwise inverts the current stencil buffer value.

Stencil buffer values are treated as unsigned integers. When incremented and decremented, values
are clamped to 0 and 2 n - 1, where n is the value returned by querying `GL_STENCIL_BITS`.

The other two arguments to `glStencilOp` specify stencil buffer actions that depend on whether
subsequent depth buffer tests succeed ( `dppass` ) or fail ( `dpfail` ) (see glDepthFunc ). The
actions are specified using the same eight symbolic constants as `sfail`. Note that `dpfail` is
ignored when there is no depth buffer, or when the depth buffer is not enabled. In these cases,
`sfail` and `dppass` specify stencil action when the stencil test fails and passes, respectively.

---
### Notes
Initially the stencil test is disabled. If there is no stencil buffer, no stencil modification can
occur and it is as if the stencil tests always pass, regardless of any call to `glStencilOp`.

glStencilOp is the same as calling glStencilOpSeparate with `face` set to
`GL_FRONT_AND_BACK`.
---
### Errors
`GL_INVALID_ENUM` is generated if `sfail`, `dpfail`, or `dppass` is any value other than
the defined constant values.
---
### Associated Gets
glGet with argument `GL_STENCIL_FAIL`, `GL_STENCIL_PASS_DEPTH_PASS`,
`GL_STENCIL_PASS_DEPTH_FAIL`, `GL_STENCIL_BACK_FAIL`, `GL_STENCIL_BACK_PASS_DEPTH_PASS`,
`GL_STENCIL_BACK_PASS_DEPTH_FAIL`, or `GL_STENCIL_BITS`

glIsEnabled with argument `GL_STENCIL_TEST`
---
### Version Support
`glStencilOp`
---
### See Also
glBlendFunc, glDepthFunc, glEnable, glLogicOp, glStencilFunc,
glStencilFuncSeparate, glStencilMask, glStencilMaskSeparate, glStencilOpSeparate
---
### Copyright
Copyright 1991-2006 Silicon Graphics, Inc. Copyright 2010-2014 Khronos Group. This document
is licensed under the SGI Free Software B License. For details, see
https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.
]],
  [[Set front and/or back stencil test actions
---
### Parameters
`face` Specifies whether front and/or back stencil state is updated. Three symbolic constants
are valid: `GL_FRONT`, `GL_BACK`, and `GL_FRONT_AND_BACK`.

`sfail` Specifies the action to take when the stencil test fails. Eight symbolic constants are
accepted: `GL_KEEP`, `GL_ZERO`, `GL_REPLACE`, `GL_INCR`, `GL_INCR_WRAP`, `GL_DECR`,
`GL_DECR_WRAP`, and `GL_INVERT`. The initial value is `GL_KEEP`.

`dpfail` Specifies the stencil action when the stencil test passes, but the depth test fails.
`dpfail` accepts the same symbolic constants as `sfail`. The initial value is `GL_KEEP`.

`dppass` Specifies the stencil action when both the stencil test and the depth test pass, or
when the stencil test passes and either there is no depth buffer or depth testing is not enabled.
`dppass` accepts the same symbolic constants as `sfail`. The initial value is `GL_KEEP`.

---
### Description
Stenciling, like depth-buffering, enables and disables drawing on a per-pixel basis. You draw into
the stencil planes using GL drawing primitives, then render geometry and images, using the stencil
planes to mask out portions of the screen. Stenciling is typically used in multipass rendering
algorithms to achieve special effects, such as decals, outlining, and constructive solid geometry
rendering. The stencil test conditionally eliminates a pixel based on the outcome of a comparison
between the value in the stencil buffer and a reference value. To enable and disable the test, call
glEnable and `glDisable` with argument `GL_STENCIL_TEST` ; to control it, call glStencilFunc
or glStencilFuncSeparate.

There can be two separate sets of `sfail`, `dpfail`, and `dppass` parameters; one affects
back-facing polygons, and the other affects front-facing polygons as well as other non-polygon
primitives. glStencilOp sets both front and back stencil state to the same values, as if
glStencilOpSeparate were called with `face` set to `GL_FRONT_AND_BACK`.

`glStencilOpSeparate` takes three arguments that indicate what happens to the stored stencil
value while stenciling is enabled. If the stencil test fails, no change is made to the pixel's color
or depth buffers, and `sfail` specifies what happens to the stencil buffer contents. The following
eight actions are possible.

`GL_KEEP` Keeps the current value.
`GL_ZERO` Sets the stencil buffer value to 0.
`GL_REPLACE` Sets the stencil buffer value to ref, as specified by glStencilFunc.

`GL_INCR` Increments the current stencil buffer value. Clamps to the maximum representable
unsigned value.
`GL_INCR_WRAP` Increments the current stencil buffer value. Wraps stencil buffer value to zero
when incrementing the maximum representable unsigned value.
`GL_DECR` Decrements the current stencil buffer value. Clamps to 0.
`GL_DECR_WRAP` Decrements the current stencil buffer value. Wraps stencil buffer value to the
maximum representable unsigned value when decrementing a stencil buffer value of zero.
`GL_INVERT` Bitwise inverts the current stencil buffer value.

Stencil buffer values are treated as unsigned integers. When incremented and decremented, values
are clamped to 0 and 2 n - 1, where n is the value returned by querying `GL_STENCIL_BITS`.

The other two arguments to `glStencilOpSeparate` specify stencil buffer actions that depend on
whether subsequent depth buffer tests succeed ( `dppass` ) or fail ( `dpfail` ) (see glDepthFunc
). The actions are specified using the same eight symbolic constants as `sfail`. Note that
`dpfail` is ignored when there is no depth buffer, or when the depth buffer is not enabled. In
these cases, `sfail` and `dppass` specify stencil action when the stencil test fails and passes,
respectively.
---
### Notes
Initially the stencil test is disabled. If there is no stencil buffer, no stencil modification can
occur and it is as if the stencil test always passes.
---
### Errors
`GL_INVALID_ENUM` is generated if `face` is any value other than `GL_FRONT`, `GL_BACK`, or
`GL_FRONT_AND_BACK`.

`GL_INVALID_ENUM` is generated if `sfail`, `dpfail`, or `dppass` is any value other than
the eight defined constant values.
---
### Associated Gets
glGet with argument `GL_STENCIL_FAIL`, `GL_STENCIL_PASS_DEPTH_PASS`,
`GL_STENCIL_PASS_DEPTH_FAIL`, `GL_STENCIL_BACK_FAIL`, `GL_STENCIL_BACK_PASS_DEPTH_PASS`,
`GL_STENCIL_BACK_PASS_DEPTH_FAIL`, or `GL_STENCIL_BITS`

glIsEnabled with argument `GL_STENCIL_TEST`
---
### Version Support
`glStencilOpSeparate`
---
### See Also
glBlendFunc, glDepthFunc, glEnable, glLogicOp, glStencilFunc,
glStencilFuncSeparate, glStencilMask, glStencilMaskSeparate, glStencilOp
---
### Copyright
Copyright 2006 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Attach a buffer object's data store to a buffer texture object
---
### Parameters
`target` Specifies the target to which the texture is bound for `glTexBuffer`. Must be
`GL_TEXTURE_BUFFER`.

`texture` Specifies the texture object name for `glTextureBuffer`.

`internalformat` Specifies the internal format of the data in the store belonging to `buffer`.

`buffer` Specifies the name of the buffer object whose storage to attach to the active buffer
texture.
---
### Description
`glTexBuffer` and `glTextureBuffer` attaches the data store of a specified buffer object to a
specified texture object, and specify the storage format for the texture image found in the buffer
object. The texture object must be a buffer texture.

If `buffer` is zero, any buffer object attached to the buffer texture is detached and no new
buffer object is attached. If `buffer` is non-zero, it must be the name of an existing buffer
object.

`internalformat` specifies the storage format, and must be one of the following sized internal
formats:

When a buffer object is attached to a buffer texture, the buffer object's data store is taken as
the texture's texel array. The number of texels in the buffer texture's texel array is given by $$
\\\\left\\\\lfloor { size \\\\over { components \\\\times sizeof(base\\\\_type) } } \\\\right\\\\rfloor $$ where $size$
is the size of the buffer object in basic machine units (the value of `GL_BUFFER_SIZE` for
`buffer` ), and $components$ and $base\\\\_type$ are the element count and base data type for elements,
as specified in the table above. The number of texels in the texel array is then clamped to the
value of the implementation-dependent limit `GL_MAX_TEXTURE_BUFFER_SIZE`. When a buffer texture is
accessed in a shader, the results of a texel fetch are undefined if the specified texel coordinate
is negative, or greater than or equal to the clamped number of texels in the texel array.
---
### Errors
`GL_INVALID_ENUM` is generated by `glTexBuffer` if `target` is not `GL_TEXTURE_BUFFER`.

`GL_INVALID_OPERATION` is generated by `glTextureBuffer` if `texture` is not the name of an
existing texture object.

`GL_INVALID_ENUM` is generated by `glTextureBuffer` if the effective target of `texture` is
not `GL_TEXTURE_BUFFER`.

`GL_INVALID_ENUM` is generated if `internalformat` is not one of the sized internal formats
described above.

`GL_INVALID_OPERATION` is generated if `buffer` is not zero and is not the name of an existing
buffer object.
---
### Associated Gets
glGet with argument `GL_MAX_TEXTURE_BUFFER_SIZE`

glGet with argument `GL_TEXTURE_BINDING_BUFFER`

glGetTexLevelParameter with argument `GL_TEXTURE_BUFFER_DATA_STORE_BINDING`
---
### Version Support
`glTexBuffer` `glTextureBuffer`
---
### See Also
glGenBuffers, glBindBuffer, glBufferData, glDeleteBuffers, glGenTextures,
glBindTexture, glDeleteTextures
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Return parameters of a query object target
---
### Parameters
`target` Specifies a query object target. Must be `GL_SAMPLES_PASSED`,
`GL_ANY_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED_CONSERVATIVE` `GL_PRIMITIVES_GENERATED`,
`GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`, `GL_TIME_ELAPSED`, or `GL_TIMESTAMP`.

`pname` Specifies the symbolic name of a query object target parameter. Accepted values are
`GL_CURRENT_QUERY` or `GL_QUERY_COUNTER_BITS`.

`params` Returns the requested data.
---
### Description
`glGetQueryiv` returns in `params` a selected parameter of the query object target specified by
`target`.

`pname` names a specific query object target parameter. When `pname` is `GL_CURRENT_QUERY`,
the name of the currently active query for `target`, or zero if no query is active, will be placed
in `params`. If `pname` is `GL_QUERY_COUNTER_BITS`, the implementation-dependent number of
bits used to hold the result of queries for `target` is returned in `params`.
---
### Notes
The target `GL_ANY_SAMPLES_PASSED_CONSERVATIVE` is available only if the GL version is 4.3 or
greater.

If an error is generated, no change is made to the contents of `params`.
---
### Errors
`GL_INVALID_ENUM` is generated if `target` or `pname` is not an accepted value.
---
### Version Support
`glGetQueryiv`
---
### See Also
glGetQueryObject, glIsQuery
---
### Copyright
Copyright 2005 Addison-Wesley. Copyright 2010-2014 Khronos Group. This material may be
distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8
June 1999. https://opencontent.org/openpub/.
]],
  [[Query a named parameter of a renderbuffer object
---
### Parameters
`target` Specifies the target to which the renderbuffer object is bound for
`glGetRenderbufferParameteriv`. `target` must be `GL_RENDERBUFFER`.

`renderbuffer` Specifies the name of the renderbuffer object for
`glGetNamedRenderbufferParameteriv`.

`pname` Specifies the parameter of the renderbuffer object to query.
`params` Returns the value of parameter `pname` for the renderbuffer object.

---
### Description
`glGetRenderbufferParameteriv` and `glGetNamedRenderbufferParameteriv` query parameters of a
specified renderbuffer object.

For `glGetRenderbufferParameteriv`, the renderbuffer object is that bound to `target`, which
must be `GL_RENDERBUFFER`.

For `glGetNamedRenderbufferParameteriv`, `renderbuffer` is the name of the renderbuffer
object.

Upon successful return, `param` will contain the value of the renderbuffer parameter specified
by `pname`, as described below.

`GL_RENDERBUFFER_WIDTH`, `GL_RENDERBUFFER_HEIGHT`, `GL_RENDERBUFFER_INTERNAL_FORMAT` or
`GL_RENDERBUFFER_SAMPLES` `params` returns the width in pixels, the height in pixels, internal
format, or the number of samples, respectively, of the image of the specified renderbuffer object.

`GL_RENDERBUFFER_RED_SIZE`, `GL_RENDERBUFFER_GREEN_SIZE`, `GL_RENDERBUFFER_BLUE_SIZE`,
`GL_RENDERBUFFER_ALPHA_SIZE`, `GL_RENDERBUFFER_DEPTH_SIZE` or `GL_RENDERBUFFER_STENCIL_SIZE`
`params` returns the actual resolution in bits (not the resolution specified when the image was
defined) for the red, green, blue, alpha, depth or stencil components, respectively, of the image of
the renderbuffer object.

---
### Errors
`GL_INVALID_ENUM` is generated by `glGetRenderbufferParameteriv` if `target` is not
`GL_RENDERBUFFER`.

`GL_INVALID_OPERATION` is generated by `glGetRenderbufferParameteriv` if zero is bound to
`target`.

`GL_INVALID_OPERATION` is generated by `glGetNamedRenderbufferParameteriv` if `renderbuffer`
is not the name of an existing renderbuffer object.

`GL_INVALID_ENUM` is generated if `pname` is not one of the accepted parameter names described
above.
---
### Version Support
`glGetNamedRenderbufferParameteriv` `glGetRenderbufferParameteriv`
---
### See Also
glGenRenderbuffers, glFramebufferRenderbuffer, glBindRenderbuffer, glRenderbufferStorage,
glRenderbufferStorageMultisample
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Return sampler parameter values
---
### Parameters
`sampler` Specifies name of the sampler object from which to retrieve parameters.
`pname` Specifies the symbolic name of a sampler parameter. `GL_TEXTURE_MAG_FILTER`,
`GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_LOD_BIAS`,
`GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`, `GL_TEXTURE_BORDER_COLOR`,
`GL_TEXTURE_COMPARE_MODE`, and `GL_TEXTURE_COMPARE_FUNC` are accepted.

`params` Returns the sampler parameters.
---
### Description
`glGetSamplerParameter` returns in `params` the value or values of the sampler parameter
specified as `pname`. `sampler` defines the target sampler, and must be the name of an existing
sampler object, returned from a previous call to glGenSamplers. `pname` accepts the same
symbols as glSamplerParameter, with the same interpretations:

`GL_TEXTURE_MAG_FILTER` Returns the single-valued texture magnification filter, a symbolic
constant. The initial value is `GL_LINEAR`.

`GL_TEXTURE_MIN_FILTER` Returns the single-valued texture minification filter, a symbolic
constant. The initial value is `GL_NEAREST_MIPMAP_LINEAR`.

`GL_TEXTURE_MIN_LOD` Returns the single-valued texture minimum level-of-detail value. The
initial value is -1000.

`GL_TEXTURE_MAX_LOD` Returns the single-valued texture maximum level-of-detail value. The
initial value is 1000.
`GL_TEXTURE_WRAP_S` Returns the single-valued wrapping function for texture coordinate s, a
symbolic constant. The initial value is `GL_REPEAT`.

`GL_TEXTURE_WRAP_T` Returns the single-valued wrapping function for texture coordinate t, a
symbolic constant. The initial value is `GL_REPEAT`.

`GL_TEXTURE_WRAP_R` Returns the single-valued wrapping function for texture coordinate r, a
symbolic constant. The initial value is `GL_REPEAT`.

`GL_TEXTURE_BORDER_COLOR` Returns four integer or floating-point numbers that comprise the RGBA
color of the texture border. Floating-point values are returned in the range 0 1. Integer
values are returned as a linear mapping of the internal floating-point representation such that 1.0
maps to the most positive representable integer and -1.0 maps to the most negative representable
integer. The initial value is (0, 0, 0, 0).

`GL_TEXTURE_COMPARE_MODE` Returns a single-valued texture comparison mode, a symbolic constant.

The initial value is `GL_NONE`. See glSamplerParameter.

`GL_TEXTURE_COMPARE_FUNC` Returns a single-valued texture comparison function, a symbolic
constant. The initial value is `GL_LEQUAL`. See glSamplerParameter.

---
### Notes
If an error is generated, no change is made to the contents of `params`.

`glGetSamplerParameter` is available only if the GL version is 3.3 or higher.
---
### Errors
`GL_INVALID_VALUE` is generated if `sampler` is not the name of a sampler object returned from
a previous call to glGenSamplers.

`GL_INVALID_ENUM` is generated if `pname` is not an accepted value.
---
### Version Support
`glGetSamplerParameterIiv` `glGetSamplerParameterIuiv` `glGetSamplerParameterfv`
`glGetSamplerParameteriv`
---
### See Also
glSamplerParameter, glGenSamplers, glDeleteSamplers, glSamplerParameter
---
### Copyright
Copyright 2010-2014 Khronos Group. This material may be distributed subject to the terms and
conditions set forth in the Open Publication License, v 1.0, 8 June 1999.

https://opencontent.org/openpub/.
]],
  [[Returns a parameter from a shader object
---
### Parameters
`shader` Specifies the shader object to be queried.
`pname` Specifies the object parameter. Accepted symbolic names are `GL_SHADER_TYPE`,
`GL_DELETE_STATUS`, `GL_COMPILE_STATUS`, `GL_INFO_LOG_LENGTH`, `GL_SHADER_SOURCE_LENGTH`.

`params` Returns the requested object parameter.
---
### Description
`glGetShader` returns in `params` the value of a parameter for a specific shader object. The
following parameters are defined:

`GL_SHADER_TYPE` `params` returns `GL_VERTEX_SHADER` if `shader` is a vertex shader
object, `GL_GEOMETRY_SHADER` if `shader` is a geometry shader object, and `GL_FRAGMENT_SHADER`
if `shader` is a fragment shader object.

`GL_DELETE_STATUS` `params` returns `GL_TRUE` if `shader` is currently flagged for
deletion, and `GL_FALSE` otherwise.

`GL_COMPILE_STATUS` `params` returns `GL_TRUE` if the last compile operation on `shader`
was successful, and `GL_FALSE` otherwise.

`GL_INFO_LOG_LENGTH` `params` returns the number of characters in the information log for
`shader` including the null termination character (i.e., the size of the character buffer required
to store the information log). If `shader` has no information log, a value of 0 is returned.

`GL_SHADER_SOURCE_LENGTH` `params` returns the length of the concatenation of the source
strings that make up the shader source for the `shader`, including the null termination character.
(i.e., the size of the character buffer required to store the shader source). If no source code
exists, 0 is returned.

---
### Notes
If an error is generated, no change is made to the contents of `params`.
---
### Errors
`GL_INVALID_VALUE` is generated if `shader` is not a value generated by OpenGL.

`GL_INVALID_OPERATION` is generated if `shader` does not refer to a shader object.

`GL_INVALID_ENUM` is generated if `pname` is not an accepted value.
---
### Associated Gets
glGetShaderInfoLog with argument `shader`

glGetShaderSource with argument `shader`

glIsShader
---
### Version Support
`glGetShaderiv`
---
### See Also
glCompileShader, glCreateShader, glDeleteShader, glGetProgram, glShaderSource
---
### Copyright
Copyright 2003-2005 3Dlabs Inc. Ltd. Copyright 2010-2014 Khronos Group. This material may be
distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8
June 1999. https://opencontent.org/openpub/.
]],
  [[Returns the information log for a shader object
---
### Parameters
`shader` Specifies the shader object whose information log is to be queried.
`maxLength` Specifies the size of the character buffer for storing the returned information log.

`length` Returns the length of the string returned in `infoLog` (excluding the null
terminator).

`infoLog` Specifies an array of characters that is used to return the information log.
---
### Description
`glGetShaderInfoLog` returns the information log for the specified shader object. The information
log for a shader object is modified when the shader is compiled. The string that is returned will be
null terminated.

`glGetShaderInfoLog` returns in `infoLog` as much of the information log as it can, up to a
maximum of `maxLength` characters. The number of characters actually returned, excluding the null
termination character, is specified by `length`. If the length of the returned string is not
required, a value of `NULL` can be passed in the `length` argument. The size of the buffer
required to store the returned information log can be obtained by calling glGetShader with the
value `GL_INFO_LOG_LENGTH`.

The information log for a shader object is a string that may contain diagnostic messages, warning
messages, and other information about the last compile operation. When a shader object is created,
its information log will be a string of length 0.
---
### Notes
The information log for a shader object is the OpenGL implementer's primary mechanism for conveying
information about the compilation process. Therefore, the information log can be helpful to
application developers during the development process, even when compilation is successful.

Application developers should not expect different OpenGL implementations to produce identical
information logs.
---
### Errors
`GL_INVALID_VALUE` is generated if `shader` is not a value generated by OpenGL.

`GL_INVALID_OPERATION` is generated if `shader` is not a shader object.

`GL_INVALID_VALUE` is generated if `maxLength` is less than 0.
---
### Associated Gets
glGetShader with argument `GL_INFO_LOG_LENGTH`

glIsShader
---
### Version Support
`glGetShaderInfoLog`
---
### See Also
glCompileShader, glGetProgramInfoLog, glLinkProgram, glValidateProgram
---
### Copyright
Copyright 2003-2005 3Dlabs Inc. Ltd. Copyright 2010-2014 Khronos Group. This material may be
distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8
June 1999. https://opencontent.org/openpub/.
]],
}

local signatures = {
  {
    'void glUniform1f(GLint location, GLfloat v0)',
    'void glUniform1fv(GLint location, GLsizei count, const GLfloat *value)',
    'void glUniform1i(GLint location, GLint v0)',
    'void glUniform1iv(GLint location, GLsizei count, const GLint *value)',
    'void glUniform1ui(GLint location, GLuint v0)',
    'void glUniform1uiv(GLint location, GLsizei count, const GLuint *value)',
    'void glUniform2f(GLint location, GLfloat v0, GLfloat v1)',
    'void glUniform2fv(GLint location, GLsizei count, const GLfloat *value)',
    'void glUniform2i(GLint location, GLint v0, GLint v1)',
    'void glUniform2iv(GLint location, GLsizei count, const GLint *value)',
    'void glUniform2ui(GLint location, GLuint v0, GLuint v1)',
    'void glUniform2uiv(GLint location, GLsizei count, const GLuint *value)',
    'void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2)',
    'void glUniform3fv(GLint location, GLsizei count, const GLfloat *value)',
    'void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2)',
    'void glUniform3iv(GLint location, GLsizei count, const GLint *value)',
    'void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2)',
    'void glUniform3uiv(GLint location, GLsizei count, const GLuint *value)',
    'void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)',
    'void glUniform4fv(GLint location, GLsizei count, const GLfloat *value)',
    'void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3)',
    'void glUniform4iv(GLint location, GLsizei count, const GLint *value)',
    'void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3)',
    'void glUniform4uiv(GLint location, GLsizei count, const GLuint *value)',
    'void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)',
    'void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)',
    'void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)',
    'void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)',
    'void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)',
    'void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)',
    'void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)',
    'void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)',
    'void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)',
  },
  {
    'void glGetShaderPrecisionFormat(GLenum shaderType, GLenum precisionType, GLint *range, GLint *precision)',
  },
  { 'void glGetShaderSource(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source)' },
  {
    'const GLubyte *glGetString(GLenum name)',
    'const GLubyte *glGetStringi(GLenum name, GLuint index)',
  },
  { 'GLuint glGetSubroutineIndex(GLuint program, GLenum shadertype, const GLchar *name)' },
  {
    'GLint glGetSubroutineUniformLocation(GLuint program, GLenum shadertype, const GLchar *name)',
  },
  {
    'void glGetSynciv(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values)',
  },
  {
    'void glGetnTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *pixels)',
    'void glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, void * pixels)',
    'void glGetTextureImage(GLuint texture, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *pixels)',
  },
  {
    'void glTexParameterf(GLenum target, GLenum pname, GLfloat param)',
    'void glTexParameterfv(GLenum target, GLenum pname, const GLfloat * params)',
    'void glTexParameteri(GLenum target, GLenum pname, GLint param)',
    'void glTexParameterIiv(GLenum target, GLenum pname, const GLint * params)',
    'void glTexParameterIuiv(GLenum target, GLenum pname, const GLuint * params)',
    'void glTexParameteriv(GLenum target, GLenum pname, const GLint * params)',
    'void glTextureParameterf(GLuint texture, GLenum pname, GLfloat param)',
    'void glTextureParameterfv(GLuint texture, GLenum pname, const GLfloat *params)',
    'void glTextureParameteri(GLuint texture, GLenum pname, GLint param)',
    'void glTextureParameterIiv(GLuint texture, GLenum pname, const GLint *params)',
    'void glTextureParameterIuiv(GLuint texture, GLenum pname, const GLuint *params)',
    'void glTextureParameteriv(GLuint texture, GLenum pname, const GLint *params)',
  },
  {
    'void glTexStorage1D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width)',
    'void glTextureStorage1D(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width)',
  },
  {
    'void glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat * params)',
    'void glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint * params)',
    'void glGetTextureLevelParameterfv(GLuint texture, GLint level, GLenum pname, GLfloat *params)',
    'void glGetTextureLevelParameteriv(GLuint texture, GLint level, GLenum pname, GLint *params)',
  },
  {
    'void glTexStorage2D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height)',
    'void glTextureStorage2D(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height)',
  },
  {
    'void glTexStorage2DMultisample(\\n  GLenum target,\\n  GLsizei samples,\\n  GLenum internalformat,\\n  GLsizei width,\\n  GLsizei height,\\n  GLboolean fixedsamplelocations\\n)',
    'void glTextureStorage2DMultisample(\\n  GLuint texture,\\n  GLsizei samples,\\n  GLenum internalformat,\\n  GLsizei width,\\n  GLsizei height,\\n  GLboolean fixedsamplelocations\\n)',
  },
  {
    'void glGetTexParameterfv(GLenum target, GLenum pname, GLfloat * params)',
    'void glGetTexParameterIiv(GLenum target, GLenum pname, GLint * params)',
    'void glGetTexParameterIuiv(GLenum target, GLenum pname, GLuint * params)',
    'void glGetTexParameteriv(GLenum target, GLenum pname, GLint * params)',
    'void glGetTextureParameterfv(GLuint texture, GLenum pname, GLfloat *params)',
    'void glGetTextureParameterIiv(GLuint texture, GLenum pname, GLint *params)',
    'void glGetTextureParameterIuiv(GLuint texture, GLenum pname, GLuint *params)',
    'void glGetTextureParameteriv(GLuint texture, GLenum pname, GLint *params)',
  },
  {
    'void glTexStorage3D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth)',
    'void glTextureStorage3D(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth)',
  },
  {
    'void glTexStorage3DMultisample(\\n  GLenum target,\\n  GLsizei samples,\\n  GLenum internalformat,\\n  GLsizei width,\\n  GLsizei height,\\n  GLsizei depth,\\n  GLboolean fixedsamplelocations\\n)',
    'void glTextureStorage3DMultisample(\\n  GLuint texture,\\n  GLsizei samples,\\n  GLenum internalformat,\\n  GLsizei width,\\n  GLsizei height,\\n  GLsizei depth,\\n  GLboolean fixedsamplelocations\\n)',
  },
  {
    'void glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void * pixels)',
    'void glTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels)',
  },
  {
    'void glTexSubImage2D(\\n  GLenum target,\\n  GLint level,\\n  GLint xoffset,\\n  GLint yoffset,\\n  GLsizei width,\\n  GLsizei height,\\n  GLenum format,\\n  GLenum type,\\n  const void * pixels\\n)',
    'void glTextureSubImage2D(\\n  GLuint texture,\\n  GLint level,\\n  GLint xoffset,\\n  GLint yoffset,\\n  GLsizei width,\\n  GLsizei height,\\n  GLenum format,\\n  GLenum type,\\n  const void *pixels\\n)',
  },
  {
    'void glGetTextureSubImage(\\n  GLuint texture,\\n  GLint level,\\n  GLint xoffset,\\n  GLint yoffset,\\n  GLint zoffset,\\n  GLsizei width,\\n  GLsizei height,\\n  GLsizei depth,\\n  GLenum format,\\n  GLenum type,\\n  GLsizei bufSize,\\n  void *pixels\\n)',
  },
  {
    'void glTexSubImage3D(\\n  GLenum target,\\n  GLint level,\\n  GLint xoffset,\\n  GLint yoffset,\\n  GLint zoffset,\\n  GLsizei width,\\n  GLsizei height,\\n  GLsizei depth,\\n  GLenum format,\\n  GLenum type,\\n  const void * pixels\\n)',
    'void glTextureSubImage3D(\\n  GLuint texture,\\n  GLint level,\\n  GLint xoffset,\\n  GLint yoffset,\\n  GLint zoffset,\\n  GLsizei width,\\n  GLsizei height,\\n  GLsizei depth,\\n  GLenum format,\\n  GLenum type,\\n  const void *pixels\\n)',
  },
  {
    'void glGetTransformFeedbacki64_v(GLuint xfb, GLenum pname, GLuint index, GLint64 *param)',
    'void glGetTransformFeedbackiv(GLuint xfb, GLenum pname, GLint *param)',
    'void glGetTransformFeedbacki_v(GLuint xfb, GLenum pname, GLuint index, GLint *param)',
  },
  { 'void glTextureBarrier(void)' },
  {
    'void glTextureView(\\n  GLuint texture,\\n  GLenum target,\\n  GLuint origtexture,\\n  GLenum internalformat,\\n  GLuint minlevel,\\n  GLuint numlevels,\\n  GLuint minlayer,\\n  GLuint numlayers\\n)',
  },
  {
    'void glGetTransformFeedbackVarying(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, char *name)',
  },
  { 'void glTransformFeedbackBufferBase(GLuint xfb, GLuint index, GLuint buffer)' },
  {
    'void glGetnUniformdv(GLuint program, GLint location, GLsizei bufSize, GLdouble *params)',
    'void glGetnUniformfv(GLuint program, GLint location, GLsizei bufSize, GLfloat *params)',
    'void glGetnUniformiv(GLuint program, GLint location, GLsizei bufSize, GLint *params)',
    'void glGetnUniformuiv(GLuint program, GLint location, GLsizei bufSize, GLuint *params)',
    'void glGetUniformdv(GLuint program, GLint location, GLdouble *params)',
    'void glGetUniformfv(GLuint program, GLint location, GLfloat *params)',
    'void glGetUniformiv(GLuint program, GLint location, GLint *params)',
    'void glGetUniformuiv(GLuint program, GLint location, GLuint *params)',
  },
  {
    'void glTransformFeedbackBufferRange(GLuint xfb, GLuint index, GLuint buffer, GLintptr offset, GLsizei size)',
  },
  {
    'void glTransformFeedbackVaryings(GLuint program, GLsizei count, const char **varyings, GLenum bufferMode)',
  },
  {
    'void glGetVertexAttribdv(GLuint index, GLenum pname, GLdouble *params)',
    'void glGetVertexAttribfv(GLuint index, GLenum pname, GLfloat *params)',
    'void glGetVertexAttribIiv(GLuint index, GLenum pname, GLint *params)',
    'void glGetVertexAttribIuiv(GLuint index, GLenum pname, GLuint *params)',
    'void glGetVertexAttribiv(GLuint index, GLenum pname, GLint *params)',
    'void glGetVertexAttribLdv(GLuint index, GLenum pname, GLdouble *params)',
  },
  {
    'void glFramebufferParameteri(GLenum target, GLenum pname, GLint param)',
    'void glNamedFramebufferParameteri(GLuint framebuffer, GLenum pname, GLint param)',
  },
  {
    'void glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)',
    'void glNamedFramebufferRenderbuffer(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)',
  },
  {
    'void glFramebufferTexture1D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)',
    'void glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)',
    'void glFramebufferTexture3D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint layer)',
    'void glFramebufferTexture(GLenum target, GLenum attachment, GLuint texture, GLint level)',
    'void glNamedFramebufferTexture(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level)',
  },
  {
    'void glGetFramebufferParameteriv(GLenum target, GLenum pname, GLint *params)',
    'void glGetNamedFramebufferParameteriv(GLuint framebuffer, GLenum pname, GLint *param)',
  },
  { 'GLenum glGetGraphicsResetStatus(void)' },
  {
    'void glFramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)',
    'void glNamedFramebufferTextureLayer(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer)',
  },
  {
    'void glGetInternalformati64v(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint64 *params)',
    'void glGetInternalformativ(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *params)',
  },
  { 'void glFrontFace(GLenum mode)' },
  { 'void glGetMultisamplefv(GLenum pname, GLuint index, GLfloat *val)' },
  { 'void glGenBuffers(GLsizei n, GLuint * buffers)' },
  {
    'void glGetObjectLabel(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei * length, char * label)',
  },
  { 'void glGenFramebuffers(GLsizei n, GLuint *ids)' },
  { 'void glGetObjectPtrLabel(void * ptr, GLsizei bufSize, GLsizei * length, char * label)' },
  { 'void glGenProgramPipelines(GLsizei n, GLuint *pipelines)' },
  { 'void glGetPointerv(GLenum pname, void ** params)' },
  { 'void glGenQueries(GLsizei n, GLuint * ids)' },
  { 'void glGetProgramiv(GLuint program, GLenum pname, GLint *params)' },
  { 'void glGenRenderbuffers(GLsizei n, GLuint *renderbuffers)' },
  {
    'void glGetProgramBinary(GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, void *binary)',
  },
  { 'void glGenSamplers(GLsizei n, GLuint *samplers)' },
  {
    'void glGetProgramInfoLog(GLuint program, GLsizei maxLength, GLsizei *length, GLchar *infoLog)',
  },
  { 'void glGenTextures(GLsizei n, GLuint * textures)' },
  {
    'void glGetProgramInterfaceiv(GLuint program, GLenum programInterface, GLenum pname, GLint * params)',
  },
  { 'void glGenTransformFeedbacks(GLsizei n, GLuint *ids)' },
  { 'void glGetProgramPipelineiv(GLuint pipeline, GLenum pname, GLint *params)' },
  { 'void glGenVertexArrays(GLsizei n, GLuint *arrays)' },
  {
    'void glGetProgramPipelineInfoLog(GLuint pipeline, GLsizei bufSize, GLsizei *length, GLchar *infoLog)',
  },
  { 'void glGenerateMipmap(GLenum target)', 'void glGenerateTextureMipmap(GLuint texture)' },
  {
    'void glGetProgramResourceiv(\\n  GLuint program,\\n  GLenum programInterface,\\n  GLuint index,\\n  GLsizei propCount,\\n  const GLenum * props,\\n  GLsizei bufSize,\\n  GLsizei * length,\\n  GLint * params\\n)',
  },
  {
    'GLuint glGetProgramResourceIndex(GLuint program, GLenum programInterface, const char * name)',
  },
  {
    'void glGetBooleani_v(GLenum target, GLuint index, GLboolean * data)',
    'void glGetBooleanv(GLenum pname, GLboolean * data)',
    'void glGetDoublei_v(GLenum target, GLuint index, GLdouble * data)',
    'void glGetDoublev(GLenum pname, GLdouble * data)',
    'void glGetFloati_v(GLenum target, GLuint index, GLfloat * data)',
    'void glGetFloatv(GLenum pname, GLfloat * data)',
    'void glGetInteger64i_v(GLenum target, GLuint index, GLint64 * data)',
    'void glGetInteger64v(GLenum pname, GLint64 * data)',
    'void glGetIntegeri_v(GLenum target, GLuint index, GLint * data)',
    'void glGetIntegerv(GLenum pname, GLint * data)',
  },
  {
    'GLint glGetProgramResourceLocation(GLuint program, GLenum programInterface, const char * name)',
  },
  {
    'GLint glGetProgramResourceLocationIndex(GLuint program, GLenum programInterface, const char * name)',
  },
  {
    'void glGetProgramResourceName(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei * length, char * name)',
  },
  { 'void glGetProgramStageiv(GLuint program, GLenum shadertype, GLenum pname, GLint *values)' },
  { 'void glGetQueryIndexediv(GLenum target, GLuint index, GLenum pname, GLint * params)' },
  {
    'void glGetQueryBufferObjecti64v(GLuint id, GLuint buffer, GLenum pname, GLintptr offset)',
    'void glGetQueryBufferObjectiv(GLuint id, GLuint buffer, GLenum pname, GLintptr offset)',
    'void glGetQueryBufferObjectui64v(GLuint id, GLuint buffer, GLenum pname, GLintptr offset)',
    'void glGetQueryBufferObjectuiv(GLuint id, GLuint buffer, GLenum pname, GLintptr offset)',
    'void glGetQueryObjecti64v(GLuint id, GLenum pname, GLint64 * params)',
    'void glGetQueryObjectiv(GLuint id, GLenum pname, GLint * params)',
    'void glGetQueryObjectui64v(GLuint id, GLenum pname, GLuint64 * params)',
    'void glGetQueryObjectuiv(GLuint id, GLenum pname, GLuint * params)',
  },
  {
    'void glGetActiveAtomicCounterBufferiv(GLuint program, GLuint bufferIndex, GLenum pname, GLint *params)',
  },
  {
    'void glGetActiveAttrib(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name)',
  },
  {
    'void glGetActiveSubroutineName(GLuint program, GLenum shadertype, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name)',
  },
  {
    'void glGetActiveSubroutineUniformiv(GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint *values)',
  },
  {
    'void glGetActiveSubroutineUniformName(GLuint program, GLenum shadertype, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name)',
  },
  {
    'void glGetActiveUniform(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name)',
  },
  {
    'void glGetActiveUniformBlockiv(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *params)',
  },
  {
    'void glGetActiveUniformBlockName(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformBlockName)',
  },
  {
    'void glGetActiveUniformName(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformName)',
  },
  {
    'void glGetActiveUniformsiv(GLuint program, GLsizei uniformCount, const GLuint *uniformIndices, GLenum pname, GLint *params)',
  },
  {
    'void glGetAttachedShaders(GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders)',
  },
  { 'GLint glGetAttribLocation(GLuint program, const GLchar *name)' },
  {
    'void glGetBufferParameteri64v(GLenum target, GLenum value, GLint64 * data)',
    'void glGetBufferParameteriv(GLenum target, GLenum value, GLint * data)',
    'void glGetNamedBufferParameteri64v(GLuint buffer, GLenum pname, GLint64 *params)',
    'void glGetNamedBufferParameteriv(GLuint buffer, GLenum pname, GLint *params)',
  },
  {
    'void glGetBufferPointerv(GLenum target, GLenum pname, void ** params)',
    'void glGetNamedBufferPointerv(GLuint buffer, GLenum pname, void **params)',
  },
  { 'void glGetBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, void * data)' },
  {
    'void glDrawElementsInstancedBaseInstance(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount, GLuint baseinstance)',
  },
  {
    'void glDrawElementsInstancedBaseVertex(GLenum mode, GLsizei count, GLenum type, void *indices, GLsizei instancecount, GLint basevertex)',
  },
  {
    'void glDrawElementsInstancedBaseVertexBaseInstance(\\n  GLenum mode,\\n  GLsizei count,\\n  GLenum type,\\n  void *indices,\\n  GLsizei instancecount,\\n  GLint basevertex,\\n  GLuint baseinstance\\n )',
  },
  {
    'void glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void * indices)',
  },
  {
    'void glDrawRangeElementsBaseVertex(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, void *indices, GLint basevertex)',
  },
  { 'void glDrawTransformFeedback(GLenum mode, GLuint id)' },
  { 'void glDrawTransformFeedbackInstanced(GLenum mode, GLuint id, GLsizei instancecount)' },
  { 'void glDrawTransformFeedbackStream(GLenum mode, GLuint id, GLuint stream)' },
  {
    'void glDrawTransformFeedbackStreamInstanced(GLenum mode, GLuint id, GLuint stream, GLsizei instancecount)',
  },
  {
    'void glDisable(GLenum cap)',
    'void glDisablei(GLenum cap, GLuint index)',
    'void glEnable(GLenum cap)',
    'void glEnablei(GLenum cap, GLuint index)',
  },
  {
    'void glGetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint *params)',
    'void glGetNamedFramebufferAttachmentParameteriv(GLuint framebuffer, GLenum attachment, GLenum pname, GLint *params)',
  },
  {
    'void glDisableVertexArrayAttrib(GLuint vaobj, GLuint index)',
    'void glDisableVertexAttribArray(GLuint index)',
    'void glEnableVertexArrayAttrib(GLuint vaobj, GLuint index)',
    'void glEnableVertexAttribArray(GLuint index)',
  },
  { 'GLsync glFenceSync(GLenum condition, GLbitfield flags)' },
  { 'void glFinish(void)' },
  { 'void glFlush(void)' },
  {
    'void glFlushMappedBufferRange(GLenum target, GLintptr offset, GLsizeiptr length)',
    'void glFlushMappedNamedBufferRange(GLuint buffer, GLintptr offset, GLsizeiptr length)',
  },
  {
    'void glVertexAttrib1d(GLuint index, GLdouble v0)',
    'void glVertexAttrib1dv(GLuint index, const GLdouble *v)',
    'void glVertexAttrib1f(GLuint index, GLfloat v0)',
    'void glVertexAttrib1fv(GLuint index, const GLfloat *v)',
    'void glVertexAttrib1s(GLuint index, GLshort v0)',
    'void glVertexAttrib1sv(GLuint index, const GLshort *v)',
    'void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1)',
    'void glVertexAttrib2dv(GLuint index, const GLdouble *v)',
    'void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1)',
    'void glVertexAttrib2fv(GLuint index, const GLfloat *v)',
    'void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1)',
    'void glVertexAttrib2sv(GLuint index, const GLshort *v)',
    'void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2)',
    'void glVertexAttrib3dv(GLuint index, const GLdouble *v)',
    'void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2)',
    'void glVertexAttrib3fv(GLuint index, const GLfloat *v)',
    'void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2)',
    'void glVertexAttrib3sv(GLuint index, const GLshort *v)',
    'void glVertexAttrib4bv(GLuint index, const GLbyte *v)',
    'void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3)',
    'void glVertexAttrib4dv(GLuint index, const GLdouble *v)',
    'void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)',
    'void glVertexAttrib4fv(GLuint index, const GLfloat *v)',
    'void glVertexAttrib4iv(GLuint index, const GLint *v)',
    'void glVertexAttrib4Nbv(GLuint index, const GLbyte *v)',
    'void glVertexAttrib4Niv(GLuint index, const GLint *v)',
    'void glVertexAttrib4Nsv(GLuint index, const GLshort *v)',
    'void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3)',
    'void glVertexAttrib4Nubv(GLuint index, const GLubyte *v)',
    'void glVertexAttrib4Nuiv(GLuint index, const GLuint *v)',
    'void glVertexAttrib4Nusv(GLuint index, const GLushort *v)',
    'void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3)',
    'void glVertexAttrib4sv(GLuint index, const GLshort *v)',
    'void glVertexAttrib4ubv(GLuint index, const GLubyte *v)',
    'void glVertexAttrib4uiv(GLuint index, const GLuint *v)',
    'void glVertexAttrib4usv(GLuint index, const GLushort *v)',
    'void glVertexAttribI1i(GLuint index, GLint v0)',
    'void glVertexAttribI1iv(GLuint index, const GLint *v)',
    'void glVertexAttribI1ui(GLuint index, GLuint v0)',
    'void glVertexAttribI1uiv(GLuint index, const GLuint *v)',
    'void glVertexAttribI2i(GLuint index, GLint v0, GLint v1)',
    'void glVertexAttribI2iv(GLuint index, const GLint *v)',
    'void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1)',
    'void glVertexAttribI2uiv(GLuint index, const GLuint *v)',
    'void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2)',
    'void glVertexAttribI3iv(GLuint index, const GLint *v)',
    'void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2)',
    'void glVertexAttribI3uiv(GLuint index, const GLuint *v)',
    'void glVertexAttribI4bv(GLuint index, const GLbyte *v)',
    'void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3)',
    'void glVertexAttribI4iv(GLuint index, const GLint *v)',
    'void glVertexAttribI4sv(GLuint index, const GLshort *v)',
    'void glVertexAttribI4ubv(GLuint index, const GLubyte *v)',
    'void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3)',
    'void glVertexAttribI4uiv(GLuint index, const GLuint *v)',
    'void glVertexAttribI4usv(GLuint index, const GLushort *v)',
    'void glVertexAttribL1d(GLuint index, GLdouble v0)',
    'void glVertexAttribL1dv(GLuint index, const GLdouble *v)',
    'void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1)',
    'void glVertexAttribL2dv(GLuint index, const GLdouble *v)',
    'void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2)',
    'void glVertexAttribL3dv(GLuint index, const GLdouble *v)',
    'void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3)',
    'void glVertexAttribL4dv(GLuint index, const GLdouble *v)',
    'void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value)',
    'void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value)',
    'void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value)',
    'void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value)',
  },
  {
    'void glVertexArrayAttribBinding(GLuint vaobj, GLuint attribindex, GLuint bindingindex)',
    'void glVertexAttribBinding(GLuint attribindex, GLuint bindingindex)',
  },
  { 'void glVertexAttribDivisor(GLuint index, GLuint divisor)' },
  {
    'void glVertexArrayAttribFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset)',
    'void glVertexArrayAttribIFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset)',
    'void glVertexArrayAttribLFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset)',
    'void glVertexAttribFormat(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset)',
    'void glVertexAttribIFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset)',
    'void glVertexAttribLFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset)',
  },
  {
    'void glVertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer)',
    'void glVertexAttribLPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer)',
    'void glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void * pointer)',
  },
  {
    'void glVertexArrayBindingDivisor(GLuint vaobj, GLuint bindingindex, GLuint divisor)',
    'void glVertexBindingDivisor(GLuint bindingindex, GLuint divisor)',
  },
  { 'void glViewport(GLint x, GLint y, GLsizei width, GLsizei height)' },
  { 'void glViewportArrayv(GLuint first, GLsizei count, const GLfloat *v)' },
  {
    'void glViewportIndexedf(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h)',
    'void glViewportIndexedfv(GLuint index, const GLfloat *v)',
  },
  { 'void glWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout)' },
  { 'void glBeginConditionalRender(GLuint id, GLenum mode)', 'void glEndConditionalRender(void)' },
  { 'void glBeginQuery(GLenum target, GLuint id)', 'void glEndQuery(GLenum target)' },
  {
    'void glBeginQueryIndexed(GLenum target, GLuint index, GLuint id)',
    'void glEndQueryIndexed(GLenum target, GLuint index)',
  },
  { 'void glBeginTransformFeedback(GLenum primitiveMode)', 'void glEndTransformFeedback(void)' },
  { 'void glBindAttribLocation(GLuint program, GLuint index, const GLchar *name)' },
  { 'void glBindBuffer(GLenum target, GLuint buffer)' },
  { 'void glBindBufferBase(GLenum target, GLuint index, GLuint buffer)' },
  {
    'void glBindBufferRange(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size)',
  },
  { 'void glBindBuffersBase(GLenum target, GLuint first, GLsizei count, const GLuint *buffers)' },
  {
    'void glBindBuffersRange(GLenum target, GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLintptr *sizes)',
  },
  { 'void glBindFragDataLocation(GLuint program, GLuint colorNumber, const char * name)' },
  {
    'void glBindFragDataLocationIndexed(GLuint program, GLuint colorNumber, GLuint index, const char *name)',
  },
  { 'void glBindFramebuffer(GLenum target, GLuint framebuffer)' },
  {
    'void glBindImageTexture(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format)',
  },
  { 'void glBindImageTextures(GLuint first, GLsizei count, const GLuint *textures)' },
  { 'void glBindProgramPipeline(GLuint pipeline)' },
  { 'void glBindRenderbuffer(GLenum target, GLuint renderbuffer)' },
  { 'void glBindSampler(GLuint unit, GLuint sampler)' },
  { 'void glBindSamplers(GLuint first, GLsizei count, const GLuint *samplers)' },
  { 'void glBindTexture(GLenum target, GLuint texture)' },
  { 'void glBindTextureUnit(GLuint unit, GLuint texture)' },
  { 'void glBindTextures(GLuint first, GLsizei count, const GLuint *textures)' },
  { 'void glBindTransformFeedback(GLenum target, GLuint id)' },
  { 'void glBindVertexArray(GLuint array)' },
  {
    'void glBindVertexBuffer(GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride)',
    'void glVertexArrayVertexBuffer(GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride)',
  },
  {
    'void glBindVertexBuffers(GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizei *strides)',
    'void glVertexArrayVertexBuffers(GLuint vaobj, GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizei *strides)',
  },
  { 'void glBlendColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)' },
  { 'void glBlendEquation(GLenum mode)', 'void glBlendEquationi(GLuint buf, GLenum mode)' },
  { 'void glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha)' },
  { 'void glBlendEquationSeparatei(GLuint buf, GLenum modeRGB, GLenum modeAlpha)' },
  {
    'void glBlendFunc(GLenum sfactor, GLenum dfactor)',
    'void glBlendFunci(GLuint buf, GLenum sfactor, GLenum dfactor)',
  },
  { 'void glBlendFuncSeparate(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)' },
  {
    'void glBlendFuncSeparatei(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)',
  },
  {
    'void glBlitFramebuffer(\\n  GLint srcX0,\\n  GLint srcY0,\\n  GLint srcX1,\\n  GLint srcY1,\\n  GLint dstX0,\\n  GLint dstY0,\\n  GLint dstX1,\\n  GLint dstY1,\\n  GLbitfield mask,\\n  GLenum filter\\n)',
    'void glBlitNamedFramebuffer(\\n  GLuint readFramebuffer,\\n  GLuint drawFramebuffer,\\n  GLint srcX0,\\n  GLint srcY0,\\n  GLint srcX1,\\n  GLint srcY1,\\n  GLint dstX0,\\n  GLint dstY0,\\n  GLint dstX1,\\n  GLint dstY1,\\n  GLbitfield mask,\\n  GLenum filter\\n)',
  },
  {
    'void glBufferData(GLenum target, GLsizeiptr size, const void * data, GLenum usage)',
    'void glNamedBufferData(GLuint buffer, GLsizeiptr size, const void *data, GLenum usage)',
  },
  { 'void glGetVertexAttribPointerv(GLuint index, GLenum pname, void **pointer)' },
  {
    'void glBufferStorage(GLenum target, GLsizeiptr size, const void * data, GLbitfield flags)',
    'void glNamedBufferStorage(GLuint buffer, GLsizeiptr size, const void *data, GLbitfield flags)',
  },
  { 'void glHint(GLenum target, GLenum mode)' },
  { 'void glInvalidateBufferData(GLuint buffer)' },
  {
    'void glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const void * data)',
    'void glNamedBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data)',
  },
  { 'void glInvalidateBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr length)' },
  {
    'void glInvalidateFramebuffer(GLenum target, GLsizei numAttachments, const GLenum * attachments)',
    'void glInvalidateNamedFramebufferData(GLuint framebuffer, GLsizei numAttachments, const GLenum *attachments)',
  },
  {
    'GLenum glCheckFramebufferStatus(GLenum target)',
    'GLenum glCheckNamedFramebufferStatus(GLuint framebuffer, GLenum target)',
  },
  {
    'void glInvalidateNamedFramebufferSubData(\\n  GLuint framebuffer,\\n  GLsizei numAttachments,\\n  const GLenum *attachments,\\n  GLint x,\\n  GLint y,\\n  GLsizei width,\\n  GLsizei height\\n)',
    'void glInvalidateSubFramebuffer(GLenum target, GLsizei numAttachments, const GLenum * attachments, GLint x, GLint y, GLint width, GLint height)',
  },
  { 'void glClampColor(GLenum target, GLenum clamp)' },
  { 'void glClear(GLbitfield mask)' },
  { 'void glInvalidateTexImage(GLuint texture, GLint level)' },
  {
    'void glClearBufferfi(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil)',
    'void glClearBufferfv(GLenum buffer, GLint drawbuffer, const GLfloat * value)',
    'void glClearBufferiv(GLenum buffer, GLint drawbuffer, const GLint * value)',
    'void glClearBufferuiv(GLenum buffer, GLint drawbuffer, const GLuint * value)',
    'void glClearNamedFramebufferfi(GLuint framebuffer, GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil)',
    'void glClearNamedFramebufferfv(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLfloat *value)',
    'void glClearNamedFramebufferiv(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLint *value)',
    'void glClearNamedFramebufferuiv(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLuint *value)',
  },
  {
    'void glInvalidateTexSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth)',
  },
  { 'GLboolean glIsBuffer(GLuint buffer)' },
  { 'GLboolean glIsEnabled(GLenum cap)', 'GLboolean glIsEnabledi(GLenum cap, GLuint index)' },
  { 'GLboolean glIsFramebuffer(GLuint framebuffer)' },
  { 'GLboolean glIsProgram(GLuint program)' },
  { 'GLboolean glIsProgramPipeline(GLuint pipeline)' },
  { 'GLboolean glIsQuery(GLuint id)' },
  {
    'void glClearBufferData(GLenum target, GLenum internalformat, GLenum format, GLenum type, const void * data)',
    'void glClearNamedBufferData(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void *data)',
  },
  { 'GLboolean glIsRenderbuffer(GLuint renderbuffer)' },
  {
    'void glClearBufferSubData(GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void * data)',
    'void glClearNamedBufferSubData(GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data)',
  },
  { 'void glClearColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)' },
  { 'void glClearDepthf(GLfloat depth)', 'void glClearDepth(GLdouble depth)' },
  { 'void glClearStencil(GLint s)' },
  {
    'void glClearTexImage(GLuint texture, GLint level, GLenum format, GLenum type, const void * data)',
  },
  {
    'void glClearTexSubImage(\\n  GLuint texture,\\n  GLint level,\\n  GLint xoffset,\\n  GLint yoffset,\\n  GLint zoffset,\\n  GLsizei width,\\n  GLsizei height,\\n  GLsizei depth,\\n  GLenum format,\\n  GLenum type,\\n  const void * data\\n)',
  },
  { 'GLenum glClientWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout)' },
  { 'void glClipControl(GLenum origin, GLenum depth)' },
  {
    'void glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)',
    'void glColorMaski(GLuint buf, GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)',
  },
  { 'void glCompileShader(GLuint shader)' },
  {
    'void glCompressedTexImage1D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void * data)',
  },
  {
    'void glCompressedTexImage2D(\\n  GLenum target,\\n  GLint level,\\n  GLenum internalformat,\\n  GLsizei width,\\n  GLsizei height,\\n  GLint border,\\n  GLsizei imageSize,\\n  const void * data\\n)',
  },
  {
    'void glCompressedTexImage3D(\\n  GLenum target,\\n  GLint level,\\n  GLenum internalformat,\\n  GLsizei width,\\n  GLsizei height,\\n  GLsizei depth,\\n  GLint border,\\n  GLsizei imageSize,\\n  const void * data\\n)',
  },
  {
    'void glCompressedTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void * data)',
    'void glCompressedTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data)',
  },
  {
    'void glCompressedTexSubImage2D(\\n  GLenum target,\\n  GLint level,\\n  GLint xoffset,\\n  GLint yoffset,\\n  GLsizei width,\\n  GLsizei height,\\n  GLenum format,\\n  GLsizei imageSize,\\n  const void * data\\n)',
    'void glCompressedTextureSubImage2D(\\n  GLuint texture,\\n  GLint level,\\n  GLint xoffset,\\n  GLint yoffset,\\n  GLsizei width,\\n  GLsizei height,\\n  GLenum format,\\n  GLsizei imageSize,\\n  const void *data\\n)',
  },
  {
    'void glCompressedTexSubImage3D(\\n  GLenum target,\\n  GLint level,\\n  GLint xoffset,\\n  GLint yoffset,\\n  GLint zoffset,\\n  GLsizei width,\\n  GLsizei height,\\n  GLsizei depth,\\n  GLenum format,\\n  GLsizei imageSize,\\n  const void * data\\n)',
    'void glCompressedTextureSubImage3D(\\n  GLuint texture,\\n  GLint level,\\n  GLint xoffset,\\n  GLint yoffset,\\n  GLint zoffset,\\n  GLsizei width,\\n  GLsizei height,\\n  GLsizei depth,\\n  GLenum format,\\n  GLsizei imageSize,\\n  const void *data\\n)',
  },
  {
    'void glCopyBufferSubData(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size)',
    'void glCopyNamedBufferSubData(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size)',
  },
  {
    'void glCopyImageSubData(\\n  GLuint srcName,\\n  GLenum srcTarget,\\n  GLint srcLevel,\\n  GLint srcX,\\n  GLint srcY,\\n  GLint srcZ,\\n  GLuint dstName,\\n  GLenum dstTarget,\\n  GLint dstLevel,\\n  GLint dstX,\\n  GLint dstY,\\n  GLint dstZ,\\n  GLsizei srcWidth,\\n  GLsizei srcHeight,\\n  GLsizei srcDepth\\n)',
  },
  {
    'void glCopyTexImage1D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)',
  },
  {
    'void glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)',
  },
  {
    'void glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)',
    'void glCopyTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)',
  },
  {
    'void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)',
    'void glCopyTextureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)',
  },
  {
    'void glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)',
    'void glCopyTextureSubImage3D(\\n  GLuint texture,\\n  GLint level,\\n  GLint xoffset,\\n  GLint yoffset,\\n  GLint zoffset,\\n  GLint x,\\n  GLint y,\\n  GLsizei width,\\n  GLsizei height\\n)',
  },
  { 'void glCreateBuffers(GLsizei n, GLuint *buffers)' },
  { 'void glCreateFramebuffers(GLsizei n, GLuint *framebuffers)' },
  { 'GLuint glCreateProgram(void)' },
  { 'void glCreateProgramPipelines(GLsizei n, GLuint *pipelines)' },
  { 'void glCreateQueries(GLenum target, GLsizei n, GLuint *ids)' },
  { 'void glCreateRenderbuffers(GLsizei n, GLuint *renderbuffers)' },
  { 'void glCreateSamplers(GLsizei n, GLuint *samplers)' },
  { 'GLuint glCreateShader(GLenum shaderType)' },
  { 'GLuint glCreateShaderProgramv(GLenum type, GLsizei count, const char **strings)' },
  { 'void glCreateTextures(GLenum target, GLsizei n, GLuint *textures)' },
  { 'void glCreateTransformFeedbacks(GLsizei n, GLuint *ids)' },
  { 'void glCreateVertexArrays(GLsizei n, GLuint *arrays)' },
  { 'void glCullFace(GLenum mode)' },
  { 'void glDebugMessageCallback(DEBUGPROC callback, const void * userParam)' },
  {
    'void glDebugMessageControl(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled)',
  },
  {
    'void glDebugMessageInsert(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const char *message)',
  },
  { 'void glDeleteBuffers(GLsizei n, const GLuint * buffers)' },
  { 'void glDeleteFramebuffers(GLsizei n, GLuint *framebuffers)' },
  { 'void glDeleteProgram(GLuint program)' },
  { 'void glDeleteProgramPipelines(GLsizei n, const GLuint *pipelines)' },
  { 'void glDeleteQueries(GLsizei n, const GLuint * ids)' },
  { 'void glActiveShaderProgram(GLuint pipeline, GLuint program)' },
  { 'void glActiveTexture(GLenum texture)' },
  { 'void glAttachShader(GLuint program, GLuint shader)' },
  { 'void glVertexArrayElementBuffer(GLuint vaobj, GLuint buffer)' },
  { 'void glValidateProgramPipeline(GLuint pipeline)' },
  { 'void glValidateProgram(GLuint program)' },
  { 'void glUseProgramStages(GLuint pipeline, GLbitfield stages, GLuint program)' },
  { 'void glUseProgram(GLuint program)' },
  { 'GLboolean glUnmapBuffer(GLenum target)', 'GLboolean glUnmapNamedBuffer(GLuint buffer)' },
  { 'void glUniformSubroutinesuiv(GLenum shadertype, GLsizei count, const GLuint *indices)' },
  {
    'void glUniformBlockBinding(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding)',
  },
  {
    'void glTexImage3DMultisample(\\n  GLenum target,\\n  GLsizei samples,\\n  GLenum internalformat,\\n  GLsizei width,\\n  GLsizei height,\\n  GLsizei depth,\\n  GLboolean fixedsamplelocations\\n)',
  },
  {
    'void glTexImage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations)',
  },
  {
    'void glTexImage1D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void * data)',
  },
  {
    'void glTexImage2D(\\n  GLenum target,\\n  GLint level,\\n  GLint internalformat,\\n  GLsizei width,\\n  GLsizei height,\\n  GLint border,\\n  GLenum format,\\n  GLenum type,\\n  const void * data\\n)',
  },
  {
    'void glTexImage3D(\\n  GLenum target,\\n  GLint level,\\n  GLint internalformat,\\n  GLsizei width,\\n  GLsizei height,\\n  GLsizei depth,\\n  GLint border,\\n  GLenum format,\\n  GLenum type,\\n  const void * data\\n)',
  },
  { 'void glDepthFunc(GLenum func)' },
  {
    'void glDepthRangef(GLfloat nearVal, GLfloat farVal)',
    'void glDepthRange(GLdouble nearVal, GLdouble farVal)',
  },
  { 'void glDepthMask(GLboolean flag)' },
  { 'void glDeleteVertexArrays(GLsizei n, const GLuint *arrays)' },
  {
    'void glSamplerParameterf(GLuint sampler, GLenum pname, GLfloat param)',
    'void glSamplerParameterfv(GLuint sampler, GLenum pname, const GLfloat * params)',
    'void glSamplerParameteri(GLuint sampler, GLenum pname, GLint param)',
    'void glSamplerParameterIiv(GLuint sampler, GLenum pname, const GLint *params)',
    'void glSamplerParameterIuiv(GLuint sampler, GLenum pname, const GLuint *params)',
    'void glSamplerParameteriv(GLuint sampler, GLenum pname, const GLint * params)',
  },
  { 'void glDeleteTransformFeedbacks(GLsizei n, const GLuint *ids)' },
  { 'void glDeleteSync(GLsync sync)' },
  { 'GLboolean glIsSampler(GLuint id)' },
  { 'void glDeleteSamplers(GLsizei n, const GLuint * samplers)' },
  { 'GLboolean glIsShader(GLuint shader)' },
  { 'void glSampleCoverage(GLfloat value, GLboolean invert)' },
  { 'GLboolean glIsSync(GLsync sync)' },
  {
    'void glNamedRenderbufferStorageMultisample(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)',
    'void glRenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)',
  },
  { 'GLboolean glIsTexture(GLuint texture)' },
  {
    'void glNamedRenderbufferStorage(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height)',
    'void glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)',
  },
  { 'GLboolean glIsTransformFeedback(GLuint id)' },
  { 'void glReleaseShaderCompiler()' },
  { 'GLboolean glIsVertexArray(GLuint array)' },
  {
    'void glReadnPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *data)',
    'void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void * data)',
  },
  { 'void glLineWidth(GLfloat width)' },
  {
    'void glNamedFramebufferReadBuffer(GLuint framebuffer, GLenum mode)',
    'void glReadBuffer(GLenum mode)',
  },
  { 'void glLinkProgram(GLuint program)' },
  { 'void glPushDebugGroup(GLenum source, GLuint id, GLsizei length, const char * message)' },
  { 'void glLogicOp(GLenum opcode)' },
  {
    'void glProgramUniform1f(GLuint program, GLint location, GLfloat v0)',
    'void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value)',
    'void glProgramUniform1i(GLuint program, GLint location, GLint v0)',
    'void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value)',
    'void glProgramUniform1ui(GLuint program, GLint location, GLuint v0)',
    'void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value)',
    'void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1)',
    'void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value)',
    'void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1)',
    'void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value)',
    'void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1)',
    'void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value)',
    'void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2)',
    'void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value)',
    'void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2)',
    'void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value)',
    'void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2)',
    'void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value)',
    'void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)',
    'void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value)',
    'void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3)',
    'void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value)',
    'void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3)',
    'void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value)',
    'void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)',
    'void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)',
    'void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)',
    'void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)',
    'void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)',
    'void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)',
    'void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)',
    'void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)',
    'void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)',
  },
  {
    'void *glMapBuffer(GLenum target, GLenum access)',
    'void *glMapNamedBuffer(GLuint buffer, GLenum access)',
  },
  {
    'void glGetCompressedTexImage(GLenum target, GLint level, void * pixels)',
    'void glGetCompressedTextureImage(GLuint texture, GLint level, GLsizei bufSize, void *pixels)',
    'void glGetnCompressedTexImage(GLenum target, GLint level, GLsizei bufSize, void *pixels)',
  },
  {
    'void *glMapBufferRange(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access)',
    'void *glMapNamedBufferRange(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access)',
  },
  {
    'void glShaderBinary(GLsizei count, const GLuint *shaders, GLenum binaryFormat, const void *binary, GLsizei length)',
  },
  {
    'void glMemoryBarrierByRegion(GLbitfield barriers)',
    'void glMemoryBarrier(GLbitfield barriers)',
  },
  {
    'GLuint glGetDebugMessageLog(\\n  GLuint count,\\n  GLsizei bufSize,\\n  GLenum *sources,\\n  GLenum *types,\\n  GLuint *ids,\\n  GLenum *severities,\\n  GLsizei *lengths,\\n  GLchar *messageLog\\n)',
  },
  { 'void glScissor(GLint x, GLint y, GLsizei width, GLsizei height)' },
  { 'void glMinSampleShading(GLfloat value)' },
  { 'GLint glGetFragDataIndex(GLuint program, const char * name)' },
  {
    'void glMultiDrawArrays(GLenum mode, const GLint * first, const GLsizei * count, GLsizei drawcount)',
  },
  { 'void glDepthRangeIndexed(GLuint index, GLdouble nearVal, GLdouble farVal)' },
  {
    'void glMultiDrawArraysIndirect(GLenum mode, const void *indirect, GLsizei drawcount, GLsizei stride)',
  },
  {
    'void glMultiDrawElements(GLenum mode, const GLsizei * count, GLenum type, const void * const * indices, GLsizei drawcount)',
  },
  { 'void glDispatchCompute(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z)' },
  {
    'void glMultiDrawElementsBaseVertex(\\n  GLenum mode,\\n  const GLsizei *count,\\n  GLenum type,\\n  const void * const *indices,\\n  GLsizei drawcount,\\n  const GLint *basevertex\\n)',
  },
  { 'void glDrawArrays(GLenum mode, GLint first, GLsizei count)' },
  {
    'void glMultiDrawElementsIndirect(GLenum mode, GLenum type, const void *indirect, GLsizei drawcount, GLsizei stride)',
  },
  { 'void glDeleteTextures(GLsizei n, const GLuint * textures)' },
  { 'void glObjectLabel(GLenum identifier, GLuint name, GLsizei length, const char * label)' },
  { 'void glDrawArraysInstanced(GLenum mode, GLint first, GLsizei count, GLsizei instancecount)' },
  { 'void glObjectPtrLabel(void * ptr, GLsizei length, const char * label)' },
  { 'void glDeleteRenderbuffers(GLsizei n, GLuint *renderbuffers)' },
  {
    'void glPatchParameterfv(GLenum pname, const GLfloat *values)',
    'void glPatchParameteri(GLenum pname, GLint value)',
  },
  {
    'void glDrawBuffer(GLenum buf)',
    'void glNamedFramebufferDrawBuffer(GLuint framebuffer, GLenum buf)',
  },
  {
    'void glDrawBuffers(GLsizei n, const GLenum *bufs)',
    'void glNamedFramebufferDrawBuffers(GLuint framebuffer, GLsizei n, const GLenum *bufs)',
  },
  { 'void glPauseTransformFeedback()' },
  { 'void glDrawElements(GLenum mode, GLsizei count, GLenum type, const void * indices)' },
  {
    'void glPixelStoref(GLenum pname, GLfloat param)',
    'void glPixelStorei(GLenum pname, GLint param)',
  },
  { 'void glDrawElementsIndirect(GLenum mode, GLenum type, const void *indirect)' },
  {
    'void glPointParameterf(GLenum pname, GLfloat param)',
    'void glPointParameterfv(GLenum pname, const GLfloat * params)',
    'void glPointParameteri(GLenum pname, GLint param)',
    'void glPointParameteriv(GLenum pname, const GLint * params)',
  },
  { 'void glDeleteShader(GLuint shader)' },
  { 'GLenum glGetError(void)' },
  {
    'void glGetCompressedTextureSubImage(\\n  GLuint texture,\\n  GLint level,\\n  GLint xoffset,\\n  GLint yoffset,\\n  GLint zoffset,\\n  GLsizei width,\\n  GLsizei height,\\n  GLsizei depth,\\n  GLsizei bufSize,\\n  void *pixels\\n)',
  },
  { 'void glPointSize(GLfloat size)' },
  { 'void glPolygonMode(GLenum face, GLenum mode)' },
  { 'void glGetUniformSubroutineuiv(GLenum shadertype, GLint location, GLuint *values)' },
  { 'void glPolygonOffset(GLfloat factor, GLfloat units)' },
  { 'GLuint glGetUniformBlockIndex(GLuint program, const GLchar *uniformBlockName)' },
  { 'void glPopDebugGroup()' },
  { 'void glGetVertexArrayiv(GLuint vaobj, GLenum pname, GLint *param)' },
  { 'void glPrimitiveRestartIndex(GLuint index)' },
  { 'GLint glGetUniformLocation(GLuint program, const GLchar *name)' },
  {
    'void glProgramBinary(GLuint program, GLenum binaryFormat, const void *binary, GLsizei length)',
  },
  {
    'void glGetVertexArrayIndexed64iv(GLuint vaobj, GLuint index, GLenum pname, GLint64 *param)',
    'void glGetVertexArrayIndexediv(GLuint vaobj, GLuint index, GLenum pname, GLint *param)',
  },
  { 'void glProgramParameteri(GLuint program, GLenum pname, GLint value)' },
  {
    'void glGetUniformIndices(GLuint program, GLsizei uniformCount, const GLchar **uniformNames, GLuint *uniformIndices)',
  },
  { 'GLint glGetFragDataLocation(GLuint program, const char * name)' },
  { 'void glGetNamedBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr size, void *data)' },
  {
    'void glDrawElementsInstanced(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount)',
  },
  {
    'void glDrawElementsBaseVertex(GLenum mode, GLsizei count, GLenum type, void *indices, GLint basevertex)',
  },
  {
    'void glDrawArraysInstancedBaseInstance(GLenum mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance)',
  },
  { 'void glDrawArraysIndirect(GLenum mode, const void *indirect)' },
  { 'void glDispatchComputeIndirect(GLintptr indirect)' },
  { 'void glDetachShader(GLuint program, GLuint shader)' },
  { 'void glDepthRangeArrayv(GLuint first, GLsizei count, const GLdouble *v)' },
  {
    'void glScissorIndexed(GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height)',
    'void glScissorIndexedv(GLuint index, const GLint *v)',
  },
  { 'void glProvokingVertex(GLenum provokeMode)' },
  { 'void glQueryCounter(GLuint id, GLenum target)' },
  { 'void glResumeTransformFeedback()' },
  { 'void glSampleMaski(GLuint maskNumber, GLbitfield mask)' },
  { 'void glScissorArrayv(GLuint first, GLsizei count, const GLint *v)' },
  {
    'void glShaderSource(GLuint shader, GLsizei count, const GLchar **string, const GLint *length)',
  },
  { 'void glStencilFunc(GLenum func, GLint ref, GLuint mask)' },
  {
    'void glShaderStorageBlockBinding(GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding)',
  },
  { 'void glStencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask)' },
  {
    'void glTexBufferRange(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size)',
    'void glTextureBufferRange(GLuint texture, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizei size)',
  },
  { 'void glStencilMask(GLuint mask)' },
  { 'void glStencilMaskSeparate(GLenum face, GLuint mask)' },
  { 'void glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass)' },
  { 'void glStencilOpSeparate(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass)' },
  {
    'void glTexBuffer(GLenum target, GLenum internalformat, GLuint buffer)',
    'void glTextureBuffer(GLuint texture, GLenum internalformat, GLuint buffer)',
  },
  { 'void glGetQueryiv(GLenum target, GLenum pname, GLint * params)' },
  {
    'void glGetNamedRenderbufferParameteriv(GLuint renderbuffer, GLenum pname, GLint *params)',
    'void glGetRenderbufferParameteriv(GLenum target, GLenum pname, GLint *params)',
  },
  {
    'void glGetSamplerParameterfv(GLuint sampler, GLenum pname, GLfloat * params)',
    'void glGetSamplerParameterIiv(GLuint sampler, GLenum pname, GLint * params)',
    'void glGetSamplerParameterIuiv(GLuint sampler, GLenum pname, GLuint * params)',
    'void glGetSamplerParameteriv(GLuint sampler, GLenum pname, GLint * params)',
  },
  { 'void glGetShaderiv(GLuint shader, GLenum pname, GLint *params)' },
  {
    'void glGetShaderInfoLog(GLuint shader, GLsizei maxLength, GLsizei *length, GLchar *infoLog)',
  },
}

local insert = {
  glMapBuffer = 'glMapBuffer(target, access)',
  glMapBufferRange = 'glMapBufferRange(target, offset, length, access)',
  glMapNamedBuffer = 'glMapNamedBuffer(buffer, access)',
  glMapNamedBufferRange = 'glMapNamedBufferRange(buffer, offset, length, access)',
  glGetString = 'glGetString(name)',
  glGetStringi = 'glGetStringi(name, index)',
  glActiveShaderProgram = 'glActiveShaderProgram(pipeline, program)',
  glActiveTexture = 'glActiveTexture(texture)',
  glAttachShader = 'glAttachShader(program, shader)',
  glBeginConditionalRender = 'glBeginConditionalRender(id, mode)',
  glBeginQuery = 'glBeginQuery(target, id)',
  glBeginQueryIndexed = 'glBeginQueryIndexed(target, index, id)',
  glBeginTransformFeedback = 'glBeginTransformFeedback(primitiveMode)',
  glBindAttribLocation = 'glBindAttribLocation(program, index, name)',
  glBindBuffer = 'glBindBuffer(target, buffer)',
  glBindBufferBase = 'glBindBufferBase(target, index, buffer)',
  glBindBufferRange = 'glBindBufferRange(target, index, buffer, offset, size)',
  glBindBuffersBase = 'glBindBuffersBase(target, first, count, buffers)',
  glBindBuffersRange = 'glBindBuffersRange(target, first, count, buffers, offsets, sizes)',
  glBindFragDataLocation = 'glBindFragDataLocation(program, colorNumber, name)',
  glBindFragDataLocationIndexed = 'glBindFragDataLocationIndexed(program, colorNumber, index, name)',
  glBindFramebuffer = 'glBindFramebuffer(target, framebuffer)',
  glBindImageTexture = 'glBindImageTexture(unit, texture, level, layered, layer, access, format)',
  glBindImageTextures = 'glBindImageTextures(first, count, textures)',
  glBindProgramPipeline = 'glBindProgramPipeline(pipeline)',
  glBindRenderbuffer = 'glBindRenderbuffer(target, renderbuffer)',
  glBindSampler = 'glBindSampler(unit, sampler)',
  glBindSamplers = 'glBindSamplers(first, count, samplers)',
  glBindTexture = 'glBindTexture(target, texture)',
  glBindTextureUnit = 'glBindTextureUnit(unit, texture)',
  glBindTextures = 'glBindTextures(first, count, textures)',
  glBindTransformFeedback = 'glBindTransformFeedback(target, id)',
  glBindVertexArray = 'glBindVertexArray(arr)',
  glBindVertexBuffer = 'glBindVertexBuffer(bindingindex, buffer, offset, stride)',
  glBindVertexBuffers = 'glBindVertexBuffers(first, count, buffers, offsets, strides)',
  glBlendColor = 'glBlendColor(red, green, blue, alpha)',
  glBlendEquation = 'glBlendEquation(mode)',
  glBlendEquationSeparate = 'glBlendEquationSeparate(modeRGB, modeAlpha)',
  glBlendEquationSeparatei = 'glBlendEquationSeparatei(buf, modeRGB, modeAlpha)',
  glBlendEquationi = 'glBlendEquationi(buf, mode)',
  glBlendFunc = 'glBlendFunc(sfactor, dfactor)',
  glBlendFuncSeparate = 'glBlendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha)',
  glBlendFuncSeparatei = 'glBlendFuncSeparatei(buf, srcRGB, dstRGB, srcAlpha, dstAlpha)',
  glBlendFunci = 'glBlendFunci(buf, sfactor, dfactor)',
  glBlitFramebuffer = 'glBlitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter)',
  glBlitNamedFramebuffer = 'glBlitNamedFramebuffer(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter)',
  glBufferData = 'glBufferData(target, size, data, usage)',
  glBufferStorage = 'glBufferStorage(target, size, data, flags)',
  glBufferSubData = 'glBufferSubData(target, offset, size, data)',
  glCheckFramebufferStatus = 'glCheckFramebufferStatus(target)',
  glCheckNamedFramebufferStatus = 'glCheckNamedFramebufferStatus(framebuffer, target)',
  glClampColor = 'glClampColor(target, clamp)',
  glClear = 'glClear(mask)',
  glClearBufferData = 'glClearBufferData(target, internalformat, format, type, data)',
  glClearBufferSubData = 'glClearBufferSubData(target, internalformat, offset, size, format, type, data)',
  glClearBufferfi = 'glClearBufferfi(buffer, drawbuffer, depth, stencil)',
  glClearBufferfv = 'glClearBufferfv(buffer, drawbuffer, value)',
  glClearBufferiv = 'glClearBufferiv(buffer, drawbuffer, value)',
  glClearBufferuiv = 'glClearBufferuiv(buffer, drawbuffer, value)',
  glClearColor = 'glClearColor(red, green, blue, alpha)',
  glClearDepth = 'glClearDepth(depth)',
  glClearDepthf = 'glClearDepthf(depth)',
  glClearNamedBufferData = 'glClearNamedBufferData(buffer, internalformat, format, type, data)',
  glClearNamedBufferSubData = 'glClearNamedBufferSubData(buffer, internalformat, offset, size, format, type, data)',
  glClearNamedFramebufferfi = 'glClearNamedFramebufferfi(framebuffer, buffer, drawbuffer, depth, stencil)',
  glClearNamedFramebufferfv = 'glClearNamedFramebufferfv(framebuffer, buffer, drawbuffer, value)',
  glClearNamedFramebufferiv = 'glClearNamedFramebufferiv(framebuffer, buffer, drawbuffer, value)',
  glClearNamedFramebufferuiv = 'glClearNamedFramebufferuiv(framebuffer, buffer, drawbuffer, value)',
  glClearStencil = 'glClearStencil(s)',
  glClearTexImage = 'glClearTexImage(texture, level, format, type, data)',
  glClearTexSubImage = 'glClearTexSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data)',
  glClientWaitSync = 'glClientWaitSync(sync, flags, timeout)',
  glClipControl = 'glClipControl(origin, depth)',
  glColorMask = 'glColorMask(red, green, blue, alpha)',
  glColorMaski = 'glColorMaski(buf, red, green, blue, alpha)',
  glCompileShader = 'glCompileShader(shader)',
  glCompressedTexImage1D = 'glCompressedTexImage1D(target, level, internalformat, width, border, imageSize, data)',
  glCompressedTexImage2D = 'glCompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data)',
  glCompressedTexImage3D = 'glCompressedTexImage3D(target, level, internalformat, width, height, depth, border, imageSize, data)',
  glCompressedTexSubImage1D = 'glCompressedTexSubImage1D(target, level, xoffset, width, format, imageSize, data)',
  glCompressedTexSubImage2D = 'glCompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data)',
  glCompressedTexSubImage3D = 'glCompressedTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data)',
  glCompressedTextureSubImage1D = 'glCompressedTextureSubImage1D(texture, level, xoffset, width, format, imageSize, data)',
  glCompressedTextureSubImage2D = 'glCompressedTextureSubImage2D(texture, level, xoffset, yoffset, width, height, format, imageSize, data)',
  glCompressedTextureSubImage3D = 'glCompressedTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data)',
  glCopyBufferSubData = 'glCopyBufferSubData(readTarget, writeTarget, readOffset, writeOffset, size)',
  glCopyImageSubData = 'glCopyImageSubData(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth)',
  glCopyNamedBufferSubData = 'glCopyNamedBufferSubData(readBuffer, writeBuffer, readOffset, writeOffset, size)',
  glCopyTexImage1D = 'glCopyTexImage1D(target, level, internalformat, x, y, width, border)',
  glCopyTexImage2D = 'glCopyTexImage2D(target, level, internalformat, x, y, width, height, border)',
  glCopyTexSubImage1D = 'glCopyTexSubImage1D(target, level, xoffset, x, y, width)',
  glCopyTexSubImage2D = 'glCopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height)',
  glCopyTexSubImage3D = 'glCopyTexSubImage3D(target, level, xoffset, yoffset, zoffset, x, y, width, height)',
  glCopyTextureSubImage1D = 'glCopyTextureSubImage1D(texture, level, xoffset, x, y, width)',
  glCopyTextureSubImage2D = 'glCopyTextureSubImage2D(texture, level, xoffset, yoffset, x, y, width, height)',
  glCopyTextureSubImage3D = 'glCopyTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, x, y, width, height)',
  glCreateBuffers = 'glCreateBuffers(n, buffers)',
  glCreateFramebuffers = 'glCreateFramebuffers(n, framebuffers)',
  glCreateProgram = 'glCreateProgram()',
  glCreateProgramPipelines = 'glCreateProgramPipelines(n, pipelines)',
  glCreateQueries = 'glCreateQueries(target, n, ids)',
  glCreateRenderbuffers = 'glCreateRenderbuffers(n, renderbuffers)',
  glCreateSamplers = 'glCreateSamplers(n, samplers)',
  glCreateShader = 'glCreateShader(shaderType)',
  glCreateShaderProgramv = 'glCreateShaderProgramv(type, count, strings)',
  glCreateTextures = 'glCreateTextures(target, n, textures)',
  glCreateTransformFeedbacks = 'glCreateTransformFeedbacks(n, ids)',
  glCreateVertexArrays = 'glCreateVertexArrays(n, arrs)',
  glCullFace = 'glCullFace(mode)',
  glDebugMessageCallback = 'glDebugMessageCallback(callback, userParam)',
  glDebugMessageControl = 'glDebugMessageControl(source, type, severity, count, ids, enabled)',
  glDebugMessageInsert = 'glDebugMessageInsert(source, type, id, severity, length, message)',
  glDeleteBuffers = 'glDeleteBuffers(n, buffers)',
  glDeleteFramebuffers = 'glDeleteFramebuffers(n, framebuffers)',
  glDeleteProgram = 'glDeleteProgram(program)',
  glDeleteProgramPipelines = 'glDeleteProgramPipelines(n, pipelines)',
  glDeleteQueries = 'glDeleteQueries(n, ids)',
  glDeleteRenderbuffers = 'glDeleteRenderbuffers(n, renderbuffers)',
  glDeleteSamplers = 'glDeleteSamplers(n, samplers)',
  glDeleteShader = 'glDeleteShader(shader)',
  glDeleteSync = 'glDeleteSync(sync)',
  glDeleteTextures = 'glDeleteTextures(n, textures)',
  glDeleteTransformFeedbacks = 'glDeleteTransformFeedbacks(n, ids)',
  glDeleteVertexArrays = 'glDeleteVertexArrays(n, arrs)',
  glDepthFunc = 'glDepthFunc(func)',
  glDepthMask = 'glDepthMask(flag)',
  glDepthRange = 'glDepthRange(nearVal, farVal)',
  glDepthRangeArrayv = 'glDepthRangeArrayv(first, count, v)',
  glDepthRangeIndexed = 'glDepthRangeIndexed(index, nearVal, farVal)',
  glDepthRangef = 'glDepthRangef(nearVal, farVal)',
  glDetachShader = 'glDetachShader(program, shader)',
  glDisable = 'glDisable(cap)',
  glDisableVertexArrayAttrib = 'glDisableVertexArrayAttrib(vaobj, index)',
  glDisableVertexAttribArray = 'glDisableVertexAttribArray(index)',
  glDisablei = 'glDisablei(cap, index)',
  glDispatchCompute = 'glDispatchCompute(num_groups_x, num_groups_y, num_groups_z)',
  glDispatchComputeIndirect = 'glDispatchComputeIndirect(indirect)',
  glDrawArrays = 'glDrawArrays(mode, first, count)',
  glDrawArraysIndirect = 'glDrawArraysIndirect(mode, indirect)',
  glDrawArraysInstanced = 'glDrawArraysInstanced(mode, first, count, instancecount)',
  glDrawArraysInstancedBaseInstance = 'glDrawArraysInstancedBaseInstance(mode, first, count, instancecount, baseinstance)',
  glDrawBuffer = 'glDrawBuffer(buf)',
  glDrawBuffers = 'glDrawBuffers(n, bufs)',
  glDrawElements = 'glDrawElements(mode, count, type, indices)',
  glDrawElementsBaseVertex = 'glDrawElementsBaseVertex(mode, count, type, indices, basevertex)',
  glDrawElementsIndirect = 'glDrawElementsIndirect(mode, type, indirect)',
  glDrawElementsInstanced = 'glDrawElementsInstanced(mode, count, type, indices, instancecount)',
  glDrawElementsInstancedBaseInstance = 'glDrawElementsInstancedBaseInstance(mode, count, type, indices, instancecount, baseinstance)',
  glDrawElementsInstancedBaseVertex = 'glDrawElementsInstancedBaseVertex(mode, count, type, indices, instancecount, basevertex)',
  glDrawElementsInstancedBaseVertexBaseInstance = 'glDrawElementsInstancedBaseVertexBaseInstance(mode, count, type, indices, instancecount, basevertex, baseinstance )',
  glDrawRangeElements = 'glDrawRangeElements(mode, start, end, count, type, indices)',
  glDrawRangeElementsBaseVertex = 'glDrawRangeElementsBaseVertex(mode, start, end, count, type, indices, basevertex)',
  glDrawTransformFeedback = 'glDrawTransformFeedback(mode, id)',
  glDrawTransformFeedbackInstanced = 'glDrawTransformFeedbackInstanced(mode, id, instancecount)',
  glDrawTransformFeedbackStream = 'glDrawTransformFeedbackStream(mode, id, stream)',
  glDrawTransformFeedbackStreamInstanced = 'glDrawTransformFeedbackStreamInstanced(mode, id, stream, instancecount)',
  glEnable = 'glEnable(cap)',
  glEnableVertexArrayAttrib = 'glEnableVertexArrayAttrib(vaobj, index)',
  glEnableVertexAttribArray = 'glEnableVertexAttribArray(index)',
  glEnablei = 'glEnablei(cap, index)',
  glEndConditionalRender = 'glEndConditionalRender()',
  glEndQuery = 'glEndQuery(target)',
  glEndQueryIndexed = 'glEndQueryIndexed(target, index)',
  glEndTransformFeedback = 'glEndTransformFeedback()',
  glFenceSync = 'glFenceSync(condition, flags)',
  glFinish = 'glFinish()',
  glFlush = 'glFlush()',
  glFlushMappedBufferRange = 'glFlushMappedBufferRange(target, offset, length)',
  glFlushMappedNamedBufferRange = 'glFlushMappedNamedBufferRange(buffer, offset, length)',
  glFramebufferParameteri = 'glFramebufferParameteri(target, pname, param)',
  glFramebufferRenderbuffer = 'glFramebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer)',
  glFramebufferTexture = 'glFramebufferTexture(target, attachment, texture, level)',
  glFramebufferTexture1D = 'glFramebufferTexture1D(target, attachment, textarget, texture, level)',
  glFramebufferTexture2D = 'glFramebufferTexture2D(target, attachment, textarget, texture, level)',
  glFramebufferTexture3D = 'glFramebufferTexture3D(target, attachment, textarget, texture, level, layer)',
  glFramebufferTextureLayer = 'glFramebufferTextureLayer(target, attachment, texture, level, layer)',
  glFrontFace = 'glFrontFace(mode)',
  glGenBuffers = 'glGenBuffers(n, buffers)',
  glGenFramebuffers = 'glGenFramebuffers(n, ids)',
  glGenProgramPipelines = 'glGenProgramPipelines(n, pipelines)',
  glGenQueries = 'glGenQueries(n, ids)',
  glGenRenderbuffers = 'glGenRenderbuffers(n, renderbuffers)',
  glGenSamplers = 'glGenSamplers(n, samplers)',
  glGenTextures = 'glGenTextures(n, textures)',
  glGenTransformFeedbacks = 'glGenTransformFeedbacks(n, ids)',
  glGenVertexArrays = 'glGenVertexArrays(n, arrs)',
  glGenerateMipmap = 'glGenerateMipmap(target)',
  glGenerateTextureMipmap = 'glGenerateTextureMipmap(texture)',
  glGetActiveAtomicCounterBufferiv = 'glGetActiveAtomicCounterBufferiv(program, bufferIndex, pname, params)',
  glGetActiveAttrib = 'glGetActiveAttrib(program, index, bufSize, length, size, type, name)',
  glGetActiveSubroutineName = 'glGetActiveSubroutineName(program, shadertype, index, bufSize, length, name)',
  glGetActiveSubroutineUniformName = 'glGetActiveSubroutineUniformName(program, shadertype, index, bufSize, length, name)',
  glGetActiveSubroutineUniformiv = 'glGetActiveSubroutineUniformiv(program, shadertype, index, pname, values)',
  glGetActiveUniform = 'glGetActiveUniform(program, index, bufSize, length, size, type, name)',
  glGetActiveUniformBlockName = 'glGetActiveUniformBlockName(program, uniformBlockIndex, bufSize, length, uniformBlockName)',
  glGetActiveUniformBlockiv = 'glGetActiveUniformBlockiv(program, uniformBlockIndex, pname, params)',
  glGetActiveUniformName = 'glGetActiveUniformName(program, uniformIndex, bufSize, length, uniformName)',
  glGetActiveUniformsiv = 'glGetActiveUniformsiv(program, uniformCount, uniformIndices, pname, params)',
  glGetAttachedShaders = 'glGetAttachedShaders(program, maxCount, count, shaders)',
  glGetAttribLocation = 'glGetAttribLocation(program, name)',
  glGetBooleani_v = 'glGetBooleani_v(target, index, data)',
  glGetBooleanv = 'glGetBooleanv(pname, data)',
  glGetBufferParameteri64v = 'glGetBufferParameteri64v(target, value, data)',
  glGetBufferParameteriv = 'glGetBufferParameteriv(target, value, data)',
  glGetBufferPointerv = 'glGetBufferPointerv(target, pname, params)',
  glGetBufferSubData = 'glGetBufferSubData(target, offset, size, data)',
  glGetCompressedTexImage = 'glGetCompressedTexImage(target, level, pixels)',
  glGetCompressedTextureImage = 'glGetCompressedTextureImage(texture, level, bufSize, pixels)',
  glGetCompressedTextureSubImage = 'glGetCompressedTextureSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels)',
  glGetDebugMessageLog = 'glGetDebugMessageLog(count, bufSize, sources, types, ids, severities, lengths, messageLog)',
  glGetDoublei_v = 'glGetDoublei_v(target, index, data)',
  glGetDoublev = 'glGetDoublev(pname, data)',
  glGetError = 'glGetError()',
  glGetFloati_v = 'glGetFloati_v(target, index, data)',
  glGetFloatv = 'glGetFloatv(pname, data)',
  glGetFragDataIndex = 'glGetFragDataIndex(program, name)',
  glGetFragDataLocation = 'glGetFragDataLocation(program, name)',
  glGetFramebufferAttachmentParameteriv = 'glGetFramebufferAttachmentParameteriv(target, attachment, pname, params)',
  glGetFramebufferParameteriv = 'glGetFramebufferParameteriv(target, pname, params)',
  glGetGraphicsResetStatus = 'glGetGraphicsResetStatus()',
  glGetInteger64i_v = 'glGetInteger64i_v(target, index, data)',
  glGetInteger64v = 'glGetInteger64v(pname, data)',
  glGetIntegeri_v = 'glGetIntegeri_v(target, index, data)',
  glGetIntegerv = 'glGetIntegerv(pname, data)',
  glGetInternalformati64v = 'glGetInternalformati64v(target, internalformat, pname, bufSize, params)',
  glGetInternalformativ = 'glGetInternalformativ(target, internalformat, pname, bufSize, params)',
  glGetMultisamplefv = 'glGetMultisamplefv(pname, index, val)',
  glGetNamedBufferParameteri64v = 'glGetNamedBufferParameteri64v(buffer, pname, params)',
  glGetNamedBufferParameteriv = 'glGetNamedBufferParameteriv(buffer, pname, params)',
  glGetNamedBufferPointerv = 'glGetNamedBufferPointerv(buffer, pname, params)',
  glGetNamedBufferSubData = 'glGetNamedBufferSubData(buffer, offset, size, data)',
  glGetNamedFramebufferAttachmentParameteriv = 'glGetNamedFramebufferAttachmentParameteriv(framebuffer, attachment, pname, params)',
  glGetNamedFramebufferParameteriv = 'glGetNamedFramebufferParameteriv(framebuffer, pname, param)',
  glGetNamedRenderbufferParameteriv = 'glGetNamedRenderbufferParameteriv(renderbuffer, pname, params)',
  glGetObjectLabel = 'glGetObjectLabel(identifier, name, bufSize, length, label)',
  glGetObjectPtrLabel = 'glGetObjectPtrLabel(ptr, bufSize, length, label)',
  glGetPointerv = 'glGetPointerv(pname, params)',
  glGetProgramBinary = 'glGetProgramBinary(program, bufSize, length, binaryFormat, binary)',
  glGetProgramInfoLog = 'glGetProgramInfoLog(program, maxLength, length, infoLog)',
  glGetProgramInterfaceiv = 'glGetProgramInterfaceiv(program, programInterface, pname, params)',
  glGetProgramPipelineInfoLog = 'glGetProgramPipelineInfoLog(pipeline, bufSize, length, infoLog)',
  glGetProgramPipelineiv = 'glGetProgramPipelineiv(pipeline, pname, params)',
  glGetProgramResourceIndex = 'glGetProgramResourceIndex(program, programInterface, name)',
  glGetProgramResourceLocation = 'glGetProgramResourceLocation(program, programInterface, name)',
  glGetProgramResourceLocationIndex = 'glGetProgramResourceLocationIndex(program, programInterface, name)',
  glGetProgramResourceName = 'glGetProgramResourceName(program, programInterface, index, bufSize, length, name)',
  glGetProgramResourceiv = 'glGetProgramResourceiv(program, programInterface, index, propCount, props, bufSize, length, params)',
  glGetProgramStageiv = 'glGetProgramStageiv(program, shadertype, pname, values)',
  glGetProgramiv = 'glGetProgramiv(program, pname, params)',
  glGetQueryBufferObjecti64v = 'glGetQueryBufferObjecti64v(id, buffer, pname, offset)',
  glGetQueryBufferObjectiv = 'glGetQueryBufferObjectiv(id, buffer, pname, offset)',
  glGetQueryBufferObjectui64v = 'glGetQueryBufferObjectui64v(id, buffer, pname, offset)',
  glGetQueryBufferObjectuiv = 'glGetQueryBufferObjectuiv(id, buffer, pname, offset)',
  glGetQueryIndexediv = 'glGetQueryIndexediv(target, index, pname, params)',
  glGetQueryObjecti64v = 'glGetQueryObjecti64v(id, pname, params)',
  glGetQueryObjectiv = 'glGetQueryObjectiv(id, pname, params)',
  glGetQueryObjectui64v = 'glGetQueryObjectui64v(id, pname, params)',
  glGetQueryObjectuiv = 'glGetQueryObjectuiv(id, pname, params)',
  glGetQueryiv = 'glGetQueryiv(target, pname, params)',
  glGetRenderbufferParameteriv = 'glGetRenderbufferParameteriv(target, pname, params)',
  glGetSamplerParameterIiv = 'glGetSamplerParameterIiv(sampler, pname, params)',
  glGetSamplerParameterIuiv = 'glGetSamplerParameterIuiv(sampler, pname, params)',
  glGetSamplerParameterfv = 'glGetSamplerParameterfv(sampler, pname, params)',
  glGetSamplerParameteriv = 'glGetSamplerParameteriv(sampler, pname, params)',
  glGetShaderInfoLog = 'glGetShaderInfoLog(shader, maxLength, length, infoLog)',
  glGetShaderPrecisionFormat = 'glGetShaderPrecisionFormat(shaderType, precisionType, range, precision)',
  glGetShaderSource = 'glGetShaderSource(shader, bufSize, length, source)',
  glGetShaderiv = 'glGetShaderiv(shader, pname, params)',
  glGetSubroutineIndex = 'glGetSubroutineIndex(program, shadertype, name)',
  glGetSubroutineUniformLocation = 'glGetSubroutineUniformLocation(program, shadertype, name)',
  glGetSynciv = 'glGetSynciv(sync, pname, bufSize, length, values)',
  glGetTexImage = 'glGetTexImage(target, level, format, type, pixels)',
  glGetTexLevelParameterfv = 'glGetTexLevelParameterfv(target, level, pname, params)',
  glGetTexLevelParameteriv = 'glGetTexLevelParameteriv(target, level, pname, params)',
  glGetTexParameterIiv = 'glGetTexParameterIiv(target, pname, params)',
  glGetTexParameterIuiv = 'glGetTexParameterIuiv(target, pname, params)',
  glGetTexParameterfv = 'glGetTexParameterfv(target, pname, params)',
  glGetTexParameteriv = 'glGetTexParameteriv(target, pname, params)',
  glGetTextureImage = 'glGetTextureImage(texture, level, format, type, bufSize, pixels)',
  glGetTextureLevelParameterfv = 'glGetTextureLevelParameterfv(texture, level, pname, params)',
  glGetTextureLevelParameteriv = 'glGetTextureLevelParameteriv(texture, level, pname, params)',
  glGetTextureParameterIiv = 'glGetTextureParameterIiv(texture, pname, params)',
  glGetTextureParameterIuiv = 'glGetTextureParameterIuiv(texture, pname, params)',
  glGetTextureParameterfv = 'glGetTextureParameterfv(texture, pname, params)',
  glGetTextureParameteriv = 'glGetTextureParameteriv(texture, pname, params)',
  glGetTextureSubImage = 'glGetTextureSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, bufSize, pixels)',
  glGetTransformFeedbackVarying = 'glGetTransformFeedbackVarying(program, index, bufSize, length, size, type, name)',
  glGetTransformFeedbacki64_v = 'glGetTransformFeedbacki64_v(xfb, pname, index, param)',
  glGetTransformFeedbacki_v = 'glGetTransformFeedbacki_v(xfb, pname, index, param)',
  glGetTransformFeedbackiv = 'glGetTransformFeedbackiv(xfb, pname, param)',
  glGetUniformBlockIndex = 'glGetUniformBlockIndex(program, uniformBlockName)',
  glGetUniformIndices = 'glGetUniformIndices(program, uniformCount, uniformNames, uniformIndices)',
  glGetUniformLocation = 'glGetUniformLocation(program, name)',
  glGetUniformSubroutineuiv = 'glGetUniformSubroutineuiv(shadertype, location, values)',
  glGetUniformdv = 'glGetUniformdv(program, location, params)',
  glGetUniformfv = 'glGetUniformfv(program, location, params)',
  glGetUniformiv = 'glGetUniformiv(program, location, params)',
  glGetUniformuiv = 'glGetUniformuiv(program, location, params)',
  glGetVertexArrayIndexed64iv = 'glGetVertexArrayIndexed64iv(vaobj, index, pname, param)',
  glGetVertexArrayIndexediv = 'glGetVertexArrayIndexediv(vaobj, index, pname, param)',
  glGetVertexArrayiv = 'glGetVertexArrayiv(vaobj, pname, param)',
  glGetVertexAttribIiv = 'glGetVertexAttribIiv(index, pname, params)',
  glGetVertexAttribIuiv = 'glGetVertexAttribIuiv(index, pname, params)',
  glGetVertexAttribLdv = 'glGetVertexAttribLdv(index, pname, params)',
  glGetVertexAttribPointerv = 'glGetVertexAttribPointerv(index, pname, pointer)',
  glGetVertexAttribdv = 'glGetVertexAttribdv(index, pname, params)',
  glGetVertexAttribfv = 'glGetVertexAttribfv(index, pname, params)',
  glGetVertexAttribiv = 'glGetVertexAttribiv(index, pname, params)',
  glGetnCompressedTexImage = 'glGetnCompressedTexImage(target, level, bufSize, pixels)',
  glGetnTexImage = 'glGetnTexImage(target, level, format, type, bufSize, pixels)',
  glGetnUniformdv = 'glGetnUniformdv(program, location, bufSize, params)',
  glGetnUniformfv = 'glGetnUniformfv(program, location, bufSize, params)',
  glGetnUniformiv = 'glGetnUniformiv(program, location, bufSize, params)',
  glGetnUniformuiv = 'glGetnUniformuiv(program, location, bufSize, params)',
  glHint = 'glHint(target, mode)',
  glInvalidateBufferData = 'glInvalidateBufferData(buffer)',
  glInvalidateBufferSubData = 'glInvalidateBufferSubData(buffer, offset, length)',
  glInvalidateFramebuffer = 'glInvalidateFramebuffer(target, numAttachments, attachments)',
  glInvalidateNamedFramebufferData = 'glInvalidateNamedFramebufferData(framebuffer, numAttachments, attachments)',
  glInvalidateNamedFramebufferSubData = 'glInvalidateNamedFramebufferSubData(framebuffer, numAttachments, attachments, x, y, width, height)',
  glInvalidateSubFramebuffer = 'glInvalidateSubFramebuffer(target, numAttachments, attachments, x, y, width, height)',
  glInvalidateTexImage = 'glInvalidateTexImage(texture, level)',
  glInvalidateTexSubImage = 'glInvalidateTexSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth)',
  glIsBuffer = 'glIsBuffer(buffer)',
  glIsEnabled = 'glIsEnabled(cap)',
  glIsEnabledi = 'glIsEnabledi(cap, index)',
  glIsFramebuffer = 'glIsFramebuffer(framebuffer)',
  glIsProgram = 'glIsProgram(program)',
  glIsProgramPipeline = 'glIsProgramPipeline(pipeline)',
  glIsQuery = 'glIsQuery(id)',
  glIsRenderbuffer = 'glIsRenderbuffer(renderbuffer)',
  glIsSampler = 'glIsSampler(id)',
  glIsShader = 'glIsShader(shader)',
  glIsSync = 'glIsSync(sync)',
  glIsTexture = 'glIsTexture(texture)',
  glIsTransformFeedback = 'glIsTransformFeedback(id)',
  glIsVertexArray = 'glIsVertexArray(arr)',
  glLineWidth = 'glLineWidth(width)',
  glLinkProgram = 'glLinkProgram(program)',
  glLogicOp = 'glLogicOp(opcode)',
  glMemoryBarrier = 'glMemoryBarrier(barriers)',
  glMemoryBarrierByRegion = 'glMemoryBarrierByRegion(barriers)',
  glMinSampleShading = 'glMinSampleShading(value)',
  glMultiDrawArrays = 'glMultiDrawArrays(mode, first, count, drawcount)',
  glMultiDrawArraysIndirect = 'glMultiDrawArraysIndirect(mode, indirect, drawcount, stride)',
  glMultiDrawElements = 'glMultiDrawElements(mode, count, type, indices, drawcount)',
  glMultiDrawElementsBaseVertex = 'glMultiDrawElementsBaseVertex(mode, count, type, indices, drawcount, basevertex)',
  glMultiDrawElementsIndirect = 'glMultiDrawElementsIndirect(mode, type, indirect, drawcount, stride)',
  glNamedBufferData = 'glNamedBufferData(buffer, size, data, usage)',
  glNamedBufferStorage = 'glNamedBufferStorage(buffer, size, data, flags)',
  glNamedBufferSubData = 'glNamedBufferSubData(buffer, offset, size, data)',
  glNamedFramebufferDrawBuffer = 'glNamedFramebufferDrawBuffer(framebuffer, buf)',
  glNamedFramebufferDrawBuffers = 'glNamedFramebufferDrawBuffers(framebuffer, n, bufs)',
  glNamedFramebufferParameteri = 'glNamedFramebufferParameteri(framebuffer, pname, param)',
  glNamedFramebufferReadBuffer = 'glNamedFramebufferReadBuffer(framebuffer, mode)',
  glNamedFramebufferRenderbuffer = 'glNamedFramebufferRenderbuffer(framebuffer, attachment, renderbuffertarget, renderbuffer)',
  glNamedFramebufferTexture = 'glNamedFramebufferTexture(framebuffer, attachment, texture, level)',
  glNamedFramebufferTextureLayer = 'glNamedFramebufferTextureLayer(framebuffer, attachment, texture, level, layer)',
  glNamedRenderbufferStorage = 'glNamedRenderbufferStorage(renderbuffer, internalformat, width, height)',
  glNamedRenderbufferStorageMultisample = 'glNamedRenderbufferStorageMultisample(renderbuffer, samples, internalformat, width, height)',
  glObjectLabel = 'glObjectLabel(identifier, name, length, label)',
  glObjectPtrLabel = 'glObjectPtrLabel(ptr, length, label)',
  glPatchParameterfv = 'glPatchParameterfv(pname, values)',
  glPatchParameteri = 'glPatchParameteri(pname, value)',
  glPauseTransformFeedback = 'glPauseTransformFeedback()',
  glPixelStoref = 'glPixelStoref(pname, param)',
  glPixelStorei = 'glPixelStorei(pname, param)',
  glPointParameterf = 'glPointParameterf(pname, param)',
  glPointParameterfv = 'glPointParameterfv(pname, params)',
  glPointParameteri = 'glPointParameteri(pname, param)',
  glPointParameteriv = 'glPointParameteriv(pname, params)',
  glPointSize = 'glPointSize(size)',
  glPolygonMode = 'glPolygonMode(face, mode)',
  glPolygonOffset = 'glPolygonOffset(factor, units)',
  glPopDebugGroup = 'glPopDebugGroup()',
  glPrimitiveRestartIndex = 'glPrimitiveRestartIndex(index)',
  glProgramBinary = 'glProgramBinary(program, binaryFormat, binary, length)',
  glProgramParameteri = 'glProgramParameteri(program, pname, value)',
  glProgramUniform1f = 'glProgramUniform1f(program, location, v0)',
  glProgramUniform1fv = 'glProgramUniform1fv(program, location, count, value)',
  glProgramUniform1i = 'glProgramUniform1i(program, location, v0)',
  glProgramUniform1iv = 'glProgramUniform1iv(program, location, count, value)',
  glProgramUniform1ui = 'glProgramUniform1ui(program, location, v0)',
  glProgramUniform1uiv = 'glProgramUniform1uiv(program, location, count, value)',
  glProgramUniform2f = 'glProgramUniform2f(program, location, v0, v1)',
  glProgramUniform2fv = 'glProgramUniform2fv(program, location, count, value)',
  glProgramUniform2i = 'glProgramUniform2i(program, location, v0, v1)',
  glProgramUniform2iv = 'glProgramUniform2iv(program, location, count, value)',
  glProgramUniform2ui = 'glProgramUniform2ui(program, location, v0, v1)',
  glProgramUniform2uiv = 'glProgramUniform2uiv(program, location, count, value)',
  glProgramUniform3f = 'glProgramUniform3f(program, location, v0, v1, v2)',
  glProgramUniform3fv = 'glProgramUniform3fv(program, location, count, value)',
  glProgramUniform3i = 'glProgramUniform3i(program, location, v0, v1, v2)',
  glProgramUniform3iv = 'glProgramUniform3iv(program, location, count, value)',
  glProgramUniform3ui = 'glProgramUniform3ui(program, location, v0, v1, v2)',
  glProgramUniform3uiv = 'glProgramUniform3uiv(program, location, count, value)',
  glProgramUniform4f = 'glProgramUniform4f(program, location, v0, v1, v2, v3)',
  glProgramUniform4fv = 'glProgramUniform4fv(program, location, count, value)',
  glProgramUniform4i = 'glProgramUniform4i(program, location, v0, v1, v2, v3)',
  glProgramUniform4iv = 'glProgramUniform4iv(program, location, count, value)',
  glProgramUniform4ui = 'glProgramUniform4ui(program, location, v0, v1, v2, v3)',
  glProgramUniform4uiv = 'glProgramUniform4uiv(program, location, count, value)',
  glProgramUniformMatrix2fv = 'glProgramUniformMatrix2fv(program, location, count, transpose, value)',
  glProgramUniformMatrix2x3fv = 'glProgramUniformMatrix2x3fv(program, location, count, transpose, value)',
  glProgramUniformMatrix2x4fv = 'glProgramUniformMatrix2x4fv(program, location, count, transpose, value)',
  glProgramUniformMatrix3fv = 'glProgramUniformMatrix3fv(program, location, count, transpose, value)',
  glProgramUniformMatrix3x2fv = 'glProgramUniformMatrix3x2fv(program, location, count, transpose, value)',
  glProgramUniformMatrix3x4fv = 'glProgramUniformMatrix3x4fv(program, location, count, transpose, value)',
  glProgramUniformMatrix4fv = 'glProgramUniformMatrix4fv(program, location, count, transpose, value)',
  glProgramUniformMatrix4x2fv = 'glProgramUniformMatrix4x2fv(program, location, count, transpose, value)',
  glProgramUniformMatrix4x3fv = 'glProgramUniformMatrix4x3fv(program, location, count, transpose, value)',
  glProvokingVertex = 'glProvokingVertex(provokeMode)',
  glPushDebugGroup = 'glPushDebugGroup(source, id, length, message)',
  glQueryCounter = 'glQueryCounter(id, target)',
  glReadBuffer = 'glReadBuffer(mode)',
  glReadPixels = 'glReadPixels(x, y, width, height, format, type, data)',
  glReadnPixels = 'glReadnPixels(x, y, width, height, format, type, bufSize, data)',
  glReleaseShaderCompiler = 'glReleaseShaderCompiler()',
  glRenderbufferStorage = 'glRenderbufferStorage(target, internalformat, width, height)',
  glRenderbufferStorageMultisample = 'glRenderbufferStorageMultisample(target, samples, internalformat, width, height)',
  glResumeTransformFeedback = 'glResumeTransformFeedback()',
  glSampleCoverage = 'glSampleCoverage(value, invert)',
  glSampleMaski = 'glSampleMaski(maskNumber, mask)',
  glSamplerParameterIiv = 'glSamplerParameterIiv(sampler, pname, params)',
  glSamplerParameterIuiv = 'glSamplerParameterIuiv(sampler, pname, params)',
  glSamplerParameterf = 'glSamplerParameterf(sampler, pname, param)',
  glSamplerParameterfv = 'glSamplerParameterfv(sampler, pname, params)',
  glSamplerParameteri = 'glSamplerParameteri(sampler, pname, param)',
  glSamplerParameteriv = 'glSamplerParameteriv(sampler, pname, params)',
  glScissor = 'glScissor(x, y, width, height)',
  glScissorArrayv = 'glScissorArrayv(first, count, v)',
  glScissorIndexed = 'glScissorIndexed(index, left, bottom, width, height)',
  glScissorIndexedv = 'glScissorIndexedv(index, v)',
  glShaderBinary = 'glShaderBinary(count, shaders, binaryFormat, binary, length)',
  glShaderSource = 'glShaderSource(shader, count, string, length)',
  glShaderStorageBlockBinding = 'glShaderStorageBlockBinding(program, storageBlockIndex, storageBlockBinding)',
  glStencilFunc = 'glStencilFunc(func, ref, mask)',
  glStencilFuncSeparate = 'glStencilFuncSeparate(face, func, ref, mask)',
  glStencilMask = 'glStencilMask(mask)',
  glStencilMaskSeparate = 'glStencilMaskSeparate(face, mask)',
  glStencilOp = 'glStencilOp(sfail, dpfail, dppass)',
  glStencilOpSeparate = 'glStencilOpSeparate(face, sfail, dpfail, dppass)',
  glTexBuffer = 'glTexBuffer(target, internalformat, buffer)',
  glTexBufferRange = 'glTexBufferRange(target, internalformat, buffer, offset, size)',
  glTexImage1D = 'glTexImage1D(target, level, internalformat, width, border, format, type, data)',
  glTexImage2D = 'glTexImage2D(target, level, internalformat, width, height, border, format, type, data)',
  glTexImage2DMultisample = 'glTexImage2DMultisample(target, samples, internalformat, width, height, fixedsamplelocations)',
  glTexImage3D = 'glTexImage3D(target, level, internalformat, width, height, depth, border, format, type, data)',
  glTexImage3DMultisample = 'glTexImage3DMultisample(target, samples, internalformat, width, height, depth, fixedsamplelocations)',
  glTexParameterIiv = 'glTexParameterIiv(target, pname, params)',
  glTexParameterIuiv = 'glTexParameterIuiv(target, pname, params)',
  glTexParameterf = 'glTexParameterf(target, pname, param)',
  glTexParameterfv = 'glTexParameterfv(target, pname, params)',
  glTexParameteri = 'glTexParameteri(target, pname, param)',
  glTexParameteriv = 'glTexParameteriv(target, pname, params)',
  glTexStorage1D = 'glTexStorage1D(target, levels, internalformat, width)',
  glTexStorage2D = 'glTexStorage2D(target, levels, internalformat, width, height)',
  glTexStorage2DMultisample = 'glTexStorage2DMultisample(target, samples, internalformat, width, height, fixedsamplelocations)',
  glTexStorage3D = 'glTexStorage3D(target, levels, internalformat, width, height, depth)',
  glTexStorage3DMultisample = 'glTexStorage3DMultisample(target, samples, internalformat, width, height, depth, fixedsamplelocations)',
  glTexSubImage1D = 'glTexSubImage1D(target, level, xoffset, width, format, type, pixels)',
  glTexSubImage2D = 'glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels)',
  glTexSubImage3D = 'glTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels)',
  glTextureBarrier = 'glTextureBarrier()',
  glTextureBuffer = 'glTextureBuffer(texture, internalformat, buffer)',
  glTextureBufferRange = 'glTextureBufferRange(texture, internalformat, buffer, offset, size)',
  glTextureParameterIiv = 'glTextureParameterIiv(texture, pname, params)',
  glTextureParameterIuiv = 'glTextureParameterIuiv(texture, pname, params)',
  glTextureParameterf = 'glTextureParameterf(texture, pname, param)',
  glTextureParameterfv = 'glTextureParameterfv(texture, pname, params)',
  glTextureParameteri = 'glTextureParameteri(texture, pname, param)',
  glTextureParameteriv = 'glTextureParameteriv(texture, pname, params)',
  glTextureStorage1D = 'glTextureStorage1D(texture, levels, internalformat, width)',
  glTextureStorage2D = 'glTextureStorage2D(texture, levels, internalformat, width, height)',
  glTextureStorage2DMultisample = 'glTextureStorage2DMultisample(texture, samples, internalformat, width, height, fixedsamplelocations)',
  glTextureStorage3D = 'glTextureStorage3D(texture, levels, internalformat, width, height, depth)',
  glTextureStorage3DMultisample = 'glTextureStorage3DMultisample(texture, samples, internalformat, width, height, depth, fixedsamplelocations)',
  glTextureSubImage1D = 'glTextureSubImage1D(texture, level, xoffset, width, format, type, pixels)',
  glTextureSubImage2D = 'glTextureSubImage2D(texture, level, xoffset, yoffset, width, height, format, type, pixels)',
  glTextureSubImage3D = 'glTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels)',
  glTextureView = 'glTextureView(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers)',
  glTransformFeedbackBufferBase = 'glTransformFeedbackBufferBase(xfb, index, buffer)',
  glTransformFeedbackBufferRange = 'glTransformFeedbackBufferRange(xfb, index, buffer, offset, size)',
  glTransformFeedbackVaryings = 'glTransformFeedbackVaryings(program, count, varyings, bufferMode)',
  glUniform1f = 'glUniform1f(location, v0)',
  glUniform1fv = 'glUniform1fv(location, count, value)',
  glUniform1i = 'glUniform1i(location, v0)',
  glUniform1iv = 'glUniform1iv(location, count, value)',
  glUniform1ui = 'glUniform1ui(location, v0)',
  glUniform1uiv = 'glUniform1uiv(location, count, value)',
  glUniform2f = 'glUniform2f(location, v0, v1)',
  glUniform2fv = 'glUniform2fv(location, count, value)',
  glUniform2i = 'glUniform2i(location, v0, v1)',
  glUniform2iv = 'glUniform2iv(location, count, value)',
  glUniform2ui = 'glUniform2ui(location, v0, v1)',
  glUniform2uiv = 'glUniform2uiv(location, count, value)',
  glUniform3f = 'glUniform3f(location, v0, v1, v2)',
  glUniform3fv = 'glUniform3fv(location, count, value)',
  glUniform3i = 'glUniform3i(location, v0, v1, v2)',
  glUniform3iv = 'glUniform3iv(location, count, value)',
  glUniform3ui = 'glUniform3ui(location, v0, v1, v2)',
  glUniform3uiv = 'glUniform3uiv(location, count, value)',
  glUniform4f = 'glUniform4f(location, v0, v1, v2, v3)',
  glUniform4fv = 'glUniform4fv(location, count, value)',
  glUniform4i = 'glUniform4i(location, v0, v1, v2, v3)',
  glUniform4iv = 'glUniform4iv(location, count, value)',
  glUniform4ui = 'glUniform4ui(location, v0, v1, v2, v3)',
  glUniform4uiv = 'glUniform4uiv(location, count, value)',
  glUniformBlockBinding = 'glUniformBlockBinding(program, uniformBlockIndex, uniformBlockBinding)',
  glUniformMatrix2fv = 'glUniformMatrix2fv(location, count, transpose, value)',
  glUniformMatrix2x3fv = 'glUniformMatrix2x3fv(location, count, transpose, value)',
  glUniformMatrix2x4fv = 'glUniformMatrix2x4fv(location, count, transpose, value)',
  glUniformMatrix3fv = 'glUniformMatrix3fv(location, count, transpose, value)',
  glUniformMatrix3x2fv = 'glUniformMatrix3x2fv(location, count, transpose, value)',
  glUniformMatrix3x4fv = 'glUniformMatrix3x4fv(location, count, transpose, value)',
  glUniformMatrix4fv = 'glUniformMatrix4fv(location, count, transpose, value)',
  glUniformMatrix4x2fv = 'glUniformMatrix4x2fv(location, count, transpose, value)',
  glUniformMatrix4x3fv = 'glUniformMatrix4x3fv(location, count, transpose, value)',
  glUniformSubroutinesuiv = 'glUniformSubroutinesuiv(shadertype, count, indices)',
  glUnmapBuffer = 'glUnmapBuffer(target)',
  glUnmapNamedBuffer = 'glUnmapNamedBuffer(buffer)',
  glUseProgram = 'glUseProgram(program)',
  glUseProgramStages = 'glUseProgramStages(pipeline, stages, program)',
  glValidateProgram = 'glValidateProgram(program)',
  glValidateProgramPipeline = 'glValidateProgramPipeline(pipeline)',
  glVertexArrayAttribBinding = 'glVertexArrayAttribBinding(vaobj, attribindex, bindingindex)',
  glVertexArrayAttribFormat = 'glVertexArrayAttribFormat(vaobj, attribindex, size, type, normalized, relativeoffset)',
  glVertexArrayAttribIFormat = 'glVertexArrayAttribIFormat(vaobj, attribindex, size, type, relativeoffset)',
  glVertexArrayAttribLFormat = 'glVertexArrayAttribLFormat(vaobj, attribindex, size, type, relativeoffset)',
  glVertexArrayBindingDivisor = 'glVertexArrayBindingDivisor(vaobj, bindingindex, divisor)',
  glVertexArrayElementBuffer = 'glVertexArrayElementBuffer(vaobj, buffer)',
  glVertexArrayVertexBuffer = 'glVertexArrayVertexBuffer(vaobj, bindingindex, buffer, offset, stride)',
  glVertexArrayVertexBuffers = 'glVertexArrayVertexBuffers(vaobj, first, count, buffers, offsets, strides)',
  glVertexAttrib1d = 'glVertexAttrib1d(index, v0)',
  glVertexAttrib1dv = 'glVertexAttrib1dv(index, v)',
  glVertexAttrib1f = 'glVertexAttrib1f(index, v0)',
  glVertexAttrib1fv = 'glVertexAttrib1fv(index, v)',
  glVertexAttrib1s = 'glVertexAttrib1s(index, v0)',
  glVertexAttrib1sv = 'glVertexAttrib1sv(index, v)',
  glVertexAttrib2d = 'glVertexAttrib2d(index, v0, v1)',
  glVertexAttrib2dv = 'glVertexAttrib2dv(index, v)',
  glVertexAttrib2f = 'glVertexAttrib2f(index, v0, v1)',
  glVertexAttrib2fv = 'glVertexAttrib2fv(index, v)',
  glVertexAttrib2s = 'glVertexAttrib2s(index, v0, v1)',
  glVertexAttrib2sv = 'glVertexAttrib2sv(index, v)',
  glVertexAttrib3d = 'glVertexAttrib3d(index, v0, v1, v2)',
  glVertexAttrib3dv = 'glVertexAttrib3dv(index, v)',
  glVertexAttrib3f = 'glVertexAttrib3f(index, v0, v1, v2)',
  glVertexAttrib3fv = 'glVertexAttrib3fv(index, v)',
  glVertexAttrib3s = 'glVertexAttrib3s(index, v0, v1, v2)',
  glVertexAttrib3sv = 'glVertexAttrib3sv(index, v)',
  glVertexAttrib4Nbv = 'glVertexAttrib4Nbv(index, v)',
  glVertexAttrib4Niv = 'glVertexAttrib4Niv(index, v)',
  glVertexAttrib4Nsv = 'glVertexAttrib4Nsv(index, v)',
  glVertexAttrib4Nub = 'glVertexAttrib4Nub(index, v0, v1, v2, v3)',
  glVertexAttrib4Nubv = 'glVertexAttrib4Nubv(index, v)',
  glVertexAttrib4Nuiv = 'glVertexAttrib4Nuiv(index, v)',
  glVertexAttrib4Nusv = 'glVertexAttrib4Nusv(index, v)',
  glVertexAttrib4bv = 'glVertexAttrib4bv(index, v)',
  glVertexAttrib4d = 'glVertexAttrib4d(index, v0, v1, v2, v3)',
  glVertexAttrib4dv = 'glVertexAttrib4dv(index, v)',
  glVertexAttrib4f = 'glVertexAttrib4f(index, v0, v1, v2, v3)',
  glVertexAttrib4fv = 'glVertexAttrib4fv(index, v)',
  glVertexAttrib4iv = 'glVertexAttrib4iv(index, v)',
  glVertexAttrib4s = 'glVertexAttrib4s(index, v0, v1, v2, v3)',
  glVertexAttrib4sv = 'glVertexAttrib4sv(index, v)',
  glVertexAttrib4ubv = 'glVertexAttrib4ubv(index, v)',
  glVertexAttrib4uiv = 'glVertexAttrib4uiv(index, v)',
  glVertexAttrib4usv = 'glVertexAttrib4usv(index, v)',
  glVertexAttribBinding = 'glVertexAttribBinding(attribindex, bindingindex)',
  glVertexAttribDivisor = 'glVertexAttribDivisor(index, divisor)',
  glVertexAttribFormat = 'glVertexAttribFormat(attribindex, size, type, normalized, relativeoffset)',
  glVertexAttribI1i = 'glVertexAttribI1i(index, v0)',
  glVertexAttribI1iv = 'glVertexAttribI1iv(index, v)',
  glVertexAttribI1ui = 'glVertexAttribI1ui(index, v0)',
  glVertexAttribI1uiv = 'glVertexAttribI1uiv(index, v)',
  glVertexAttribI2i = 'glVertexAttribI2i(index, v0, v1)',
  glVertexAttribI2iv = 'glVertexAttribI2iv(index, v)',
  glVertexAttribI2ui = 'glVertexAttribI2ui(index, v0, v1)',
  glVertexAttribI2uiv = 'glVertexAttribI2uiv(index, v)',
  glVertexAttribI3i = 'glVertexAttribI3i(index, v0, v1, v2)',
  glVertexAttribI3iv = 'glVertexAttribI3iv(index, v)',
  glVertexAttribI3ui = 'glVertexAttribI3ui(index, v0, v1, v2)',
  glVertexAttribI3uiv = 'glVertexAttribI3uiv(index, v)',
  glVertexAttribI4bv = 'glVertexAttribI4bv(index, v)',
  glVertexAttribI4i = 'glVertexAttribI4i(index, v0, v1, v2, v3)',
  glVertexAttribI4iv = 'glVertexAttribI4iv(index, v)',
  glVertexAttribI4sv = 'glVertexAttribI4sv(index, v)',
  glVertexAttribI4ubv = 'glVertexAttribI4ubv(index, v)',
  glVertexAttribI4ui = 'glVertexAttribI4ui(index, v0, v1, v2, v3)',
  glVertexAttribI4uiv = 'glVertexAttribI4uiv(index, v)',
  glVertexAttribI4usv = 'glVertexAttribI4usv(index, v)',
  glVertexAttribIFormat = 'glVertexAttribIFormat(attribindex, size, type, relativeoffset)',
  glVertexAttribIPointer = 'glVertexAttribIPointer(index, size, type, stride, pointer)',
  glVertexAttribL1d = 'glVertexAttribL1d(index, v0)',
  glVertexAttribL1dv = 'glVertexAttribL1dv(index, v)',
  glVertexAttribL2d = 'glVertexAttribL2d(index, v0, v1)',
  glVertexAttribL2dv = 'glVertexAttribL2dv(index, v)',
  glVertexAttribL3d = 'glVertexAttribL3d(index, v0, v1, v2)',
  glVertexAttribL3dv = 'glVertexAttribL3dv(index, v)',
  glVertexAttribL4d = 'glVertexAttribL4d(index, v0, v1, v2, v3)',
  glVertexAttribL4dv = 'glVertexAttribL4dv(index, v)',
  glVertexAttribLFormat = 'glVertexAttribLFormat(attribindex, size, type, relativeoffset)',
  glVertexAttribLPointer = 'glVertexAttribLPointer(index, size, type, stride, pointer)',
  glVertexAttribP1ui = 'glVertexAttribP1ui(index, type, normalized, value)',
  glVertexAttribP2ui = 'glVertexAttribP2ui(index, type, normalized, value)',
  glVertexAttribP3ui = 'glVertexAttribP3ui(index, type, normalized, value)',
  glVertexAttribP4ui = 'glVertexAttribP4ui(index, type, normalized, value)',
  glVertexAttribPointer = 'glVertexAttribPointer(index, size, type, normalized, stride, pointer)',
  glVertexBindingDivisor = 'glVertexBindingDivisor(bindingindex, divisor)',
  glViewport = 'glViewport(x, y, width, height)',
  glViewportArrayv = 'glViewportArrayv(first, count, v)',
  glViewportIndexedf = 'glViewportIndexedf(index, x, y, w, h)',
  glViewportIndexedfv = 'glViewportIndexedfv(index, v)',
  glWaitSync = 'glWaitSync(sync, flags, timeout)',
}

local docs = {}
for i = 1, #signatures do
  docs[i] = '```c\n' .. table.concat(signatures[i], '\n') .. '\n```\n' .. descriptions[i]
end

return {
  docs = docs,
  insert = insert,
  signatures,
}
